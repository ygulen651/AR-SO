import {ActionFunction} from 'xstate'
import {ActorRef} from 'xstate'
import {ActorRefFromLogic} from 'xstate'
import {AnyActorLogic} from 'xstate'
import {AnyActorRef} from 'xstate'
import {AnyEventObject} from 'xstate'
import type {ClientPerspective} from '@sanity/client'
import {ConditionalRequired} from 'xstate'
import type {ContentSourceMap} from '@sanity/client'
import type {ContentSourceMapDocuments} from '@sanity/client'
import {DocumentSchema} from '@sanity/visual-editing-types'
import {DoneStateEvent} from 'xstate'
import {EventObject} from 'xstate'
import {GetConcreteByKey} from 'xstate'
import {InputFrom} from 'xstate'
import {InsertMenuOptions} from '@sanity/visual-editing-types'
import {IsNotNever} from 'xstate'
import {ListenInput} from '@sanity/comlink'
import {MachineSnapshot} from 'xstate'
import {Message} from '@sanity/comlink'
import {MessageData} from '@sanity/comlink'
import {MessageType} from '@sanity/comlink'
import {MetaObject} from 'xstate'
import {MSG_RESPONSE} from '@sanity/comlink'
import type {MutationEvent} from '@sanity/client'
import {NonReducibleUnknown} from 'xstate'
import {ObservableActorLogic} from 'xstate'
import {Path} from '@sanity/client/csm'
import {PreviewSnapshot} from '@sanity/visual-editing-types'
import {ProtocolMessage} from '@sanity/comlink'
import type {QueryParams} from '@sanity/client'
import type {ReconnectEvent} from '@sanity/client'
import {RequestMachineContext} from '@sanity/comlink'
import {RequiredActorOptions} from 'xstate'
import {RequiredLogicInput} from 'xstate'
import {ResolvedSchemaTypeMap} from '@sanity/visual-editing-types'
import {ResponseMessage} from '@sanity/comlink'
import type {SanityDocument} from '@sanity/client'
import {SanityNode} from '@sanity/visual-editing-types'
import {SanityStegaNode} from '@sanity/visual-editing-types'
import {SchemaArrayItem} from '@sanity/visual-editing-types'
import {SchemaArrayNode} from '@sanity/visual-editing-types'
import {SchemaBooleanNode} from '@sanity/visual-editing-types'
import {SchemaInlineNode} from '@sanity/visual-editing-types'
import {SchemaNode} from '@sanity/visual-editing-types'
import {SchemaNullNode} from '@sanity/visual-editing-types'
import {SchemaNumberNode} from '@sanity/visual-editing-types'
import {SchemaObjectField} from '@sanity/visual-editing-types'
import {SchemaObjectNode} from '@sanity/visual-editing-types'
import {SchemaStringNode} from '@sanity/visual-editing-types'
import {SchemaType} from '@sanity/visual-editing-types'
import {SchemaUnionNode} from '@sanity/visual-editing-types'
import {SchemaUnionNodeOptions} from '@sanity/visual-editing-types'
import {SchemaUnionOption} from '@sanity/visual-editing-types'
import {SchemaUnknownNode} from '@sanity/visual-editing-types'
import {StateMachine} from 'xstate'
import {StateValue} from 'xstate'
import type {SyncTag} from '@sanity/client'
import {TypeSchema} from '@sanity/visual-editing-types'
import {UnresolvedPath} from '@sanity/visual-editing-types'
import {Values} from 'xstate'
import type {WelcomeEvent} from '@sanity/client'

export declare const createCompatibilityActors: <T extends Message>() => {
  listen: ObservableActorLogic<
    {
      type: string
      message: MessageEvent<ProtocolMessage>
    },
    ListenInput,
    EventObject
  >
  requestMachine: StateMachine<
    RequestMachineContext<T>,
    | {
        type: 'message'
        data: ProtocolMessage<ResponseMessage>
      }
    | {
        type: 'abort'
      },
    {
      'listen for response'?:
        | ActorRefFromLogic<
            ObservableActorLogic<
              MessageEvent<ProtocolMessage<ResponseMessage>>,
              {
                requestId: string
                sources: Set<MessageEventSource>
                signal?: AbortSignal
              },
              EventObject
            >
          >
        | undefined
    },
    {
      src: 'listen'
      logic: ObservableActorLogic<
        MessageEvent<ProtocolMessage<ResponseMessage>>,
        {
          requestId: string
          sources: Set<MessageEventSource>
          signal?: AbortSignal
        },
        EventObject
      >
      id: 'listen for response'
    },
    Values<{
      'send message': {
        type: 'send message'
        params: {
          message: ProtocolMessage
        }
      }
      'on success': {
        type: 'on success'
        params: NonReducibleUnknown
      }
      'on fail': {
        type: 'on fail'
        params: NonReducibleUnknown
      }
      'on abort': {
        type: 'on abort'
        params: NonReducibleUnknown
      }
    }>,
    {
      type: 'expectsResponse'
      params: unknown
    },
    'initialTimeout' | 'responseTimeout',
    'idle' | 'sending' | 'awaiting' | 'success' | 'aborted' | 'failed',
    string,
    {
      channelId: string
      data?: T['data']
      domain: string
      expectResponse?: boolean
      from: string
      parentRef: AnyActorRef
      resolvable?: PromiseWithResolvers<T['response']>
      responseTimeout?: number
      responseTo?: string
      signal?: AbortSignal
      sources: Set<MessageEventSource> | MessageEventSource
      suppressWarnings?: boolean
      targetOrigin: string
      to: string
      type: T['type']
    },
    {
      requestId: string
      response: T['response'] | null
      responseTo: string | undefined
    },
    | {
        type: 'request.failed'
        requestId: string
      }
    | {
        type: 'request.aborted'
        requestId: string
      }
    | {
        type: 'request.success'
        requestId: string
        response: MessageData | null
        responseTo: string | undefined
      },
    MetaObject,
    {
      readonly context: ({
        input,
      }: {
        spawn: {
          <TSrc extends 'listen'>(
            logic: TSrc,
            ...[options]: {
              src: 'listen'
              logic: ObservableActorLogic<
                MessageEvent<ProtocolMessage<ResponseMessage>>,
                {
                  requestId: string
                  sources: Set<MessageEventSource>
                  signal?: AbortSignal
                },
                EventObject
              >
              id: 'listen for response'
            } extends infer T_1
              ? T_1 extends {
                  src: 'listen'
                  logic: ObservableActorLogic<
                    MessageEvent<ProtocolMessage<ResponseMessage>>,
                    {
                      requestId: string
                      sources: Set<MessageEventSource>
                      signal?: AbortSignal
                    },
                    EventObject
                  >
                  id: 'listen for response'
                }
                ? T_1 extends {
                    src: TSrc
                  }
                  ? ConditionalRequired<
                      [
                        options?:
                          | ({
                              id?: T_1['id'] | undefined
                              systemId?: string
                              input?: InputFrom<T_1['logic']> | undefined
                              syncSnapshot?: boolean
                            } & {[K in RequiredActorOptions<T_1>]: unknown})
                          | undefined,
                      ],
                      IsNotNever<RequiredActorOptions<T_1>>
                    >
                  : never
                : never
              : never
          ): ActorRefFromLogic<
            GetConcreteByKey<
              {
                src: 'listen'
                logic: ObservableActorLogic<
                  MessageEvent<ProtocolMessage<ResponseMessage>>,
                  {
                    requestId: string
                    sources: Set<MessageEventSource>
                    signal?: AbortSignal
                  },
                  EventObject
                >
                id: 'listen for response'
              },
              'src',
              TSrc
            >['logic']
          >
          <TLogic extends AnyActorLogic>(
            src: TLogic,
            ...[options]: ConditionalRequired<
              [
                options?:
                  | ({
                      id?: never
                      systemId?: string
                      input?: InputFrom<TLogic> | undefined
                      syncSnapshot?: boolean
                    } & {[K in RequiredLogicInput<TLogic>]: unknown})
                  | undefined,
              ],
              IsNotNever<RequiredLogicInput<TLogic>>
            >
          ): ActorRefFromLogic<TLogic>
        }
        input: {
          channelId: string
          data?: T['data']
          domain: string
          expectResponse?: boolean
          from: string
          parentRef: AnyActorRef
          resolvable?: PromiseWithResolvers<T['response']>
          responseTimeout?: number
          responseTo?: string
          signal?: AbortSignal
          sources: Set<MessageEventSource> | MessageEventSource
          suppressWarnings?: boolean
          targetOrigin: string
          to: string
          type: T['type']
        }
        self: ActorRef<
          MachineSnapshot<
            RequestMachineContext<T>,
            | {
                type: 'message'
                data: ProtocolMessage<ResponseMessage>
              }
            | {
                type: 'abort'
              },
            Record<string, AnyActorRef | undefined>,
            StateValue,
            string,
            unknown,
            any,
            any
          >,
          | {
              type: 'message'
              data: ProtocolMessage<ResponseMessage>
            }
          | {
              type: 'abort'
            },
          AnyEventObject
        >
      }) => {
        channelId: string
        data: T['data'] | undefined
        domain: string
        expectResponse: boolean
        from: string
        id: string
        parentRef: AnyActorRef
        resolvable: PromiseWithResolvers<T['response']> | undefined
        response: null
        responseTimeout: number | undefined
        responseTo: string | undefined
        signal: AbortSignal | undefined
        sources: Set<MessageEventSource>
        suppressWarnings: boolean | undefined
        targetOrigin: string
        to: string
        type: T['type']
      }
      readonly initial: 'idle'
      readonly on: {
        readonly abort: '.aborted'
      }
      readonly states: {
        readonly idle: {
          readonly after: {
            readonly initialTimeout: readonly [
              {
                readonly target: 'sending'
              },
            ]
          }
        }
        readonly sending: {
          readonly entry: {
            readonly type: 'send message'
            readonly params: ({
              context,
            }: {
              context: RequestMachineContext<T>
              event:
                | {
                    type: 'message'
                    data: ProtocolMessage<ResponseMessage>
                  }
                | {
                    type: 'abort'
                  }
            }) => {
              message: {
                channelId: string
                data: MessageData
                domain: string
                from: string
                id: string
                to: string
                type: string
                responseTo: string | undefined
              }
            }
          }
          readonly always: readonly [
            {
              readonly guard: 'expectsResponse'
              readonly target: 'awaiting'
            },
            'success',
          ]
        }
        readonly awaiting: {
          readonly invoke: {
            readonly id: 'listen for response'
            readonly src: 'listen'
            readonly input: ({
              context,
            }: {
              context: RequestMachineContext<T>
              event:
                | {
                    type: 'message'
                    data: ProtocolMessage<ResponseMessage>
                  }
                | {
                    type: 'abort'
                  }
              self: ActorRef<
                MachineSnapshot<
                  RequestMachineContext<T>,
                  | {
                      type: 'message'
                      data: ProtocolMessage<ResponseMessage>
                    }
                  | {
                      type: 'abort'
                    },
                  Record<string, AnyActorRef>,
                  StateValue,
                  string,
                  unknown,
                  any,
                  any
                >,
                | {
                    type: 'message'
                    data: ProtocolMessage<ResponseMessage>
                  }
                | {
                    type: 'abort'
                  },
                AnyEventObject
              >
            }) => {
              requestId: string
              sources: Set<MessageEventSource>
              signal: AbortSignal | undefined
            }
            readonly onError: 'aborted'
          }
          readonly after: {
            readonly responseTimeout: 'failed'
          }
          readonly on: {
            readonly message: {
              readonly actions: ActionFunction<
                RequestMachineContext<T>,
                {
                  type: 'message'
                  data: ProtocolMessage<ResponseMessage>
                },
                | {
                    type: 'message'
                    data: ProtocolMessage<ResponseMessage>
                  }
                | {
                    type: 'abort'
                  },
                undefined,
                {
                  src: 'listen'
                  logic: ObservableActorLogic<
                    MessageEvent<ProtocolMessage<ResponseMessage>>,
                    {
                      requestId: string
                      sources: Set<MessageEventSource>
                      signal?: AbortSignal
                    },
                    EventObject
                  >
                  id: 'listen for response'
                },
                never,
                never,
                never,
                never
              >
              readonly target: 'success'
            }
          }
        }
        readonly failed: {
          readonly type: 'final'
          readonly entry: 'on fail'
        }
        readonly success: {
          readonly type: 'final'
          readonly entry: 'on success'
        }
        readonly aborted: {
          readonly type: 'final'
          readonly entry: 'on abort'
        }
      }
      readonly output: ({
        context,
        self,
      }: {
        context: RequestMachineContext<T>
        event: DoneStateEvent<unknown>
        self: ActorRef<
          MachineSnapshot<
            RequestMachineContext<T>,
            | {
                type: 'message'
                data: ProtocolMessage<ResponseMessage>
              }
            | {
                type: 'abort'
              },
            Record<string, AnyActorRef>,
            StateValue,
            string,
            unknown,
            any,
            any
          >,
          | {
              type: 'message'
              data: ProtocolMessage<ResponseMessage>
            }
          | {
              type: 'abort'
            },
          AnyEventObject
        >
      }) => {
        requestId: string
        response: T['response'] | null
        responseTo: string | undefined
      }
    }
  >
}

export {DocumentSchema}

/**
 * Preview frame history refresh event, emitted by Presentation Tool
 * @public
 */
export declare type HistoryRefresh =
  | {
      /**
       * source 'manual' means the refresh button were clicked by the user
       */
      source: 'manual'
      /**
       * If true then there's either preview-kit or a loader connected on the page
       */
      livePreviewEnabled: boolean
    }
  | {
      /**
       * source 'mutation' means a document were mutated and the preview might need to refresh
       */
      source: 'mutation'
      /**
       * If true then there's either preview-kit or a loader connected on the page
       */
      livePreviewEnabled: boolean
      /**
       * Select metadata about the document that were mutated
       * If it's prefixed with `drafts.` then it's a draft document, otherwise it's a published document.
       */
      document: {
        /**
         * If it's prefixed with `drafts.` then it's a draft document, otherwise it's a published document.
         */
        _id: string
        /**
         * The document type is frequently used in `revalidateTag` scenarios with Next.js App Router
         */
        _type: string
        /**
         * The document revision, can be used to dedupe requests, as we always send two due to debouncing and handling Content Lake eventual consistency
         */
        _rev: string
        /**
         * If the document has a top level slug field named `slug` with the type `slug`, then it'll be included here
         */
        slug?: {
          current?: string | null
        }
      }
    }

/**
 * Preview frame history update
 * @public
 */
export declare type HistoryUpdate = {
  type: 'push' | 'pop' | 'replace'
  title?: string
  url: string
}

export {InsertMenuOptions}

export declare function isMaybePresentation(): boolean

export declare function isMaybePreviewIframe(): boolean

export declare function isMaybePreviewWindow(): boolean

export {ListenInput}

/**
 * @public
 */
export declare type LoaderControllerMsg =
  | {
      type: 'loader/perspective'
      data: {
        projectId: string
        dataset: string
        perspective: ClientPerspective
      }
    }
  | {
      type: 'loader/query-change'
      data: {
        projectId: string
        dataset: string
        perspective: ClientPerspective
        query: string
        params: QueryParams
        result: any
        resultSourceMap?: ContentSourceMap
        tags?: SyncTag[]
      }
    }

/**
 * @public
 */
export declare type LoaderNodeMsg =
  | {
      type: 'loader/query-listen'
      data: {
        projectId: string
        dataset: string
        perspective: ClientPerspective
        query: string
        params: QueryParams
        /**
         * If above 0, then the loader will fire listen events on a heartbeat interval,
         * allowing Presentation Tool to detect when it's no longer necessary to subscribe to a query.
         */
        heartbeat?: number
      }
    }
  | {
      /**
       * Sends over the CSM reported documents in use on the page. If there are multiple queries and thus
       * multiple CSM's, they're all deduped and concatenated into a single list.
       */
      type: 'loader/documents'
      data: {
        projectId: string
        dataset: string
        perspective: ClientPerspective
        documents: ContentSourceMapDocuments
      }
    }

export {Message}

export {MessageData}

export {MessageType}

export {MSG_RESPONSE}

export {Path}

/**
 * @public
 */
export declare type PreviewKitNodeMsg = {
  /**
   * Sends over the CSM reported documents in use on the page. If there are multiple queries and thus
   * multiple CSM's, they're all deduped and concatenated into a single list.
   */
  type: 'preview-kit/documents'
  data: {
    projectId: string
    dataset: string
    perspective: ClientPerspective
    documents: ContentSourceMapDocuments
  }
}

export {PreviewSnapshot}

export {ProtocolMessage}

export {RequestMachineContext}

export {ResolvedSchemaTypeMap}

export {ResponseMessage}

export {SanityNode}

export {SanityStegaNode}

export {SchemaArrayItem}

export {SchemaArrayNode}

export {SchemaBooleanNode}

export {SchemaInlineNode}

export {SchemaNode}

export {SchemaNullNode}

export {SchemaNumberNode}

export {SchemaObjectField}

export {SchemaObjectNode}

export {SchemaStringNode}

export {SchemaType}

export {SchemaUnionNode}

export {SchemaUnionNodeOptions}

export {SchemaUnionOption}

export {SchemaUnknownNode}

/**
 * @public
 */
export declare type Serializable = SerializablePrimitive | SerializableObject | SerializableArray

/**
 * @public
 */
export declare type SerializableArray = Serializable[]

/**
 * @public
 */
export declare type SerializableObject = {
  [key: string]: Serializable
}

/**
 * @public
 */
export declare type SerializablePrimitive = string | number | boolean | null | undefined

export {TypeSchema}

export {UnresolvedPath}

/**
 * @public
 */
export declare type VisualEditingControllerMsg =
  | {
      type: 'presentation/focus'
      data: {
        id: string
        path: string
      }
    }
  | {
      type: 'presentation/blur'
      data: undefined
    }
  | {
      type: 'presentation/navigate'
      data: HistoryUpdate
    }
  | {
      type: 'presentation/toggle-overlay'
      data: undefined
    }
  | {
      type: 'presentation/refresh'
      data: HistoryRefresh
    }
  | {
      type: 'presentation/perspective'
      data: {
        perspective: ClientPerspective
      }
    }
  /**
   * @deprecated switch to explict schema fetching (using
   * 'visual-editing/schema') at next major
   */
  | {
      type: 'presentation/schema'
      data: {
        schema: SchemaType[]
      }
    }
  | {
      type: 'presentation/preview-snapshots'
      data: {
        snapshots: PreviewSnapshot[]
      }
    }
  | {
      type: 'presentation/snapshot-event'
      data: {
        event: ReconnectEvent | WelcomeEvent | MutationEvent
      }
    }
  | {
      type: 'presentation/shared-state'
      data: {
        key: string
        value?: Serializable
      }
    }
  | {
      /**
       * Special event where Presentation Tool is unable to connect to a target iframe or popup window, and is asking for status with `targetOrigin: *` to detect
       * if the URL origin is misconfigured. Presentation doesn't send any data, as any listener can see it.
       */
      type: 'presentation/status'
      data: undefined
    }

/**
 * @public
 */
export declare type VisualEditingNodeMsg =
  | {
      type: 'visual-editing/focus'
      data: SanityNode | SanityStegaNode
    }
  | {
      type: 'overlay/focus'
      data: SanityNode | SanityStegaNode
    }
  | {
      type: 'visual-editing/navigate'
      data: HistoryUpdate
    }
  | {
      type: 'overlay/navigate'
      data: HistoryUpdate
    }
  | {
      type: 'visual-editing/toggle'
      data: {
        enabled: boolean
      }
    }
  | {
      type: 'overlay/toggle'
      data: {
        enabled: boolean
      }
    }
  | {
      type: 'visual-editing/meta'
      data: {
        title: string
      }
    }
  | {
      type: 'visual-editing/documents'
      data: {
        projectId?: string
        dataset?: string
        perspective: ClientPerspective
        documents: ContentSourceMapDocuments
      }
    }
  | {
      type: 'visual-editing/preview-snapshots'
      data: undefined
      response: {
        snapshots: PreviewSnapshot[]
      }
    }
  | {
      type: 'visual-editing/refreshing'
      data: HistoryRefresh
    }
  | {
      type: 'visual-editing/refreshed'
      data: HistoryRefresh
    }
  | {
      type: 'visual-editing/schema'
      data: undefined
      response: {
        schema: SchemaType[]
      }
    }
  | {
      type: 'visual-editing/schema-union-types'
      data: {
        paths: UnresolvedPath[]
      }
      response: {
        types: ResolvedSchemaTypeMap
      }
    }
  | {
      type: 'visual-editing/observe-documents'
      data: {
        documentIds: string[]
      }
    }
  | {
      type: 'visual-editing/fetch-snapshot'
      data: {
        documentId: string
      }
      response: {
        snapshot: SanityDocument<Record<string, any>> | undefined | void
      }
    }
  | {
      type: 'visual-editing/mutate'
      data: {
        transactionId: string | undefined
        mutations: any[]
      }
      response: any
    }
  | {
      type: 'visual-editing/snapshot-welcome'
      data: undefined
      response: {
        event: WelcomeEvent
      }
    }
  | {
      type: 'visual-editing/fetch-perspective'
      data: undefined
      response: {
        perspective: ClientPerspective
      }
    }
  | {
      type: 'visual-editing/features'
      data: undefined
      response: {
        features: Record<string, boolean>
      }
    }
  | {
      type: 'visual-editing/shared-state'
      data: undefined
      response: {
        state: SerializableObject
      }
    }
  | {
      type: 'visual-editing/telemetry-log'
      data: {
        event: any
        data: any
      }
    }
  | {
      /**
       * Special event related to the `presentation/status` event, where comlink is unable to connect,
       * and we're asking for some status information to detect if the URL origin is misconfigured.
       */
      type: 'visual-editing/status'
      data: {
        origin: string
      }
    }

export {}
