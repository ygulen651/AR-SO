{"version":3,"file":"index.js","sources":["../src/auth/authStateType.ts","../src/utils/ids.ts","../src/store/createSanityInstance.ts","../src/utils/getEnv.ts","../src/store/createStoreState.ts","../src/store/createStoreInstance.ts","../src/store/createActionBinder.ts","../src/store/createStateSourceAction.ts","../src/auth/authConstants.ts","../src/auth/refreshStampedToken.ts","../src/auth/subscribeToStateAndFetchCurrentUser.ts","../src/auth/utils.ts","../src/auth/subscribeToStorageEventsAndSetToken.ts","../src/auth/authStore.ts","../src/auth/handleAuthCallback.ts","../src/auth/logout.ts","../src/client/clientStore.ts","../src/comlink/controller/actions/destroyController.ts","../src/comlink/controller/actions/getOrCreateChannel.ts","../src/comlink/controller/actions/getOrCreateController.ts","../src/comlink/controller/actions/releaseChannel.ts","../src/comlink/controller/comlinkControllerStore.ts","../src/comlink/node/actions/getOrCreateNode.ts","../src/comlink/node/actions/releaseNode.ts","../src/comlink/node/comlinkNodeStore.ts","../src/utils/createFetcherStore.ts","../src/datasets/datasets.ts","../src/document/actions.ts","../src/document/documentConstants.ts","../src/document/patchOperations.ts","../src/document/processMutations.ts","../src/document/listen.ts","../src/document/_synchronous-groq-js.mjs","../src/document/diffPatch.ts","../src/utils/MultiKeyWeakMap.ts","../src/document/permissions.ts","../src/document/processActions.ts","../src/document/reducers.ts","../src/document/events.ts","../src/document/sharedListener.ts","../src/document/documentStore.ts","../src/document/applyDocumentActions.ts","../src/query/queryStoreConstants.ts","../src/query/reducers.ts","../src/query/queryStore.ts","../src/utils/hashString.ts","../src/preview/previewConstants.ts","../src/preview/util.ts","../src/preview/previewQuery.ts","../src/preview/subscribeToStateAndFetchBatches.ts","../src/preview/previewStore.ts","../src/preview/getPreviewState.ts","../src/preview/resolvePreview.ts","../src/project/project.ts","../src/projection/util.ts","../src/projection/projectionQuery.ts","../src/projection/subscribeToStateAndFetchBatches.ts","../src/projection/projectionStore.ts","../src/projection/getProjectionState.ts","../src/projection/resolveProjection.ts","../src/projects/projects.ts","../src/users/usersConstants.ts","../src/users/reducers.ts","../src/users/usersStore.ts","../src/utils/createGroqSearchFilter.ts","../src/version.ts"],"sourcesContent":["/**\n * Represents the various states the authentication type can be in.\n *\n * @public\n */\nexport enum AuthStateType {\n  LOGGED_IN = 'logged-in',\n  LOGGING_IN = 'logging-in',\n  ERROR = 'error',\n  LOGGED_OUT = 'logged-out',\n}\n","export function getPublishedId(id: string): string {\n  const draftsPrefix = 'drafts.'\n  return id.startsWith(draftsPrefix) ? id.slice(draftsPrefix.length) : id\n}\n\nexport function getDraftId(id: string): string {\n  const draftsPrefix = 'drafts.'\n  return id.startsWith(draftsPrefix) ? id : `${draftsPrefix}${id}`\n}\n\nexport function insecureRandomId(): string {\n  return Array.from({length: 16}, () => Math.floor(Math.random() * 16).toString(16)).join('')\n}\n","import {pick} from 'lodash-es'\n\nimport {type SanityConfig} from '../config/sanityConfig'\nimport {insecureRandomId} from '../utils/ids'\n\n/**\n * Represents a Sanity.io resource instance with its own configuration and lifecycle\n * @remarks Instances form a hierarchy through parent/child relationships\n *\n * @public\n */\nexport interface SanityInstance {\n  /**\n   * Unique identifier for this instance\n   * @remarks Generated using crypto.randomUUID()\n   */\n  readonly instanceId: string\n\n  /**\n   * Resolved configuration for this instance\n   * @remarks Merges values from parent instances where appropriate\n   */\n  readonly config: SanityConfig\n\n  /**\n   * Checks if the instance has been disposed\n   * @returns true if dispose() has been called\n   */\n  isDisposed(): boolean\n\n  /**\n   * Disposes the instance and cleans up associated resources\n   * @remarks Triggers all registered onDispose callbacks\n   */\n  dispose(): void\n\n  /**\n   * Registers a callback to be invoked when the instance is disposed\n   * @param cb - Callback to execute on disposal\n   * @returns Function to unsubscribe the callback\n   */\n  onDispose(cb: () => void): () => void\n\n  /**\n   * Gets the parent instance in the hierarchy\n   * @returns Parent instance or undefined if this is the root\n   */\n  getParent(): SanityInstance | undefined\n\n  /**\n   * Creates a child instance with merged configuration\n   * @param config - Configuration to merge with parent values\n   * @remarks Child instances inherit parent configuration but can override values\n   */\n  createChild(config: SanityConfig): SanityInstance\n\n  /**\n   * Traverses the instance hierarchy to find the first instance whose configuration\n   * matches the given target config using a shallow comparison.\n   * @param targetConfig - A partial configuration object containing key-value pairs to match.\n   * @returns The first matching instance or undefined if no match is found.\n   */\n  match(targetConfig: Partial<SanityConfig>): SanityInstance | undefined\n}\n\n/**\n * Creates a new Sanity resource instance\n * @param config - Configuration for the instance (optional)\n * @returns A configured SanityInstance\n * @remarks When creating child instances, configurations are merged with parent values\n *\n * @public\n */\nexport function createSanityInstance(config: SanityConfig = {}): SanityInstance {\n  const instanceId = crypto.randomUUID()\n  const disposeListeners = new Map<string, () => void>()\n  const disposed = {current: false}\n\n  const instance: SanityInstance = {\n    instanceId,\n    config,\n    isDisposed: () => disposed.current,\n    dispose: () => {\n      if (disposed.current) return\n      disposed.current = true\n      disposeListeners.forEach((listener) => listener())\n      disposeListeners.clear()\n    },\n    onDispose: (cb) => {\n      const listenerId = insecureRandomId()\n      disposeListeners.set(listenerId, cb)\n      return () => {\n        disposeListeners.delete(listenerId)\n      }\n    },\n    getParent: () => undefined,\n    createChild: (next) =>\n      Object.assign(\n        createSanityInstance({\n          ...config,\n          ...next,\n          ...(config.auth === next.auth\n            ? config.auth\n            : config.auth && next.auth && {auth: {...config.auth, ...next.auth}}),\n        }),\n        {getParent: () => instance},\n      ),\n    match: (targetConfig) => {\n      if (\n        Object.entries(pick(targetConfig, 'auth', 'projectId', 'dataset')).every(\n          ([key, value]) => config[key as keyof SanityConfig] === value,\n        )\n      ) {\n        return instance\n      }\n\n      const parent = instance.getParent()\n      if (parent) return parent.match(targetConfig)\n      return undefined\n    },\n  }\n\n  return instance\n}\n","// Local type declaration for Remix\ntype WindowWithEnv = Window &\n  typeof globalThis & {\n    ENV?: Record<string, unknown>\n  }\n\ntype KnownEnvVar = 'DEV' | 'PKG_VERSION'\n\nexport function getEnv(key: KnownEnvVar): unknown {\n  if (typeof import.meta !== 'undefined' && import.meta.env) {\n    // Vite environment variables\n    return (import.meta.env as unknown as Record<string, unknown>)[key]\n  } else if (typeof process !== 'undefined' && process.env) {\n    // Node.js or server-side environment variables\n    return process.env[key]\n  } else if (typeof window !== 'undefined' && (window as WindowWithEnv).ENV) {\n    // Remix-style client-side environment variables\n    return (window as WindowWithEnv).ENV?.[key]\n  }\n  return undefined\n}\n","import {Observable} from 'rxjs'\nimport {devtools, type DevtoolsOptions} from 'zustand/middleware'\nimport {createStore} from 'zustand/vanilla'\n\n/**\n * Represents a reactive store state container with multiple access patterns\n */\nexport interface StoreState<TState> {\n  /**\n   * Gets the current state value\n   *\n   * @remarks\n   * This is a direct synchronous accessor that doesn't trigger subscriptions\n   */\n  get: () => TState\n\n  /**\n   * Updates the store state\n   * @param name - Action name for devtools tracking\n   * @param updatedState - New state value or updater function\n   *\n   * @remarks\n   * When providing a partial object, previous top-level keys not included in\n   * the update will be preserved.\n   */\n  set: (name: string, updatedState: Partial<TState> | ((s: TState) => Partial<TState>)) => void\n\n  /**\n   * Observable stream of state changes\n   * @remarks\n   * - Emits immediately with current state on subscription\n   * - Shares underlying subscription between observers\n   * - Only emits when state reference changes\n   * - Completes when store is disposed\n   */\n  observable: Observable<TState>\n}\n\n/**\n * Creates a reactive store state container with multiple access patterns\n * @param initialState - Initial state value for the store\n * @param devToolsOptions - Configuration for Zustand devtools integration\n * @returns StoreState instance with get/set/observable interface\n *\n * @example\n * ```typescript\n * // Create a simple counter store\n * const counterStore = createStoreState({ count: 0 });\n *\n * // Update state\n * counterStore.set('increment', { count: 1 });\n *\n * // Observe changes\n * counterStore.observable.subscribe(console.log);\n * ```\n *\n * @remarks\n * Uses Zustand for state management under the hood with RxJS for observable interface.\n * Designed to work with both imperative and reactive programming patterns.\n */\nexport function createStoreState<TState>(\n  initialState: TState,\n  devToolsOptions?: DevtoolsOptions,\n): StoreState<TState> {\n  // Create underlying Zustand store with devtools integration\n  const store = createStore<TState>()(devtools(() => initialState, devToolsOptions))\n\n  return {\n    get: store.getState,\n    set: (actionKey, updatedState) => {\n      const currentState = store.getState()\n      const nextState =\n        typeof updatedState === 'function' ? updatedState(currentState) : updatedState\n\n      // Optimization: Skip update if state reference remains the same\n      if (currentState !== nextState) {\n        store.setState(nextState, false, actionKey)\n      }\n    },\n    observable: new Observable((observer) => {\n      // Emit current state immediately on subscription\n      const emit = () => observer.next(store.getState())\n      emit()\n\n      // Subscribe to Zustand store changes\n      const unsubscribe = store.subscribe(emit)\n\n      // Cleanup when observable unsubscribed\n      return () => unsubscribe()\n    }),\n  }\n}\n","import {getEnv} from '../utils/getEnv'\nimport {type SanityInstance} from './createSanityInstance'\nimport {createStoreState, type StoreState} from './createStoreState'\nimport {type StoreDefinition} from './defineStore'\n\n/**\n * Represents a running instance of a store with its own state and lifecycle\n *\n * @remarks\n * Each StoreInstance is tied to a specific SanityInstance, manages its own state,\n * and can be independently disposed when no longer needed.\n */\nexport interface StoreInstance<TState> {\n  /**\n   * Access to the reactive state container for this store instance\n   */\n  state: StoreState<TState>\n\n  /**\n   * Checks if this store instance has been disposed\n   * @returns Boolean indicating disposed state\n   */\n  isDisposed: () => void\n\n  /**\n   * Cleans up this store instance and runs any initialization cleanup functions\n   * @remarks Triggers the cleanup function returned from the initialize method\n   */\n  dispose: () => void\n}\n\n/**\n * Creates a new instance of a store from a store definition\n *\n * @param instance - The Sanity instance this store will be associated with\n * @param storeDefinition - The store definition containing initial state and initialization logic\n * @returns A store instance with state management and lifecycle methods\n *\n * @remarks\n * The store instance maintains its own state that is scoped to the given Sanity instance.\n * If the store definition includes an initialize function, it will be called during\n * instance creation, and its cleanup function will be called during disposal.\n *\n * @example\n * ```ts\n * const counterStore = defineStore({\n *   name: 'Counter',\n *   getInitialState: () => ({ count: 0 }),\n *   initialize: ({state}) => {\n *     console.log('Counter store initialized')\n *     return () => console.log('Counter store disposed')\n *   }\n * })\n *\n * const instance = createStoreInstance(sanityInstance, counterStore)\n * // Later when done with the store:\n * instance.dispose()\n * ```\n */\nexport function createStoreInstance<TState>(\n  instance: SanityInstance,\n  {name, getInitialState, initialize}: StoreDefinition<TState>,\n): StoreInstance<TState> {\n  const state = createStoreState(getInitialState(instance), {\n    enabled: !!getEnv('DEV'),\n    name: `${name}-${instance.config.projectId}.${instance.config.dataset}`,\n  })\n  const dispose = initialize?.({state, instance})\n  const disposed = {current: false}\n\n  return {\n    state,\n    dispose: () => {\n      if (disposed.current) return\n      disposed.current = true\n      dispose?.()\n    },\n    isDisposed: () => disposed.current,\n  }\n}\n","import {type SanityConfig} from '../config/sanityConfig'\nimport {type SanityInstance} from './createSanityInstance'\nimport {createStoreInstance, type StoreInstance} from './createStoreInstance'\nimport {type StoreState} from './createStoreState'\nimport {type StoreContext, type StoreDefinition} from './defineStore'\n\n/**\n * Defines a store action that operates on a specific state type\n */\nexport type StoreAction<TState, TParams extends unknown[], TReturn> = (\n  context: StoreContext<TState>,\n  ...params: TParams\n) => TReturn\n\n/**\n * Represents a store action that has been bound to a specific store instance\n */\nexport type BoundStoreAction<_TState, TParams extends unknown[], TReturn> = (\n  instance: SanityInstance,\n  ...params: TParams\n) => TReturn\n\n/**\n * Creates an action binder function that uses the provided key function\n * to determine how store instances are shared between Sanity instances\n *\n * @param keyFn - Function that generates a key from a Sanity config\n * @returns A function that binds store actions to Sanity instances\n *\n * @remarks\n * Action binders determine how store instances are shared across multiple\n * Sanity instances. The key function determines which instances share state.\n *\n * @example\n * ```ts\n * // Create a custom binder that uses a tenant ID for isolation\n * const bindActionByTenant = createActionBinder(config => config.tenantId || 'default')\n *\n * // Use the custom binder with a store definition\n * const getTenantUsers = bindActionByTenant(\n *   userStore,\n *   ({state}) => state.get().users\n * )\n * ```\n */\nexport function createActionBinder(keyFn: (config: SanityConfig) => string) {\n  const instanceRegistry = new Map<string, Set<string>>()\n  const storeRegistry = new Map<string, StoreInstance<unknown>>()\n\n  /**\n   * Binds a store action to a store definition\n   *\n   * @param storeDefinition - The store definition\n   * @param action - The action to bind\n   * @returns A function that executes the action with a Sanity instance\n   */\n  return function bindAction<TState, TParams extends unknown[], TReturn>(\n    storeDefinition: StoreDefinition<TState>,\n    action: StoreAction<TState, TParams, TReturn>,\n  ): BoundStoreAction<TState, TParams, TReturn> {\n    return function boundAction(instance: SanityInstance, ...params: TParams) {\n      const keySuffix = keyFn(instance.config)\n      const compositeKey = storeDefinition.name + (keySuffix ? `:${keySuffix}` : '')\n\n      // Get or create instance set for this composite key\n      let instances = instanceRegistry.get(compositeKey)\n      if (!instances) {\n        instances = new Set<string>()\n        instanceRegistry.set(compositeKey, instances)\n      }\n\n      // Register instance for disposal tracking\n      if (!instances.has(instance.instanceId)) {\n        instances.add(instance.instanceId)\n        instance.onDispose(() => {\n          instances.delete(instance.instanceId)\n\n          // Clean up when last instance is disposed\n          if (instances.size === 0) {\n            storeRegistry.get(compositeKey)?.dispose()\n            storeRegistry.delete(compositeKey)\n            instanceRegistry.delete(compositeKey)\n          }\n        })\n      }\n\n      // Get or create store instance\n      let storeInstance = storeRegistry.get(compositeKey)\n      if (!storeInstance) {\n        storeInstance = createStoreInstance(instance, storeDefinition)\n        storeRegistry.set(compositeKey, storeInstance)\n      }\n\n      // Execute action with store context\n      return action({instance, state: storeInstance.state as StoreState<TState>}, ...params)\n    }\n  }\n}\n\n/**\n * Binds an action to a store that's scoped to a specific project and dataset\n *\n * @remarks\n * This creates actions that operate on state isolated to a specific projectId and dataset.\n * Different project/dataset combinations will have separate states.\n *\n * @throws Error if projectId or dataset is missing from the Sanity instance config\n *\n * @example\n * ```ts\n * // Define a store\n * const documentStore = defineStore<DocumentState>({\n *   name: 'Document',\n *   getInitialState: () => ({ documents: {} }),\n *   // ...\n * })\n *\n * // Create dataset-specific actions\n * export const fetchDocument = bindActionByDataset(\n *   documentStore,\n *   ({instance, state}, documentId) => {\n *     // This state is isolated to the specific project/dataset\n *     // ...fetch logic...\n *   }\n * )\n *\n * // Usage\n * fetchDocument(sanityInstance, 'doc123')\n * ```\n */\nexport const bindActionByDataset = createActionBinder(({projectId, dataset}) => {\n  if (!projectId || !dataset) {\n    throw new Error('This API requires a project ID and dataset configured.')\n  }\n  return `${projectId}.${dataset}`\n})\n\n/**\n * Binds an action to a global store that's shared across all Sanity instances\n *\n * @remarks\n * This creates actions that operate on state shared globally across all Sanity instances.\n * Use this for features like authentication where the state should be the same\n * regardless of which project or dataset is being used.\n *\n * @example\n * ```ts\n * // Define a store\n * const authStore = defineStore<AuthState>({\n *   name: 'Auth',\n *   getInitialState: () => ({\n *     user: null,\n *     isAuthenticated: false\n *   }),\n *   // ...\n * })\n *\n * // Create global actions\n * export const getCurrentUser = bindActionGlobally(\n *   authStore,\n *   ({state}) => state.get().user\n * )\n *\n * export const login = bindActionGlobally(\n *   authStore,\n *   ({state, instance}, credentials) => {\n *     // Login logic that affects global state\n *     // ...\n *   }\n * )\n *\n * // Usage with any instance\n * getCurrentUser(sanityInstance)\n * ```\n */\nexport const bindActionGlobally = createActionBinder(() => 'global')\n","import {distinctUntilChanged, map, Observable, share, skip} from 'rxjs'\n\nimport {type StoreAction} from './createActionBinder'\nimport {type SanityInstance} from './createSanityInstance'\nimport {type StoreContext} from './defineStore'\n\n/**\n * Represents a reactive state source that provides synchronized access to store data\n *\n * @remarks\n * Designed to work with React's useSyncExternalStore hook. Provides three ways to access data:\n * 1. `getCurrent()` for synchronous current value access\n * 2. `subscribe()` for imperative change notifications\n * 3. `observable` for reactive stream access\n *\n * @public\n */\nexport interface StateSource<T> {\n  /**\n   * Subscribes to state changes with optional callback\n   * @param onStoreChanged - Called whenever relevant state changes occur\n   * @returns Unsubscribe function to clean up the subscription\n   */\n  subscribe: (onStoreChanged?: () => void) => () => void\n\n  /**\n   * Gets the current derived state value\n   *\n   * @remarks\n   * Safe to call without subscription. Will always return the latest value\n   * based on the current store state and selector parameters.\n   */\n  getCurrent: () => T\n\n  /**\n   * Observable stream of state values\n   *\n   * @remarks\n   * Shares a single underlying subscription between all observers. Emits:\n   * - Immediately with current value on subscription\n   * - On every relevant state change\n   * - Errors if selector throws\n   */\n  observable: Observable<T>\n}\n\n/**\n * Context passed to selectors when deriving state\n *\n * @remarks\n * Provides access to both the current state value and the Sanity instance,\n * allowing selectors to use configuration values when computing derived state.\n * The context is memoized for each state object and instance combination\n * to optimize performance and prevent unnecessary recalculations.\n *\n * @example\n * ```ts\n * // Using both state and instance in a selector (psuedo example)\n * const getUserByProjectId = createStateSourceAction(\n *   ({ state, instance }: SelectorContext<UsersState>, options?: ProjectHandle) => {\n *     const allUsers = state.users\n *     const projectId = options?.projectId ?? instance.config.projectId\n *     return allUsers.filter(user => user.projectId === projectId)\n *   }\n * )\n * ```\n */\nexport interface SelectorContext<TState> {\n  /**\n   * The current state object from the store\n   */\n  state: TState\n\n  /**\n   * The Sanity instance associated with this state\n   */\n  instance: SanityInstance\n}\n\n/**\n * Function type for selecting derived state from store state and parameters\n * @public\n */\nexport type Selector<TState, TParams extends unknown[], TReturn> = (\n  context: SelectorContext<TState>,\n  ...params: TParams\n) => TReturn\n\n/**\n * Configuration options for creating a state source action\n */\ninterface StateSourceOptions<TState, TParams extends unknown[], TReturn> {\n  /**\n   * Selector function that derives the desired value from store state\n   *\n   * @remarks\n   * Will be called on every store change. Should be pure function.\n   * Thrown errors will propagate to observable subscribers.\n   */\n  selector: Selector<TState, TParams, TReturn>\n\n  /**\n   * Optional setup/cleanup handler for subscriptions\n   *\n   * @param context - Store context containing state and instance\n   * @param params - Action parameters provided during invocation\n   * @returns Optional cleanup function called when subscription ends\n   */\n  onSubscribe?: (context: StoreContext<TState>, ...params: TParams) => void | (() => void)\n\n  /**\n   * Equality function to prevent unnecessary updates\n   */\n  isEqual?: (prev: TReturn, curr: TReturn) => boolean\n}\n\n/**\n * Creates a state source action that generates StateSource instances\n *\n * @remarks\n * The returned action can be bound to a store using createActionBinder.\n * When invoked, returns a StateSource that stays synchronized with the store.\n *\n * Key performance features:\n * - Memoizes selector contexts to prevent redundant object creation\n * - Only runs selectors when the underlying state changes\n *\n * For complex data transformations, consider using memoized selectors\n * (like those from Reselect) to prevent expensive recalculations.\n *\n * @example\n * ```ts\n * // Create a simple counter source\n * const getCount = createStateSourceAction(({state}: SelectorContext<CounterState>) => state.count)\n * ```\n *\n * @example\n * ```ts\n * // Create a parameterized source with setup/cleanup\n * const getItem = createStateSourceAction({\n *   selector: ({state}, index: number) => state.items[index],\n *   onSubscribe: (context, index) => {\n *     trackItemSubscription(index)\n *     return () => untrackItem(index)\n *   }\n * })\n * ```\n *\n * @example\n * ```ts\n * // Binding a state source to a specific store\n * const documentStore = defineStore<DocumentState>({\n *   name: 'Documents',\n *   getInitialState: () => ({ documents: {} }),\n *   // ...\n * })\n *\n * const getDocument = bindActionByDataset(\n *   documentStore,\n *   createStateSourceAction(({state}, documentId: string) => state.documents[documentId])\n * )\n *\n * // Usage\n * const documentSource = getDocument(sanityInstance, 'doc123')\n * const doc = documentSource.getCurrent()\n * const subscription = documentSource.observable.subscribe(updatedDoc => {\n *   console.log('Document changed:', updatedDoc)\n * })\n * ```\n */\nexport function createStateSourceAction<TState, TParams extends unknown[], TReturn>(\n  options: Selector<TState, TParams, TReturn> | StateSourceOptions<TState, TParams, TReturn>,\n): StoreAction<TState, TParams, StateSource<TReturn>> {\n  const selector = typeof options === 'function' ? options : options.selector\n  const subscribeHandler = options && 'onSubscribe' in options ? options.onSubscribe : undefined\n  const isEqual = options && 'isEqual' in options ? (options.isEqual ?? Object.is) : Object.is\n  const selectorContextCache = new WeakMap<\n    object,\n    WeakMap<SanityInstance, SelectorContext<TState>>\n  >()\n\n  /**\n   * The state source action implementation\n   * @param context - Store context providing access to state and instance\n   * @param params - Parameters provided when invoking the bound action\n   */\n  function stateSourceAction(context: StoreContext<TState>, ...params: TParams) {\n    const {state, instance} = context\n\n    const getCurrent = () => {\n      const currentState = state.get()\n      if (typeof currentState !== 'object' || currentState === null) {\n        throw new Error(\n          `Expected store state to be an object but got \"${typeof currentState}\" instead`,\n        )\n      }\n\n      let instanceCache = selectorContextCache.get(currentState)\n      if (!instanceCache) {\n        instanceCache = new WeakMap<SanityInstance, SelectorContext<TState>>()\n        selectorContextCache.set(currentState, instanceCache)\n      }\n      let selectorContext = instanceCache.get(instance)\n      if (!selectorContext) {\n        selectorContext = {state: currentState, instance}\n        instanceCache.set(instance, selectorContext)\n      }\n      return selector(selectorContext, ...params)\n    }\n\n    // Subscription manager handles both RxJS and direct subscriptions\n    const subscribe = (onStoreChanged?: () => void) => {\n      // Run setup handler if provided\n      const cleanup = subscribeHandler?.(context, ...params)\n\n      // Set up state change subscription\n      const subscription = state.observable\n        .pipe(\n          // Derive value from current state\n          map(getCurrent),\n          // Filter unchanged values using custom equality check\n          distinctUntilChanged(isEqual),\n          // Skip initial emission since we only want changes\n          skip(1),\n        )\n        .subscribe({\n          next: () => onStoreChanged?.(),\n          // Propagate selector errors to both subscription types\n          error: () => onStoreChanged?.(),\n        })\n\n      return () => {\n        subscription.unsubscribe()\n        cleanup?.()\n      }\n    }\n\n    // Create shared observable that handles multiple subscribers efficiently\n    const observable = new Observable<TReturn>((observer) => {\n      const emitCurrent = () => {\n        try {\n          observer.next(getCurrent())\n        } catch (error) {\n          observer.error(error)\n        }\n      }\n      // Emit immediately on subscription\n      emitCurrent()\n      return subscribe(emitCurrent)\n    }).pipe(share())\n\n    return {\n      getCurrent,\n      subscribe,\n      observable,\n    }\n  }\n\n  return stateSourceAction\n}\n","export const DEFAULT_BASE = 'http://localhost'\nexport const AUTH_CODE_PARAM = 'sid'\nexport const DEFAULT_API_VERSION = '2021-06-07'\nexport const REQUEST_TAG_PREFIX = 'sanity.sdk.auth'\n","import {\n  distinctUntilChanged,\n  filter,\n  interval,\n  map,\n  type Subscription,\n  switchMap,\n  takeWhile,\n} from 'rxjs'\n\nimport {type StoreContext} from '../store/defineStore'\nimport {DEFAULT_API_VERSION} from './authConstants'\nimport {AuthStateType} from './authStateType'\nimport {type AuthState, type AuthStoreState} from './authStore'\n\n/**\n * @internal\n */\nexport const refreshStampedToken = ({state}: StoreContext<AuthStoreState>): Subscription => {\n  const {clientFactory, apiHost, storageArea, storageKey} = state.get().options\n\n  const refreshInterval = 12 * 60 * 60 * 1000 // refresh the token every 12 hours\n\n  const refreshToken$ = state.observable.pipe(\n    map(({authState}) => authState),\n    filter(\n      (authState): authState is Extract<AuthState, {type: AuthStateType.LOGGED_IN}> =>\n        authState.type === AuthStateType.LOGGED_IN,\n    ),\n    distinctUntilChanged(),\n    filter((authState) => authState.token.includes('-st')), // Ensure we only try to refresh stamped tokens\n    switchMap((authState) =>\n      interval(refreshInterval).pipe(\n        takeWhile(() => state.get().authState.type === AuthStateType.LOGGED_IN),\n        map(() => authState.token),\n        distinctUntilChanged(),\n        map((token) =>\n          clientFactory({\n            apiVersion: DEFAULT_API_VERSION,\n            requestTagPrefix: 'sdk.token-refresh',\n            useProjectHostname: false,\n            token,\n            ignoreBrowserTokenWarning: true,\n            ...(apiHost && {apiHost}),\n          }),\n        ),\n        switchMap((client) =>\n          client.observable.request<{token: string}>({\n            uri: 'auth/refresh-token',\n            method: 'POST',\n            body: {\n              token: authState.token,\n            },\n          }),\n        ),\n      ),\n    ),\n  )\n\n  return refreshToken$.subscribe({\n    next: (response) => {\n      state.set('setRefreshStampedToken', (prev) => ({\n        authState:\n          prev.authState.type === AuthStateType.LOGGED_IN\n            ? {...prev.authState, token: response.token}\n            : prev.authState,\n      }))\n      storageArea?.setItem(storageKey, JSON.stringify({token: response.token}))\n    },\n    error: (error) => {\n      state.set('setRefreshStampedTokenError', {authState: {type: AuthStateType.ERROR, error}})\n    },\n  })\n}\n","import {type CurrentUser} from '@sanity/types'\nimport {distinctUntilChanged, filter, map, type Subscription, switchMap} from 'rxjs'\n\nimport {type StoreContext} from '../store/defineStore'\nimport {DEFAULT_API_VERSION, REQUEST_TAG_PREFIX} from './authConstants'\nimport {AuthStateType} from './authStateType'\nimport {type AuthState, type AuthStoreState} from './authStore'\n\nexport const subscribeToStateAndFetchCurrentUser = ({\n  state,\n}: StoreContext<AuthStoreState>): Subscription => {\n  const {clientFactory, apiHost} = state.get().options\n\n  const currentUser$ = state.observable\n    .pipe(\n      map(({authState}) => authState),\n      filter(\n        (authState): authState is Extract<AuthState, {type: AuthStateType.LOGGED_IN}> =>\n          authState.type === AuthStateType.LOGGED_IN && !authState.currentUser,\n      ),\n      map((authState) => authState.token),\n      distinctUntilChanged(),\n    )\n    .pipe(\n      map((token) =>\n        clientFactory({\n          apiVersion: DEFAULT_API_VERSION,\n          requestTagPrefix: REQUEST_TAG_PREFIX,\n          token,\n          ignoreBrowserTokenWarning: true,\n          useProjectHostname: false,\n          ...(apiHost && {apiHost}),\n        }),\n      ),\n      switchMap((client) =>\n        client.observable.request<CurrentUser>({uri: '/users/me', method: 'GET'}),\n      ),\n    )\n\n  return currentUser$.subscribe({\n    next: (currentUser) => {\n      state.set('setCurrentUser', (prev) => ({\n        authState:\n          prev.authState.type === AuthStateType.LOGGED_IN\n            ? {...prev.authState, currentUser}\n            : prev.authState,\n      }))\n    },\n    error: (error) => {\n      state.set('setError', {authState: {type: AuthStateType.ERROR, error}})\n    },\n  })\n}\n","import {EMPTY, fromEvent, Observable} from 'rxjs'\n\nimport {AUTH_CODE_PARAM, DEFAULT_BASE} from './authConstants'\n\nexport function getAuthCode(callbackUrl: string | undefined, locationHref: string): string | null {\n  const loc = new URL(locationHref, DEFAULT_BASE)\n  const callbackLocation = callbackUrl ? new URL(callbackUrl, DEFAULT_BASE) : undefined\n  const callbackLocationMatches = callbackLocation\n    ? loc.pathname.toLowerCase().startsWith(callbackLocation.pathname.toLowerCase())\n    : true\n\n  // for stamped tokens, the authCode is not in the hash, it is in the query params\n  const authCode =\n    new URLSearchParams(loc.hash.slice(1)).get(AUTH_CODE_PARAM) ||\n    new URLSearchParams(loc.search).get(AUTH_CODE_PARAM)\n\n  return authCode && callbackLocationMatches ? authCode : null\n}\n\n/**\n * Attempts to retrieve a token from the configured storage.\n * If invalid or not present, returns null.\n */\nexport function getTokenFromStorage(\n  storageArea: Storage | undefined,\n  storageKey: string,\n): string | null {\n  if (!storageArea) return null\n  const item = storageArea.getItem(storageKey)\n  if (item === null) return null\n\n  try {\n    const parsed: unknown = JSON.parse(item)\n    if (\n      typeof parsed !== 'object' ||\n      parsed === null ||\n      !('token' in parsed) ||\n      typeof parsed.token !== 'string'\n    ) {\n      throw new Error('Invalid stored auth data structure')\n    }\n    return parsed.token\n  } catch {\n    storageArea.removeItem(storageKey)\n    return null\n  }\n}\n\n/**\n * Creates an observable stream of storage events. If not in a browser environment,\n * returns an EMPTY observable.\n */\nexport function getStorageEvents(): Observable<StorageEvent> {\n  const isBrowser = typeof window !== 'undefined' && typeof window.addEventListener === 'function'\n\n  if (!isBrowser) {\n    return EMPTY\n  }\n\n  return fromEvent<StorageEvent>(window, 'storage')\n}\n\n/**\n * Returns a default storage instance (localStorage) if available.\n * If not available or an error occurs, returns undefined.\n */\nexport function getDefaultStorage(): Storage | undefined {\n  try {\n    if (typeof localStorage !== 'undefined' && typeof localStorage.getItem === 'function') {\n      return localStorage\n    }\n    return undefined\n  } catch {\n    return undefined\n  }\n}\n\n/**\n * Returns the default location to use.\n * Tries accessing `location.href`, falls back to a default base if not available or on error.\n */\nexport function getDefaultLocation(): string {\n  try {\n    if (typeof location === 'undefined') return DEFAULT_BASE\n    if (typeof location.href === 'string') return location.href\n    return DEFAULT_BASE\n  } catch {\n    return DEFAULT_BASE\n  }\n}\n","import {defer, distinctUntilChanged, filter, map, type Subscription} from 'rxjs'\n\nimport {type StoreContext} from '../store/defineStore'\nimport {AuthStateType} from './authStateType'\nimport {type AuthStoreState} from './authStore'\nimport {getStorageEvents, getTokenFromStorage} from './utils'\n\nexport const subscribeToStorageEventsAndSetToken = ({\n  state,\n}: StoreContext<AuthStoreState>): Subscription => {\n  const {storageArea, storageKey} = state.get().options\n\n  const tokenFromStorage$ = defer(getStorageEvents).pipe(\n    filter(\n      (e): e is StorageEvent & {newValue: string} =>\n        e.storageArea === storageArea && e.key === storageKey,\n    ),\n    map(() => getTokenFromStorage(storageArea, storageKey)),\n    distinctUntilChanged(),\n  )\n\n  return tokenFromStorage$.subscribe((token) => {\n    state.set('updateTokenFromStorageEvent', {\n      authState: token\n        ? {type: AuthStateType.LOGGED_IN, token, currentUser: null}\n        : {type: AuthStateType.LOGGED_OUT, isDestroyingSession: false},\n    })\n  })\n}\n","import {type ClientConfig, createClient, type SanityClient} from '@sanity/client'\nimport {type CurrentUser} from '@sanity/types'\nimport {type Subscription} from 'rxjs'\n\nimport {type AuthConfig, type AuthProvider} from '../config/authConfig'\nimport {bindActionGlobally} from '../store/createActionBinder'\nimport {createStateSourceAction} from '../store/createStateSourceAction'\nimport {defineStore} from '../store/defineStore'\nimport {AuthStateType} from './authStateType'\nimport {refreshStampedToken} from './refreshStampedToken'\nimport {subscribeToStateAndFetchCurrentUser} from './subscribeToStateAndFetchCurrentUser'\nimport {subscribeToStorageEventsAndSetToken} from './subscribeToStorageEventsAndSetToken'\nimport {getAuthCode, getDefaultLocation, getDefaultStorage, getTokenFromStorage} from './utils'\n\n/**\n * Represents the various states the authentication can be in.\n *\n * @public\n */\nexport type AuthState = LoggedInAuthState | LoggedOutAuthState | LoggingInAuthState | ErrorAuthState\n\n/**\n * Logged-in state from the auth state.\n * @public\n */\nexport type LoggedInAuthState = {\n  type: AuthStateType.LOGGED_IN\n  token: string\n  currentUser: CurrentUser | null\n}\n\n/**\n * Logged-out state from the auth state.\n * @public\n */\nexport type LoggedOutAuthState = {type: AuthStateType.LOGGED_OUT; isDestroyingSession: boolean}\n\n/**\n * Logging-in state from the auth state.\n * @public\n */\nexport type LoggingInAuthState = {type: AuthStateType.LOGGING_IN; isExchangingToken: boolean}\n\n/**\n * Error state from the auth state.\n * @public\n */\nexport type ErrorAuthState = {type: AuthStateType.ERROR; error: unknown}\n\n/**\n * Represents the various states the authentication can be in.\n *\n * @public\n */\nexport interface DashboardContext {\n  mode?: string\n  env?: string\n  orgId?: string\n}\n\nlet tokenRefresherRunning = false\n\n/**\n * @public\n */\nexport interface AuthStoreState {\n  authState: AuthState\n  providers?: AuthProvider[]\n  options: {\n    initialLocationHref: string\n    clientFactory: (config: ClientConfig) => SanityClient\n    customProviders: AuthConfig['providers']\n    storageKey: string\n    storageArea: Storage | undefined\n    apiHost: string | undefined\n    loginUrl: string\n    callbackUrl: string | undefined\n    providedToken: string | undefined\n  }\n  dashboardContext?: DashboardContext\n}\n\nexport const authStore = defineStore<AuthStoreState>({\n  name: 'Auth',\n  getInitialState(instance) {\n    const {\n      apiHost,\n      callbackUrl,\n      providers: customProviders,\n      token: providedToken,\n      clientFactory = createClient,\n      initialLocationHref = getDefaultLocation(),\n      storageArea = getDefaultStorage(),\n    } = instance.config.auth ?? {}\n\n    const storageKey = `__sanity_auth_token`\n\n    // This login URL will only be used for local development\n    let loginDomain = 'https://www.sanity.io'\n    try {\n      if (apiHost && new URL(apiHost).hostname.endsWith('.sanity.work')) {\n        loginDomain = 'https://www.sanity.work'\n      }\n    } catch {\n      /* empty */\n    }\n    const loginUrl = new URL('/login', loginDomain)\n    loginUrl.searchParams.set('origin', initialLocationHref)\n    loginUrl.searchParams.set('type', 'stampedToken') // Token must be stamped to have an sid passed back\n    loginUrl.searchParams.set('withSid', 'true')\n\n    let authState: AuthState\n\n    const token = getTokenFromStorage(storageArea, storageKey)\n\n    if (providedToken) {\n      authState = {type: AuthStateType.LOGGED_IN, token: providedToken, currentUser: null}\n    } else if (getAuthCode(callbackUrl, initialLocationHref)) {\n      authState = {type: AuthStateType.LOGGING_IN, isExchangingToken: false}\n    } else if (token) {\n      authState = {type: AuthStateType.LOGGED_IN, token, currentUser: null}\n    } else {\n      authState = {type: AuthStateType.LOGGED_OUT, isDestroyingSession: false}\n    }\n\n    return {\n      authState,\n      options: {\n        apiHost,\n        loginUrl: loginUrl.toString(),\n        callbackUrl,\n        customProviders,\n        providedToken,\n        clientFactory,\n        initialLocationHref,\n        storageKey,\n        storageArea,\n      },\n    }\n  },\n  initialize(context) {\n    const subscriptions: Subscription[] = []\n    subscriptions.push(subscribeToStateAndFetchCurrentUser(context))\n\n    if (context.state.get().options?.storageArea) {\n      subscriptions.push(subscribeToStorageEventsAndSetToken(context))\n    }\n\n    if (!tokenRefresherRunning) {\n      tokenRefresherRunning = true\n      subscriptions.push(refreshStampedToken(context))\n    }\n\n    return () => {\n      for (const subscription of subscriptions) {\n        subscription.unsubscribe()\n      }\n    }\n  },\n})\n\n/**\n * @public\n */\nexport const getCurrentUserState = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {authState}}) =>\n    authState.type === AuthStateType.LOGGED_IN ? authState.currentUser : null,\n  ),\n)\n\n/**\n * @public\n */\nexport const getTokenState = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {authState}}) =>\n    authState.type === AuthStateType.LOGGED_IN ? authState.token : null,\n  ),\n)\n\n/**\n * @public\n */\nexport const getLoginUrlState = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {options}}) => options.loginUrl),\n)\n\n/**\n * @public\n */\nexport const getAuthState = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {authState}}) => authState),\n)\n\n/**\n * @public\n */\nexport const getDashboardOrganizationId = bindActionGlobally(\n  authStore,\n  createStateSourceAction(({state: {dashboardContext}}) => dashboardContext?.orgId),\n)\n","import {bindActionGlobally} from '../store/createActionBinder'\nimport {DEFAULT_API_VERSION, REQUEST_TAG_PREFIX} from './authConstants'\nimport {AuthStateType} from './authStateType'\nimport {authStore, type AuthStoreState, type DashboardContext} from './authStore'\nimport {getAuthCode, getDefaultLocation} from './utils'\n\n/**\n * @public\n */\nexport const handleAuthCallback = bindActionGlobally(\n  authStore,\n  async ({state}, locationHref: string = getDefaultLocation()) => {\n    const {providedToken, callbackUrl, clientFactory, apiHost, storageArea, storageKey} =\n      state.get().options\n\n    // If a token is provided, no need to handle callback\n    if (providedToken) return false\n\n    // Don't handle the callback if already in flight.\n    const {authState} = state.get()\n    if (authState.type === AuthStateType.LOGGING_IN && authState.isExchangingToken) return false\n\n    // If there is no matching `authCode` then we can't handle the callback\n    const authCode = getAuthCode(callbackUrl, locationHref)\n    if (!authCode) return false\n\n    // Get the SanityOS dashboard context from the url\n    const parsedUrl = new URL(locationHref)\n    let dashboardContext: DashboardContext = {}\n    try {\n      const contextParam = parsedUrl.searchParams.get('_context') ?? '{}'\n      dashboardContext = JSON.parse(contextParam)\n    } catch (err) {\n      // If JSON parsing fails, use empty context\n      // eslint-disable-next-line no-console\n      console.error('Failed to parse dashboard context:', err)\n    }\n    const {mode, env, orgId} = dashboardContext\n\n    // Otherwise, start the exchange\n    state.set('exchangeSessionForToken', {\n      authState: {type: AuthStateType.LOGGING_IN, isExchangingToken: true},\n      dashboardContext: {mode, env, orgId},\n    } as Partial<AuthStoreState>)\n\n    try {\n      const client = clientFactory({\n        apiVersion: DEFAULT_API_VERSION,\n        requestTagPrefix: REQUEST_TAG_PREFIX,\n        useProjectHostname: false,\n        ...(apiHost && {apiHost}),\n      })\n\n      const {token} = await client.request<{token: string; label: string}>({\n        method: 'GET',\n        uri: '/auth/fetch',\n        query: {sid: authCode},\n        tag: 'fetch-token',\n      })\n\n      storageArea?.setItem(storageKey, JSON.stringify({token}))\n      state.set('setToken', {authState: {type: AuthStateType.LOGGED_IN, token, currentUser: null}})\n\n      const loc = new URL(locationHref)\n      loc.hash = ''\n      loc.searchParams.delete('sid')\n      loc.searchParams.delete('url')\n      return loc.toString()\n    } catch (error) {\n      state.set('exchangeSessionForTokenError', {authState: {type: AuthStateType.ERROR, error}})\n      return false\n    }\n  },\n)\n","import {bindActionGlobally} from '../store/createActionBinder'\nimport {DEFAULT_API_VERSION, REQUEST_TAG_PREFIX} from './authConstants'\nimport {AuthStateType} from './authStateType'\nimport {authStore} from './authStore'\n\n/**\n * @public\n */\nexport const logout = bindActionGlobally(authStore, async ({state}) => {\n  const {clientFactory, apiHost, providedToken, storageArea, storageKey} = state.get().options\n\n  // If a token is statically provided, logout does nothing\n  if (providedToken) return\n\n  const {authState} = state.get()\n\n  // If we already have an inflight request, no-op\n  if (authState.type === AuthStateType.LOGGED_OUT && authState.isDestroyingSession) return\n  const token = authState.type === AuthStateType.LOGGED_IN && authState.token\n\n  try {\n    if (token) {\n      state.set('loggingOut', {\n        authState: {type: AuthStateType.LOGGED_OUT, isDestroyingSession: true},\n      })\n\n      const client = clientFactory({\n        token,\n        requestTagPrefix: REQUEST_TAG_PREFIX,\n        apiVersion: DEFAULT_API_VERSION,\n        ...(apiHost && {apiHost}),\n        useProjectHostname: false,\n      })\n\n      await client.request<void>({uri: '/auth/logout', method: 'POST'})\n    }\n  } finally {\n    state.set('logoutSuccess', {\n      authState: {type: AuthStateType.LOGGED_OUT, isDestroyingSession: false},\n    })\n    storageArea?.removeItem(storageKey)\n  }\n})\n","import {type ClientConfig, createClient, type SanityClient} from '@sanity/client'\nimport {pick} from 'lodash-es'\n\nimport {getTokenState} from '../auth/authStore'\nimport {type DatasetHandle} from '../config/sanityConfig'\nimport {bindActionGlobally} from '../store/createActionBinder'\nimport {createStateSourceAction} from '../store/createStateSourceAction'\nimport {defineStore, type StoreContext} from '../store/defineStore'\n\nconst DEFAULT_API_VERSION = '2024-11-12'\nconst DEFAULT_REQUEST_TAG_PREFIX = 'sanity.sdk'\n\ntype AllowedClientConfigKey =\n  | 'useCdn'\n  | 'token'\n  | 'perspective'\n  | 'apiHost'\n  | 'proxy'\n  | 'withCredentials'\n  | 'timeout'\n  | 'maxRetries'\n  | 'dataset'\n  | 'projectId'\n  | 'requestTagPrefix'\n  | 'useProjectHostname'\n\nconst allowedKeys = Object.keys({\n  apiHost: null,\n  useCdn: null,\n  token: null,\n  perspective: null,\n  proxy: null,\n  withCredentials: null,\n  timeout: null,\n  maxRetries: null,\n  dataset: null,\n  projectId: null,\n  scope: null,\n  apiVersion: null,\n  requestTagPrefix: null,\n  useProjectHostname: null,\n} satisfies Record<keyof ClientOptions, null>) as (keyof ClientOptions)[]\n\nconst DEFAULT_CLIENT_CONFIG: ClientConfig = {\n  apiVersion: DEFAULT_API_VERSION,\n  useCdn: false,\n  ignoreBrowserTokenWarning: true,\n  allowReconfigure: false,\n  requestTagPrefix: DEFAULT_REQUEST_TAG_PREFIX,\n}\n\n/**\n * States tracked by the client store\n * @public\n */\nexport interface ClientStoreState {\n  token: string | null\n  clients: {[TKey in string]?: SanityClient}\n}\n\n/**\n * Options used when retrieving a client instance from the client store.\n *\n * This interface extends the base {@link ClientConfig} and adds:\n *\n * - **apiVersion:** A required string indicating the API version for the client.\n * - **scope:** An optional flag to choose between the project-specific client\n *   ('project') and the global client ('global'). When set to `'global'`, the\n *   global client is used.\n *\n * These options are utilized by `getClient` and `getClientState` to configure and\n * return appropriate client instances that automatically handle authentication\n * updates and configuration changes.\n *\n * @public\n */\nexport interface ClientOptions extends Pick<ClientConfig, AllowedClientConfigKey>, DatasetHandle {\n  /**\n   * An optional flag to choose between the default client (typically project-level)\n   * and the global client ('global'). When set to `'global'`, the global client\n   * is used.\n   */\n  scope?: 'default' | 'global'\n  /**\n   * A required string indicating the API version for the client.\n   */\n  apiVersion: string\n}\n\nconst clientStore = defineStore<ClientStoreState>({\n  name: 'clientStore',\n\n  getInitialState: (instance) => ({\n    clients: {},\n    token: getTokenState(instance).getCurrent(),\n  }),\n\n  initialize(context) {\n    const subscription = listenToToken(context)\n    return () => subscription.unsubscribe()\n  },\n})\n\n/**\n * Updates the client store state when a token is received.\n * @internal\n */\nconst listenToToken = ({instance, state}: StoreContext<ClientStoreState>) => {\n  return getTokenState(instance).observable.subscribe((token) => {\n    state.set('setTokenAndResetClients', {token, clients: {}})\n  })\n}\n\nconst getClientConfigKey = (options: ClientOptions) => JSON.stringify(pick(options, ...allowedKeys))\n\n/**\n * Retrieves a Sanity client instance configured with the provided options.\n *\n * This function returns a client instance configured for the project or as a\n * global client based on the options provided. It ensures efficient reuse of\n * client instances by returning the same instance for the same options.\n * For automatic handling of authentication token updates, consider using\n * `getClientState`.\n *\n * @public\n */\nexport const getClient = bindActionGlobally(\n  clientStore,\n  ({state, instance}, options: ClientOptions) => {\n    // Check for disallowed keys\n    const providedKeys = Object.keys(options) as (keyof ClientOptions)[]\n    const disallowedKeys = providedKeys.filter((key) => !allowedKeys.includes(key))\n\n    if (disallowedKeys.length > 0) {\n      const listFormatter = new Intl.ListFormat('en', {style: 'long', type: 'conjunction'})\n      throw new Error(\n        `The client options provided contains unsupported properties: ${listFormatter.format(disallowedKeys)}. ` +\n          `Allowed keys are: ${listFormatter.format(allowedKeys)}.`,\n      )\n    }\n\n    const {token, clients} = state.get()\n    const projectId = options.projectId ?? instance.config.projectId\n    const dataset = options.dataset ?? instance.config.dataset\n    const apiHost = options.apiHost ?? instance.config.auth?.apiHost\n\n    const effectiveOptions: ClientOptions = {\n      ...DEFAULT_CLIENT_CONFIG,\n      ...((options.scope === 'global' || !projectId) && {useProjectHostname: false}),\n      ...(token && {token}),\n      ...options,\n      ...(projectId && {projectId}),\n      ...(dataset && {dataset}),\n      ...(apiHost && {apiHost}),\n    }\n\n    const key = getClientConfigKey(effectiveOptions)\n\n    if (clients[key]) return clients[key]\n\n    const client = createClient(effectiveOptions)\n    state.set('addClient', (prev) => ({clients: {...prev.clients, [key]: client}}))\n\n    return client\n  },\n)\n\n/**\n * Returns a state source for the Sanity client instance.\n *\n * This function provides a subscribable state source that emits updated client\n * instances whenever relevant configurations change (such as authentication tokens).\n * Use this when you need to react to client configuration changes in your application.\n *\n * @public\n */\nexport const getClientState = bindActionGlobally(\n  clientStore,\n  createStateSourceAction(({instance}, options: ClientOptions) => getClient(instance, options)),\n)\n","import {type StoreContext} from '../../../store/defineStore'\nimport {type ComlinkControllerState} from '../comlinkControllerStore'\n\n/**\n * Calls the destroy method on the controller and resets the controller state.\n * @public\n */\nexport const destroyController = ({state}: StoreContext<ComlinkControllerState>): void => {\n  const {controller} = state.get()\n\n  if (controller) {\n    controller.destroy()\n    state.set('destroyController', {\n      controller: null,\n      channels: new Map(),\n    })\n  }\n}\n","import {type ChannelInput, type ChannelInstance} from '@sanity/comlink'\nimport {isEqual} from 'lodash-es'\n\nimport {type StoreContext} from '../../../store/defineStore'\nimport {type FrameMessage, type WindowMessage} from '../../types'\nimport {type ComlinkControllerState} from '../comlinkControllerStore'\n\n/**\n * Retrieve or create a channel to be used for communication between\n * an application and the controller.\n * @public\n */\nexport const getOrCreateChannel = (\n  {state}: StoreContext<ComlinkControllerState>,\n  options: ChannelInput,\n): ChannelInstance<FrameMessage, WindowMessage> => {\n  const controller = state.get().controller\n\n  if (!controller) {\n    throw new Error('Controller must be initialized before using or creating channels')\n  }\n\n  const channels = state.get().channels\n  const existing = channels.get(options.name)\n\n  // limit channels to one per name\n  if (existing) {\n    if (!isEqual(existing.options, options)) {\n      throw new Error(`Channel \"${options.name}\" already exists with different options`)\n    }\n\n    state.set('incrementChannelRefCount', {\n      channels: new Map(channels).set(options.name, {\n        ...existing,\n        refCount: existing.refCount + 1,\n      }),\n    })\n    existing.channel.start()\n    return existing.channel\n  }\n\n  const channel = controller.createChannel(options)\n  channel.start()\n  state.set('createChannel', {\n    channels: new Map(channels).set(options.name, {\n      channel,\n      options,\n      refCount: 1,\n    }),\n  })\n\n  return channel\n}\n","import {type Controller, createController} from '@sanity/comlink'\n\nimport {type StoreContext} from '../../../store/defineStore'\nimport {type ComlinkControllerState} from '../comlinkControllerStore'\nimport {destroyController} from './destroyController'\n\n/**\n * Initializes or fetches a controller to handle communication\n * between an application and iframes.\n * @public\n */\nexport const getOrCreateController = (\n  {state, instance}: StoreContext<ComlinkControllerState>,\n  targetOrigin: string,\n): Controller => {\n  const {controller, controllerOrigin} = state.get()\n  if (controller && controllerOrigin === targetOrigin) {\n    return controller\n  }\n\n  // if the target origin has changed, we'll create a new controller,\n  // but need to clean up first\n  if (controller) {\n    destroyController({state, instance})\n  }\n\n  const newController = createController({targetOrigin})\n  state.set('initializeController', {\n    controllerOrigin: targetOrigin,\n    controller: newController,\n  })\n\n  return newController\n}\n","import {type StoreContext} from '../../../store/defineStore'\nimport {type ComlinkControllerState} from '../comlinkControllerStore'\n\n/**\n * Signals to the store that the consumer has stopped using the channel\n * @public\n */\nexport const releaseChannel = (\n  {state}: StoreContext<ComlinkControllerState>,\n  name: string,\n): void => {\n  const channels = state.get().channels\n  const channelEntry = channels.get(name)\n\n  if (channelEntry) {\n    const newRefCount = channelEntry.refCount === 0 ? 0 : channelEntry.refCount - 1\n\n    if (newRefCount === 0) {\n      channelEntry.channel.stop()\n      channels.delete(name)\n      state.set('releaseChannel', {channels: new Map(channels)})\n    } else {\n      state.set('releaseChannel', {\n        channels: new Map(channels).set(name, {\n          ...channelEntry,\n          refCount: newRefCount,\n        }),\n      })\n    }\n  }\n}\n","import {type ChannelInput, type ChannelInstance, type Controller} from '@sanity/comlink'\n\nimport {bindActionGlobally} from '../../store/createActionBinder'\nimport {defineStore} from '../../store/defineStore'\nimport {type FrameMessage, type WindowMessage} from '../types'\nimport {destroyController as unboundDestroyController} from './actions/destroyController'\nimport {getOrCreateChannel as unboundGetOrCreateChannel} from './actions/getOrCreateChannel'\nimport {getOrCreateController as unboundGetOrCreateController} from './actions/getOrCreateController'\nimport {releaseChannel as unboundReleaseChannel} from './actions/releaseChannel'\n\n/**\n * Individual channel with its relevant options\n * @public\n */\nexport interface ChannelEntry {\n  channel: ChannelInstance<FrameMessage, WindowMessage>\n  // we store options to ensure that channels remain as unique / consistent as possible\n  options: ChannelInput\n  // we store refCount to ensure channels remain open only as long as they are in use\n  refCount: number\n}\n\n/**\n * Internal state tracking comlink connections\n * @public\n */\nexport interface ComlinkControllerState {\n  controller: Controller | null\n  controllerOrigin: string | null\n  channels: Map<string, ChannelEntry>\n}\n\nexport const comlinkControllerStore = defineStore<ComlinkControllerState>({\n  name: 'connectionStore',\n  getInitialState: () => {\n    const initialState = {\n      controller: null,\n      controllerOrigin: null,\n      channels: new Map(),\n    }\n    return initialState\n  },\n  initialize({instance}) {\n    return () => {\n      // destroying controller also destroys channels\n      destroyController(instance)\n    }\n  },\n})\n\n/**\n * Calls the destroy method on the controller and resets the controller state.\n * @public\n */\nexport const destroyController = bindActionGlobally(\n  comlinkControllerStore,\n  unboundDestroyController,\n)\n\n/**\n * Retrieve or create a channel to be used for communication between\n * an application and the controller.\n * @public\n */\nexport const getOrCreateChannel = bindActionGlobally(\n  comlinkControllerStore,\n  unboundGetOrCreateChannel,\n)\n\n/**\n * Initializes or fetches a controller to handle communication\n * between an application and iframes.\n * @public\n */\nexport const getOrCreateController = bindActionGlobally(\n  comlinkControllerStore,\n  unboundGetOrCreateController,\n)\n\n/**\n * Signals to the store that the consumer has stopped using the channel\n * @public\n */\nexport const releaseChannel = bindActionGlobally(comlinkControllerStore, unboundReleaseChannel)\n","import {createNode, type Node, type NodeInput} from '@sanity/comlink'\nimport {isEqual} from 'lodash-es'\n\nimport {type StoreContext} from '../../../store/defineStore'\nimport {type FrameMessage, type WindowMessage} from '../../types'\nimport {type ComlinkNodeState} from '../comlinkNodeStore'\n\n/**\n * Retrieve or create a node to be used for communication between\n * an application and the controller -- specifically, a node should\n * be created within a frame / window to communicate with the controller.\n * @public\n */\nexport const getOrCreateNode = (\n  {state}: StoreContext<ComlinkNodeState>,\n  options: NodeInput,\n): Node<WindowMessage, FrameMessage> => {\n  const nodes = state.get().nodes\n  const existing = nodes.get(options.name)\n\n  // limit nodes to one per name\n  if (existing) {\n    if (!isEqual(existing.options, options)) {\n      throw new Error(`Node \"${options.name}\" already exists with different options`)\n    }\n\n    state.set('incrementNodeRefCount', {\n      nodes: new Map(nodes).set(options.name, {\n        ...existing,\n        refCount: existing.refCount + 1,\n      }),\n    })\n\n    existing.node.start()\n    return existing.node\n  }\n\n  const node: Node<WindowMessage, FrameMessage> = createNode(options)\n  node.start()\n\n  nodes.set(options.name, {node, options, refCount: 1})\n\n  state.set('createNode', {nodes})\n\n  return node\n}\n","import {type StoreContext} from '../../../store/defineStore'\nimport {type ComlinkNodeState} from '../comlinkNodeStore'\n\n/**\n * Signals to the store that the consumer has stopped using the node\n * @public\n */\nexport const releaseNode = ({state}: StoreContext<ComlinkNodeState>, name: string): void => {\n  const nodes = state.get().nodes\n  const nodeEntry = nodes.get(name)\n\n  if (nodeEntry) {\n    const newRefCount = nodeEntry.refCount === 0 ? 0 : nodeEntry.refCount - 1\n\n    if (newRefCount === 0) {\n      nodeEntry.node.stop()\n      nodes.delete(name)\n      state.set('releaseNode', {nodes: new Map(nodes)})\n    } else {\n      state.set('releaseNode', {\n        nodes: new Map(nodes).set(name, {\n          ...nodeEntry,\n          refCount: newRefCount,\n        }),\n      })\n    }\n  }\n}\n","import {type Node, type NodeInput} from '@sanity/comlink'\n\nimport {bindActionGlobally} from '../../store/createActionBinder'\nimport {defineStore} from '../../store/defineStore'\nimport {type FrameMessage, type WindowMessage} from '../types'\nimport {getOrCreateNode as unboundGetOrCreateNode} from './actions/getOrCreateNode'\nimport {releaseNode as unboundReleaseNode} from './actions/releaseNode'\n\n/**\n * Individual node with its relevant options\n * @public\n */\nexport interface NodeEntry {\n  node: Node<WindowMessage, FrameMessage>\n  // we store options to ensure that channels remain as unique / consistent as possible\n  options: NodeInput\n  // we store refCount to ensure nodes are running only as long as they are in use\n  refCount: number\n}\n\n/**\n * Internal state tracking comlink connections\n * @public\n */\nexport interface ComlinkNodeState {\n  nodes: Map<string, NodeEntry>\n}\n\nexport const comlinkNodeStore = defineStore<ComlinkNodeState>({\n  name: 'nodeStore',\n  getInitialState: () => ({\n    nodes: new Map(),\n  }),\n\n  initialize({state}) {\n    return () => {\n      state.get().nodes.forEach(({node}) => {\n        node.stop()\n      })\n    }\n  },\n})\n\n/**\n * Signals to the store that the consumer has stopped using the node\n * @public\n */\nexport const releaseNode = bindActionGlobally(comlinkNodeStore, unboundReleaseNode)\n\n/**\n * Retrieve or create a node to be used for communication between\n * an application and the controller -- specifically, a node should\n * be created within a frame / window to communicate with the controller.\n * @public\n */\nexport const getOrCreateNode = bindActionGlobally(comlinkNodeStore, unboundGetOrCreateNode)\n","import {omit} from 'lodash-es'\nimport {asapScheduler, EMPTY, firstValueFrom, from, Observable} from 'rxjs'\nimport {\n  catchError,\n  delay,\n  filter,\n  first,\n  groupBy,\n  map,\n  mergeMap,\n  pairwise,\n  startWith,\n  switchMap,\n  tap,\n} from 'rxjs/operators'\n\nimport {bindActionGlobally, type BoundStoreAction} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {\n  createStateSourceAction,\n  type SelectorContext,\n  type StateSource,\n} from '../store/createStateSourceAction'\nimport {defineStore, type StoreContext} from '../store/defineStore'\nimport {insecureRandomId} from '../utils/ids'\n\ninterface CreateFetcherStoreOptions<TParams extends unknown[], TData> {\n  /**\n   * A unique name for this store (for devtools)\n   */\n  name: string\n  /**\n   * A function that creates the observable that will be used to fetch the data.\n   */\n  fetcher: (instance: SanityInstance) => (...params: TParams) => Observable<TData>\n  /**\n   * The function used to convert the params into keys that state related to\n   * those params will be stored.\n   */\n  getKey: (instance: SanityInstance, ...params: TParams) => string\n  /**\n   * Delay in ms before clearing state after the last subscription is removed.\n   * This results in react components suspending again due to no previous state\n   * to show.\n   */\n  stateExpirationDelay?: number\n  /**\n   * The minimum time (ms) that must elapse since the last fetch for the same key\n   */\n  fetchThrottleInternal?: number\n}\n\ninterface StoreEntry<TParams extends unknown[], TData> {\n  params: TParams\n  instance: SanityInstance\n  key: string\n  data?: TData\n  error?: unknown\n  subscriptions: string[]\n  lastFetchInitiatedAt?: string\n}\n\n/**\n * Internal helper type\n * @public\n */\nexport interface FetcherStoreState<TParams extends unknown[], TData> {\n  stateByParams: {[TSerializedKey in string]?: StoreEntry<TParams, TData>}\n  error?: unknown\n}\n\n/**\n * Internal helper type\n * @public\n */\nexport interface FetcherStore<TParams extends unknown[], TData> {\n  getState: BoundStoreAction<\n    FetcherStoreState<TParams, TData>,\n    TParams,\n    StateSource<TData | undefined>\n  >\n  resolveState: BoundStoreAction<FetcherStoreState<TParams, TData>, TParams, Promise<TData>>\n}\n\n/**\n * Creates a store from a function that returns an observable that fetches data\n * that supports parameterized state caching.\n *\n * This function creates a resource store keyed by parameter values (using the\n * provided `getKey` function) and returns a state source (via `getState`)\n * that components can subscribe to. When a new subscription is added, and if\n * enough time has passed since the last fetch (controlled by\n * `fetchThrottleInternal`), it invokes the observable factory (via\n * `getObservable`) to fetch fresh data. The data is stored in state and can be\n * accessed reactively.\n *\n * Additionally, the store provides a `resolveState` function that returns a\n * Promise resolving with the next non-undefined value from the state source.\n *\n * State expiration is implemented: after the last subscription for a key is\n * removed, its state is cleared after `stateExpirationDelay` ms, causing\n * components to suspend until fresh data is fetched.\n */\nexport function createFetcherStore<TParams extends unknown[], TData>({\n  name,\n  fetcher: getObservable,\n  getKey,\n  fetchThrottleInternal = 1000,\n  stateExpirationDelay = 5000,\n}: CreateFetcherStoreOptions<TParams, TData>): FetcherStore<TParams, TData> {\n  const store = defineStore<FetcherStoreState<TParams, TData>>({\n    name,\n    getInitialState: () => ({\n      stateByParams: {},\n    }),\n    initialize: (context) => {\n      const subscription = subscribeToSubscriptionsAndFetch(context)\n      return () => subscription.unsubscribe()\n    },\n  })\n\n  /**\n   * For each key in state.stateByParams we set up a grouped stream.\n   * When a subscription is added (i.e. the subscriptions array length increases)\n   * and if enough time has elapsed since the last fetch, we update the timestamp\n   * and call the factory function for that key.\n   */\n  const subscribeToSubscriptionsAndFetch = ({\n    state,\n  }: StoreContext<FetcherStoreState<TParams, TData>>) => {\n    return state.observable\n      .pipe(\n        // Map the state to an array of [serialized, entry] pairs.\n        switchMap((s: FetcherStoreState<TParams, TData>) => {\n          const entries = Object.entries(s.stateByParams)\n          return entries.length > 0 ? from(entries) : EMPTY\n        }),\n        // Group by the serialized key.\n        groupBy(([key]) => key),\n        mergeMap((group$) =>\n          group$.pipe(\n            // Emit an initial value for pairwise comparisons.\n            startWith<[string, StoreEntry<TParams, TData> | undefined]>([group$.key, undefined]),\n            pairwise(),\n            // Trigger only when the subscriptions array grows.\n            filter(([[, prevEntry], [, currEntry]]) => {\n              const prevSubs = prevEntry?.subscriptions ?? []\n              const currSubs = currEntry?.subscriptions ?? []\n              return currSubs.length > prevSubs.length\n            }),\n            map(([, [, currEntry]]) => currEntry),\n\n            // Only trigger if we haven't fetched recently.\n            filter((entry) => {\n              const lastFetch = entry?.lastFetchInitiatedAt\n              if (!lastFetch) return true\n              return Date.now() - new Date(lastFetch).getTime() >= fetchThrottleInternal\n            }),\n            switchMap((entry) => {\n              // Retrieve params from the entry\n              if (!entry) return EMPTY\n\n              // Record that a fetch is being initiated.\n              state.set('setLastFetchInitiatedAt', (prev: FetcherStoreState<TParams, TData>) => ({\n                stateByParams: {\n                  ...prev.stateByParams,\n                  [entry.key]: {\n                    ...entry,\n                    ...prev.stateByParams[entry.key],\n                    lastFetchInitiatedAt: new Date().toISOString(),\n                  },\n                },\n              }))\n\n              const factoryFn = getObservable(entry.instance)\n              return factoryFn(...entry.params).pipe(\n                // the `createStateSourceAction` util requires the update\n                // to\n                delay(0, asapScheduler),\n                tap((data: TData) =>\n                  state.set('setData', (prev: FetcherStoreState<TParams, TData>) => ({\n                    stateByParams: {\n                      ...prev.stateByParams,\n                      [entry.key]: {\n                        ...omit(entry, 'error'),\n                        ...omit(prev.stateByParams[entry.key], 'error'),\n                        data,\n                      },\n                    },\n                  })),\n                ),\n                catchError((error) => {\n                  state.set('setError', (prev) => ({\n                    stateByParams: {\n                      ...prev.stateByParams,\n                      [entry.key]: {\n                        ...entry,\n                        ...prev.stateByParams[entry.key],\n                        error,\n                      },\n                    },\n                  }))\n\n                  return EMPTY\n                }),\n              )\n            }),\n          ),\n        ),\n      )\n      .subscribe({\n        error: (error) => state.set('setError', {error}),\n      })\n  }\n\n  const getState = bindActionGlobally(\n    store,\n    createStateSourceAction({\n      selector: (\n        {\n          instance,\n          state: {stateByParams, error},\n        }: SelectorContext<FetcherStoreState<TParams, TData>>,\n        ...params: TParams\n      ) => {\n        if (error) throw error\n        const key = getKey(instance, ...params)\n        const entry = stateByParams[key]\n        if (entry?.error) throw entry.error\n        return entry?.data\n      },\n      onSubscribe: ({instance, state}, ...params: TParams) => {\n        const subscriptionId = insecureRandomId()\n        const key = getKey(instance, ...params)\n\n        state.set('addSubscription', (prev: FetcherStoreState<TParams, TData>) => ({\n          stateByParams: {\n            ...prev.stateByParams,\n            [key]: {\n              ...prev.stateByParams[key],\n              instance,\n              key,\n              params: prev.stateByParams[key]?.params || params,\n              subscriptions: [...(prev.stateByParams[key]?.subscriptions || []), subscriptionId],\n            },\n          },\n        }))\n\n        return () => {\n          setTimeout(() => {\n            state.set('removeSubscription', (prev: FetcherStoreState<TParams, TData>) => {\n              const entry = prev.stateByParams[key]\n              if (!entry) return prev\n\n              const newSubs = (entry.subscriptions || []).filter((id) => id !== subscriptionId)\n              if (newSubs.length === 0) {\n                return {stateByParams: omit(prev.stateByParams, key)}\n              }\n\n              return {\n                stateByParams: {\n                  ...prev.stateByParams,\n                  [key]: {\n                    ...entry,\n                    subscriptions: newSubs,\n                  },\n                },\n              }\n            })\n          }, stateExpirationDelay)\n        }\n      },\n    }),\n  )\n\n  const resolveState = bindActionGlobally(store, ({instance}, ...params: TParams) =>\n    firstValueFrom(getState(instance, ...params).observable.pipe(first((i) => i !== undefined))),\n  )\n\n  return {getState, resolveState}\n}\n","import {switchMap} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {type ProjectHandle} from '../config/sanityConfig'\nimport {createFetcherStore} from '../utils/createFetcherStore'\n\nconst API_VERSION = 'v2025-02-19'\n\n/** @public */\nexport const datasets = createFetcherStore({\n  name: 'Datasets',\n  getKey: (instance, options?: ProjectHandle) => {\n    const projectId = options?.projectId ?? instance.config.projectId\n    if (!projectId) {\n      throw new Error('A projectId is required to use the project API.')\n    }\n    return projectId\n  },\n  fetcher: (instance) => (options?: ProjectHandle) => {\n    return getClientState(instance, {\n      apiVersion: API_VERSION,\n      // non-null assertion is fine because we check above\n      projectId: (options?.projectId ?? instance.config.projectId)!,\n      useProjectHostname: true,\n    }).observable.pipe(switchMap((client) => client.observable.datasets.list()))\n  },\n})\n\n/** @public */\nexport const getDatasetsState = datasets.getState\n\n/** @public */\nexport const resolveDatasets = datasets.resolveState\n","import {SanityEncoder} from '@sanity/mutate'\nimport {type PatchMutation as SanityMutatePatchMutation} from '@sanity/mutate/_unstable_store'\nimport {type PatchMutation, type PatchOperations, type SanityDocumentLike} from '@sanity/types'\n\nimport {type DocumentHandle, type DocumentTypeHandle} from '../config/sanityConfig'\nimport {getPublishedId} from '../utils/ids'\n\nconst isSanityMutatePatch = (value: unknown): value is SanityMutatePatchMutation => {\n  if (typeof value !== 'object' || !value) return false\n  if (!('type' in value) || typeof value.type !== 'string' || value.type !== 'patch') return false\n  if (!('id' in value) || typeof value.id !== 'string') return false\n  if (!('patches' in value) || !Array.isArray(value.patches)) return false\n  return true\n}\n\n/** @beta */\nexport interface CreateDocumentAction<TDocument extends SanityDocumentLike = SanityDocumentLike>\n  extends DocumentTypeHandle<TDocument> {\n  type: 'document.create'\n}\n\n/** @beta */\nexport interface DeleteDocumentAction<TDocument extends SanityDocumentLike = SanityDocumentLike>\n  extends DocumentHandle<TDocument> {\n  type: 'document.delete'\n}\n\n/** @beta */\nexport interface EditDocumentAction<TDocument extends SanityDocumentLike = SanityDocumentLike>\n  extends DocumentHandle<TDocument> {\n  type: 'document.edit'\n  patches?: PatchOperations[]\n}\n\n/** @beta */\nexport interface PublishDocumentAction<TDocument extends SanityDocumentLike = SanityDocumentLike>\n  extends DocumentHandle<TDocument> {\n  type: 'document.publish'\n}\n\n/** @beta */\nexport interface UnpublishDocumentAction<TDocument extends SanityDocumentLike = SanityDocumentLike>\n  extends DocumentHandle<TDocument> {\n  type: 'document.unpublish'\n}\n\n/** @beta */\nexport interface DiscardDocumentAction<TDocument extends SanityDocumentLike = SanityDocumentLike>\n  extends DocumentHandle<TDocument> {\n  type: 'document.discard'\n}\n\n/** @beta */\nexport type DocumentAction<TDocument extends SanityDocumentLike = SanityDocumentLike> =\n  | CreateDocumentAction<TDocument>\n  | DeleteDocumentAction<TDocument>\n  | EditDocumentAction<TDocument>\n  | PublishDocumentAction<TDocument>\n  | UnpublishDocumentAction<TDocument>\n  | DiscardDocumentAction<TDocument>\n\n/** @beta */\nexport function createDocument<TDocument extends SanityDocumentLike>(\n  doc: DocumentTypeHandle<TDocument>,\n): CreateDocumentAction<TDocument> {\n  return {\n    type: 'document.create',\n    ...doc,\n    ...(doc.documentId && {documentId: getPublishedId(doc.documentId)}),\n  }\n}\n\n/** @beta */\nexport function deleteDocument<TDocument extends SanityDocumentLike>(\n  doc: DocumentHandle<TDocument>,\n): DeleteDocumentAction<TDocument> {\n  return {\n    type: 'document.delete',\n    ...doc,\n    documentId: getPublishedId(doc.documentId),\n  }\n}\n\nfunction convertSanityMutatePatch(\n  sanityPatchMutation: SanityMutatePatchMutation,\n): EditDocumentAction['patches'] {\n  const encoded = SanityEncoder.encode(sanityPatchMutation) as PatchMutation[]\n  return encoded.map((i) => {\n    const copy: PatchOperations = {...i.patch}\n    if ('id' in copy) delete copy.id\n    return copy\n  })\n}\n\n/** @beta */\nexport function editDocument<TDocument extends SanityDocumentLike>(\n  doc: DocumentHandle<TDocument>,\n  sanityMutatePatch: SanityMutatePatchMutation,\n): EditDocumentAction<TDocument>\n/** @beta */\nexport function editDocument<TDocument extends SanityDocumentLike>(\n  doc: DocumentHandle<TDocument>,\n  patches?: PatchOperations | PatchOperations[],\n): EditDocumentAction<TDocument>\n/** @beta */\nexport function editDocument<TDocument extends SanityDocumentLike>(\n  doc: DocumentHandle<TDocument>,\n  patches?: PatchOperations | PatchOperations[] | SanityMutatePatchMutation,\n): EditDocumentAction<TDocument> {\n  if (isSanityMutatePatch(patches)) {\n    const converted = convertSanityMutatePatch(patches) ?? []\n    return {\n      ...doc,\n      type: 'document.edit',\n      documentId: getPublishedId(doc.documentId),\n      patches: converted,\n    }\n  }\n\n  return {\n    ...doc,\n    type: 'document.edit',\n    documentId: getPublishedId(doc.documentId),\n    ...(patches && {patches: Array.isArray(patches) ? patches : [patches]}),\n  }\n}\n\n/** @beta */\nexport function publishDocument<TDocument extends SanityDocumentLike>(\n  doc: DocumentHandle<TDocument>,\n): PublishDocumentAction<TDocument> {\n  return {\n    type: 'document.publish',\n    ...doc,\n    documentId: getPublishedId(doc.documentId),\n  }\n}\n\n/** @beta */\nexport function unpublishDocument<TDocument extends SanityDocumentLike>(\n  doc: DocumentHandle<TDocument>,\n): UnpublishDocumentAction<TDocument> {\n  return {\n    type: 'document.unpublish',\n    ...doc,\n    documentId: getPublishedId(doc.documentId),\n  }\n}\n\n/** @beta */\nexport function discardDocument<TDocument extends SanityDocumentLike>(\n  doc: DocumentHandle<TDocument>,\n): DiscardDocumentAction<TDocument> {\n  return {\n    type: 'document.discard',\n    ...doc,\n    documentId: getPublishedId(doc.documentId),\n  }\n}\n","/**\n * When a document has no more subscribers, its state is cleaned up and removed\n * from the store. A delay used to prevent re-creating resources when the last\n * subscriber is removed quickly before another one is added. This is helpful\n * when used in a frontend where components may suspend or transition to\n * different views quickly.\n */\nexport const DOCUMENT_STATE_CLEAR_DELAY = 1000\nexport const INITIAL_OUTGOING_THROTTLE_TIME = 1000\nexport const API_VERSION = 'vX'\n","import {applyPatches, parsePatch} from '@sanity/diff-match-patch'\nimport {\n  type IndexTuple,\n  type InsertPatch,\n  isKeyedObject,\n  isKeySegment,\n  type KeyedSegment,\n  type Path,\n  type PathSegment,\n  type SanityDocumentLike,\n} from '@sanity/types'\n\ntype SingleValuePath = Exclude<PathSegment, IndexTuple>[]\n\ntype ToNumber<TInput extends string> = TInput extends `${infer TNumber extends number}`\n  ? TNumber\n  : TInput\n\n/**\n * Parse a single segment that may include bracket parts.\n *\n * For example, the literal\n *\n * ```\n * \"friends[0][1]\"\n * ```\n *\n * is parsed as:\n *\n * ```\n * [\"friends\", 0, 1]\n * ```\n */\ntype ParseSegment<TInput extends string> = TInput extends `${infer TProp}[${infer TRest}`\n  ? TProp extends ''\n    ? [...ParseBracket<`[${TRest}`>] // no property name before '['\n    : [TProp, ...ParseBracket<`[${TRest}`>]\n  : TInput extends ''\n    ? []\n    : [TInput]\n\n/**\n * Parse one or more bracketed parts from a segment.\n *\n * It recursively peels off a bracketed part and then continues.\n *\n * For example, given the string:\n *\n * ```\n * \"[0][foo]\"\n * ```\n *\n * it produces:\n *\n * ```\n * [ToNumber<\"0\">, \"foo\"]\n * ```\n */\ntype ParseBracket<TInput extends string> = TInput extends `[${infer TPart}]${infer TRest}`\n  ? [ToNumber<TPart>, ...ParseSegment<TRest>]\n  : [] // no leading bracket  end of this segment\n\n/**\n * Split the entire path string on dots outside of any brackets.\n *\n * For example:\n * ```\n * \"friends[0].name\"\n * ```\n *\n * becomes:\n *\n * ```\n * [...ParseSegment<\"friends[0]\">, ...ParseSegment<\"name\">]\n * ```\n *\n * (We use a simple recursion that splits on the first dot.)\n */\ntype PathParts<TPath extends string> = TPath extends `${infer TLeft}.${infer TRight}`\n  ? [...ParseSegment<TLeft>, ...PathParts<TRight>]\n  : ParseSegment<TPath>\n\n/**\n * Given a type T and an array of access keys Parts, recursively index into T.\n *\n * If a part is a key, it looks up that property.\n * If T is an array and the part is a number, it indexes into the element type.\n */\ntype DeepGet<T, TParts extends readonly unknown[]> = TParts extends [infer Head, ...infer Tail]\n  ? Head extends keyof T\n    ? DeepGet<T[Head], Tail>\n    : T extends Array<infer U>\n      ? Head extends number\n        ? DeepGet<U, Tail>\n        : never\n      : never\n  : T\n\n/**\n * Given a document type TDocument and a JSON Match path string TPath,\n * compute the type found at that path.\n * @beta\n */\nexport type JsonMatch<TDocument extends SanityDocumentLike, TPath extends string> = DeepGet<\n  TDocument,\n  PathParts<TPath>\n>\n\n/**\n * Computing the full possible paths may be possible but is hard to compute\n * within the type system for complex document types so we use string.\n * @beta\n */\nexport type JsonMatchPath<_TDocument extends SanityDocumentLike> = string\n\nfunction parseBracketContent(content: string): PathSegment {\n  // 1) Range match:  ^(\\d*):(\\d*)$\n  //    - start or end can be empty (meaning \"start\" or \"end\" of array)\n  const rangeMatch = content.match(/^(\\d*):(\\d*)$/)\n  if (rangeMatch) {\n    const startStr = rangeMatch[1]\n    const endStr = rangeMatch[2]\n    const start: number | '' = startStr === '' ? '' : parseInt(startStr, 10)\n    const end: number | '' = endStr === '' ? '' : parseInt(endStr, 10)\n    return [start, end]\n  }\n\n  // 2) Keyed segment match:  ^_key==[\"'](.*)[\"']$\n  //    (We allow either double or single quotes for the value)\n  const keyedMatch = content.match(/^_key==[\"'](.+)[\"']$/)\n  if (keyedMatch) {\n    return {_key: keyedMatch[1]}\n  }\n\n  // 3) Single index (positive or negative)\n  const index = parseInt(content, 10)\n  if (!isNaN(index)) {\n    return index\n  }\n\n  throw new Error(`Invalid bracket content: [${content}]`)\n}\n\nfunction parseSegment(segment: string): PathSegment[] {\n  // Each \"segment\" can contain:\n  // - A leading property name (optional).\n  // - Followed by zero or more bracket expressions, e.g. foo[1][_key==\"bar\"][2:9].\n  //\n  // We'll collect these into an array of path segments.\n\n  const segments: PathSegment[] = []\n  let idx = 0\n\n  // Helper to push a string if it's not empty\n  function pushIfNotEmpty(text: string) {\n    if (text) {\n      segments.push(text)\n    }\n  }\n\n  while (idx < segment.length) {\n    // Look for the next '['\n    const openIndex = segment.indexOf('[', idx)\n    if (openIndex === -1) {\n      // No more brackets  whatever remains is a plain string key\n      const remaining = segment.slice(idx)\n      pushIfNotEmpty(remaining)\n      break\n    }\n\n    // Push text before this bracket (as a string key) if not empty\n    const before = segment.slice(idx, openIndex)\n    pushIfNotEmpty(before)\n\n    // Find the closing bracket\n    const closeIndex = segment.indexOf(']', openIndex)\n    if (closeIndex === -1) {\n      throw new Error(`Unmatched \"[\" in segment: \"${segment}\"`)\n    }\n\n    // Extract the bracket content\n    const bracketContent = segment.slice(openIndex + 1, closeIndex)\n    segments.push(parseBracketContent(bracketContent))\n\n    // Move past the bracket\n    idx = closeIndex + 1\n  }\n\n  return segments\n}\n\nexport function parsePath(path: string): Path {\n  // We want to split on '.' outside of brackets. A simple approach is\n  // to track \"are we in bracket or not?\" while scanning.\n  const result: Path = []\n  let buffer = ''\n  let bracketDepth = 0\n\n  for (let i = 0; i < path.length; i++) {\n    const ch = path[i]\n    if (ch === '[') {\n      bracketDepth++\n      buffer += ch\n    } else if (ch === ']') {\n      bracketDepth--\n      buffer += ch\n    } else if (ch === '.' && bracketDepth === 0) {\n      // We hit a dot at the top level  this ends one segment\n      if (buffer) {\n        result.push(...parseSegment(buffer))\n        buffer = ''\n      }\n    } else {\n      buffer += ch\n    }\n  }\n\n  // If there's anything left in the buffer, parse it\n  if (buffer) {\n    result.push(...parseSegment(buffer))\n  }\n\n  return result\n}\n\nexport function stringifyPath(path: Path): string {\n  let result = ''\n  for (let i = 0; i < path.length; i++) {\n    const segment = path[i]\n\n    if (typeof segment === 'string') {\n      // If not the first segment and the previous segment was\n      // not a bracket form, we add a dot\n      if (result) {\n        result += '.'\n      }\n      result += segment\n    } else if (typeof segment === 'number') {\n      // Single index\n      result += `[${segment}]`\n    } else if (Array.isArray(segment)) {\n      // Index tuple\n      const [start, end] = segment\n      const startStr = start === '' ? '' : String(start)\n      const endStr = end === '' ? '' : String(end)\n      result += `[${startStr}:${endStr}]`\n    } else {\n      // Keyed segment\n      // e.g. {_key: \"someValue\"} => [_key==\"someValue\"]\n      result += `[_key==\"${segment._key}\"]`\n    }\n  }\n  return result\n}\n\ntype MatchEntry<T = unknown> = {\n  value: T\n  path: SingleValuePath\n}\n\n/**\n * A very simplified implementation of [JSONMatch][0] that only supports:\n * - descent e.g. `friend.name`\n * - array index e.g. `items[-1]`\n * - array matching with `_key` e.g. `items[_key==\"dd9efe09\"]`\n * - array matching with a range e.g. `items[4:]`\n *\n * E.g. `friends[_key==\"dd9efe09\"].address.zip`\n *\n * [0]: https://www.sanity.io/docs/json-match\n *\n * @beta\n */\nexport function jsonMatch<\n  TDocument extends SanityDocumentLike,\n  TPath extends JsonMatchPath<TDocument>,\n>(input: TDocument, path: TPath): MatchEntry<JsonMatch<TDocument, TPath>>[]\n/** @beta */\nexport function jsonMatch<TValue>(input: unknown, path: string): MatchEntry<TValue>[]\n/** @beta */\nexport function jsonMatch(input: unknown, pathExpression: string): MatchEntry[] {\n  return matchRecursive(input, parsePath(pathExpression), [])\n}\n\nfunction matchRecursive(value: unknown, path: Path, currentPath: SingleValuePath): MatchEntry[] {\n  // If we've consumed the entire path, return the final match\n  if (path.length === 0) {\n    return [{value, path: currentPath}]\n  }\n\n  const [head, ...rest] = path\n\n  // 1) String segment => object property\n  if (typeof head === 'string') {\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\n      const obj = value as Record<string, unknown>\n      const nextValue = obj[head]\n      return matchRecursive(nextValue, rest, [...currentPath, head])\n    }\n    // If not an object with that property, no match\n    return []\n  }\n\n  // 2) Numeric segment => array index\n  if (typeof head === 'number') {\n    if (Array.isArray(value)) {\n      const nextValue = value.at(head)\n      return matchRecursive(nextValue, rest, [...currentPath, head])\n    }\n    // If not an array, no match\n    return []\n  }\n\n  // 3) Index tuple => multiple indices\n  if (Array.isArray(head)) {\n    // This is a range: [start, end]\n    if (!Array.isArray(value)) {\n      // If not an array, no match\n      return []\n    }\n\n    const [start, end] = head\n    // Convert empty strings '' to the start/end of the array\n    const startIndex = start === '' ? 0 : start\n    const endIndex = end === '' ? value.length : end\n\n    // Well accumulate all matches from each index in the range\n    let results: MatchEntry[] = []\n\n    // Decide whether the range is exclusive or inclusive. The example in\n    // the doc says \"array[1:9]\" => element 1 through 9 (non-inclusive?).\n    // Typically, in slice terms, that is `array.slice(1, 9)`  includes\n    // indices 1..8. If that's your intention, do i < endIndex.\n    for (let i = startIndex; i < endIndex; i++) {\n      results = results.concat(matchRecursive(value[i], rest, [...currentPath, i]))\n    }\n\n    return results\n  }\n\n  // 4) Keyed segment => find index in array\n  //    e.g. {_key: 'foo'}\n  const keyed = head as KeyedSegment\n  const arrIndex = getIndexForKey(value, keyed._key)\n  if (arrIndex === undefined || !Array.isArray(value)) {\n    return []\n  }\n\n  const nextVal = value[arrIndex]\n  return matchRecursive(nextVal, rest, [...currentPath, arrIndex])\n}\n\n// this is a similar array key to the studio:\n// https://github.com/sanity-io/sanity/blob/v3.74.1/packages/sanity/src/core/form/inputs/arrays/ArrayOfObjectsInput/createProtoArrayValue.ts\nfunction generateArrayKey(length: number = 12): string {\n  // Each byte gives two hex characters, so generate enough bytes.\n  const numBytes = Math.ceil(length / 2)\n  const bytes = crypto.getRandomValues(new Uint8Array(numBytes))\n  // Convert each byte to a 2-digit hex string and join them.\n  return Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0'))\n    .join('')\n    .slice(0, length)\n}\n\nfunction memoize<TFunction extends (input: unknown) => unknown>(fn: TFunction): TFunction {\n  const cache = new WeakMap<object, unknown>()\n  return ((input) => {\n    if (!input || typeof input !== 'object') return fn(input)\n\n    const cached = cache.get(input)\n    if (cached) return cached\n\n    const result = fn(input)\n    cache.set(input, result)\n    return result\n  }) as TFunction\n}\n\n/**\n * Recursively traverse a value. When an array is encountered, ensure that\n * each object item has a _key property. Memoized such that sub-objects that\n * have not changed aren't re-computed.\n */\nexport const ensureArrayKeysDeep = memoize(<R>(input: R): R => {\n  if (!input || typeof input !== 'object') return input\n\n  if (Array.isArray(input)) {\n    // if the array is empty then just return the input\n    if (!input.length) return input\n    const first = input[0]\n    // if the first input in the array isn't an object (null is allowed) then\n    // assume that this is an array of primitives, just return the input\n    if (typeof first !== 'object') return input\n\n    // if all the items already have a key, then return the input\n    if (input.every(isKeyedObject)) return input\n\n    // otherwise return a new object item with a new key\n    return input.map((item: unknown) => {\n      if (!item || typeof item !== 'object') return item\n      if (isKeyedObject(item)) return ensureArrayKeysDeep(item)\n      const next = ensureArrayKeysDeep(item)\n      return {...next, _key: generateArrayKey()}\n    }) as R\n  }\n\n  const entries = Object.entries(input).map(([key, value]) => [key, ensureArrayKeysDeep(value)])\n\n  if (entries.every(([key, value]) => input[key as keyof typeof input] === value)) {\n    return input\n  }\n\n  return Object.fromEntries(entries) as R\n})\n\n/**\n * Given an input object and a record of path expressions to values, this\n * function will set each match with the given value.\n *\n * ```js\n * const output = set(\n *   {name: {first: 'initial', last: 'initial'}},\n *   {'name.first': 'changed'}\n * );\n *\n * // { name: { first: 'changed', last: 'initial' } }\n * console.log(output);\n * ```\n */\nexport function set<R>(input: unknown, pathExpressionValues: Record<string, unknown>): R\nexport function set(input: unknown, pathExpressionValues: Record<string, unknown>): unknown {\n  const result = Object.entries(pathExpressionValues)\n    .flatMap(([pathExpression, replacementValue]) =>\n      jsonMatch(input, pathExpression).map((matchEntry) => ({\n        ...matchEntry,\n        replacementValue,\n      })),\n    )\n    .reduce((acc, {path, replacementValue}) => setDeep(acc, path, replacementValue), input)\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Given an input object and a record of path expressions to values, this\n * function will set each match with the given value **if the value at the current\n * path is missing** (i.e. `null` or `undefined`).\n *\n * ```js\n * const output = setIfMissing(\n *   {items: [null, 'initial']},\n *   {'items[:]': 'changed'}\n * );\n *\n * // { items: ['changed', 'initial'] }\n * console.log(output);\n * ```\n */\nexport function setIfMissing<R>(input: unknown, pathExpressionValues: Record<string, unknown>): R\nexport function setIfMissing(\n  input: unknown,\n  pathExpressionValues: Record<string, unknown>,\n): unknown {\n  const result = Object.entries(pathExpressionValues)\n    .flatMap(([pathExpression, replacementValue]) => {\n      return jsonMatch(input, pathExpression).map((matchEntry) => ({\n        ...matchEntry,\n        replacementValue,\n      }))\n    })\n    .filter((matchEntry) => matchEntry.value === null || matchEntry.value === undefined)\n    .reduce((acc, {path, replacementValue}) => setDeep(acc, path, replacementValue), input)\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Given an input object and an array of path expressions, this function will\n * remove each match from the input object.\n *\n * ```js\n * const output = unset(\n *   {name: {first: 'one', last: 'two'}},\n *   ['name.last']\n * );\n *\n * // { name: { first: 'one' } }\n * console.log(output);\n * ```\n */\nexport function unset<R>(input: unknown, pathExpressions: string[]): R\nexport function unset(input: unknown, pathExpressions: string[]): unknown {\n  const result = pathExpressions\n    .flatMap((pathExpression) => jsonMatch(input, pathExpression))\n    .reduce((acc, {path}) => unsetDeep(acc, path), input)\n\n  return ensureArrayKeysDeep(result)\n}\n\nconst operations = ['before', 'after', 'replace'] as const\ntype Operation = (typeof operations)[number]\n\n/**\n * Given an input object, a path expression (inside the insert patch object), and an array of items,\n * this function will insert or replace the matched items.\n *\n * **Insert before:**\n *\n * ```js\n * const input = {some: {array: ['a', 'b', 'c']}}\n * const output = insert(\n *   input,\n *   {\n *     before: 'some.array[1]',\n *     items: ['!']\n *   }\n * );\n * // { some: { array: ['a', '!', 'b', 'c'] } }\n * console.log(output);\n * ```\n *\n * **Insert before with negative index (append):**\n *\n * ```js\n * const input = {some: {array: ['a', 'b', 'c']}}\n * const output = insert(\n *   input,\n *   {\n *     before: 'some.array[-1]',\n *     items: ['!']\n *   }\n * );\n * // { some: { array: ['a', 'b', 'c', '!'] } }\n * console.log(output);\n * ```\n *\n * **Insert after:**\n *\n * ```js\n * const input = {some: {array: ['a', 'b', 'c']}}\n * const output = insert(\n *   input,\n *   {\n *     after: 'some.array[1]',\n *     items: ['!']\n *   }\n * );\n * // { some: { array: ['a', 'b', '!', 'c'] } }\n * console.log(output);\n * ```\n *\n * **Replace:**\n *\n * ```js\n * const output = insert(\n *   { some: { array: ['a', 'b', 'c'] } },\n *   {\n *     replace: 'some.array[1]',\n *     items: ['!']\n *   }\n * );\n * // { some: { array: ['a', '!', 'c'] } }\n * console.log(output);\n * ```\n *\n * **Replace many:**\n *\n * ```js\n * const input = {some: {array: ['a', 'b', 'c', 'd']}}\n * const output = insert(\n *   input,\n *   {\n *     replace: 'some.array[1:3]',\n *     items: ['!', '?']\n *   }\n * );\n * // { some: { array: ['a', '!', '?', 'd'] } }\n * console.log(output);\n * ```\n */\nexport function insert<R>(input: unknown, insertPatch: InsertPatch): R\nexport function insert(input: unknown, insertPatch: InsertPatch): unknown {\n  const operation = operations.find((op) => op in insertPatch)\n  if (!operation) return input\n\n  const {items} = insertPatch\n  const pathExpression = (insertPatch as {[K in Operation]?: string} & {items: unknown})[operation]\n  if (typeof pathExpression !== 'string') return input\n\n  // Helper to normalize a matched index given the parent arrays length.\n  function normalizeIndex(index: number, parentLength: number): number {\n    switch (operation) {\n      case 'before':\n        // A negative index means append (i.e. insert before a hypothetical element\n        // beyond the end of the array).\n        return index < 0 ? parentLength : index\n      case 'after':\n        // For \"after\", if the matched index is negative, we treat it as prepend:\n        // by convention, we convert it to -1 so that later adding 1 produces 0.\n        return index < 0 ? -1 : index\n      default: // default to 'replace'\n        // For replace, convert a negative index to the corresponding positive one.\n        return index < 0 ? parentLength + index : index\n    }\n  }\n\n  // Group the matched array entries by their parent array.\n  interface GroupEntry {\n    array: unknown[]\n    pathToArray: SingleValuePath\n    indexes: number[]\n  }\n  const grouped = new Map<unknown, GroupEntry>()\n  jsonMatch(input, pathExpression)\n    .map(({path}) => {\n      const segment = path[path.length - 1]\n      let index: number | undefined\n      if (isKeySegment(segment)) {\n        index = getIndexForKey(input, segment._key)\n      } else if (typeof segment === 'number') {\n        index = segment\n      }\n      if (typeof index !== 'number') return null\n\n      const parentPath = path.slice(0, path.length - 1)\n      const parent = getDeep(input, parentPath)\n      if (!Array.isArray(parent)) return null\n\n      const normalizedIndex = normalizeIndex(index, parent.length)\n      return {parent, parentPath, normalizedIndex}\n    })\n    .filter(isNonNullable)\n    .forEach(({parent, parentPath, normalizedIndex}) => {\n      if (grouped.has(parent)) {\n        grouped.get(parent)!.indexes.push(normalizedIndex)\n      } else {\n        grouped.set(parent, {array: parent, pathToArray: parentPath, indexes: [normalizedIndex]})\n      }\n    })\n\n  // Sort the indexes for each grouped entry.\n  const groupEntries = Array.from(grouped.values()).map((entry) => ({\n    ...entry,\n    indexes: entry.indexes.sort((a, b) => a - b),\n  }))\n\n  // For each group, update the parent array using setDeep.\n  const result = groupEntries.reduce<unknown>((acc, {array, indexes, pathToArray}) => {\n    switch (operation) {\n      case 'before': {\n        // Insert items before the first matched index.\n        const firstIndex = indexes[0]\n        return setDeep(acc, pathToArray, [\n          ...array.slice(0, firstIndex),\n          ...items,\n          ...array.slice(firstIndex),\n        ])\n      }\n      case 'after': {\n        // Insert items after the last matched index.\n        const lastIndex = indexes[indexes.length - 1] + 1\n        return setDeep(acc, pathToArray, [\n          ...array.slice(0, lastIndex),\n          ...items,\n          ...array.slice(lastIndex),\n        ])\n      }\n      // default to 'replace' behavior\n      default: {\n        // Remove all matched items then insert the new items at the first match.\n        const firstIndex = indexes[0]\n        const indexSet = new Set(indexes)\n        return setDeep(acc, pathToArray, [\n          ...array.slice(0, firstIndex),\n          ...items,\n          ...array.slice(firstIndex).filter((_, idx) => !indexSet.has(idx + firstIndex)),\n        ])\n      }\n    }\n  }, input)\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Given an input object and a record of path expressions to numeric values,\n * this function will increment each match with the given value.\n *\n * ```js\n * const output = inc(\n *   {foo: {first: 3, second: 4.5}},\n *   {'foo.first': 3, 'foo.second': 4}\n * );\n *\n * // { foo: { first: 6, second: 8.5 } }\n * console.log(output);\n * ```\n */\nexport function inc<R>(input: unknown, pathExpressionValues: Record<string, number>): R\nexport function inc(input: unknown, pathExpressionValues: Record<string, number>): unknown {\n  const result = Object.entries(pathExpressionValues)\n    .flatMap(([pathExpression, valueToAdd]) =>\n      jsonMatch(input, pathExpression).map((matchEntry) => ({\n        ...matchEntry,\n        valueToAdd,\n      })),\n    )\n    .filter(\n      <T extends {value: unknown}>(matchEntry: T): matchEntry is T & {value: number} =>\n        typeof matchEntry.value === 'number',\n    )\n    .reduce((acc, {path, value, valueToAdd}) => setDeep(acc, path, value + valueToAdd), input)\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Given an input object and a record of path expressions to numeric values,\n * this function will decrement each match with the given value.\n *\n * ```js\n * const output = dec(\n *   {foo: {first: 3, second: 4.5}},\n *   {'foo.first': 3, 'foo.second': 4}\n * );\n *\n * // { foo: { first: 0, second: 0.5 } }\n * console.log(output);\n * ```\n */\nexport function dec<R>(input: unknown, pathExpressionValues: Record<string, number>): R\nexport function dec(input: unknown, pathExpressionValues: Record<string, number>): unknown {\n  const result = inc(\n    input,\n    Object.fromEntries(\n      Object.entries(pathExpressionValues)\n        .filter(([, value]) => typeof value === 'number')\n        .map(([key, value]) => [key, -value]),\n    ),\n  )\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Given an input object and a record of paths to [diff match patches][0], this\n * function will apply the diff match patch for the string at each match.\n *\n * [0]: https://www.sanity.io/docs/http-patches#aTbJhlAJ\n *\n * ```js\n * const output = diffMatchPatch(\n *   {foo: 'the quick brown fox'},\n *   {'foo': '@@ -13,7 +13,7 @@\\n own \\n-fox\\n+cat\\n'}\n * );\n *\n * // { foo: 'the quick brown cat' }\n * console.log(output);\n * ```\n */\nexport function diffMatchPatch<R>(input: unknown, pathExpressionValues: Record<string, string>): R\nexport function diffMatchPatch(\n  input: unknown,\n  pathExpressionValues: Record<string, string>,\n): unknown {\n  const result = Object.entries(pathExpressionValues)\n    .flatMap(([pathExpression, dmp]) => jsonMatch(input, pathExpression).map((m) => ({...m, dmp})))\n    .filter((i) => i.value !== undefined)\n    .map(({path, value, dmp}) => {\n      if (typeof value !== 'string') {\n        throw new Error(\n          `Can't diff-match-patch \\`${JSON.stringify(value)}\\` at path \\`${stringifyPath(path)}\\`, because it is not a string`,\n        )\n      }\n\n      const [nextValue] = applyPatches(parsePatch(dmp), value)\n      return {path, value: nextValue}\n    })\n    .reduce((acc, {path, value}) => setDeep(acc, path, value), input)\n\n  return ensureArrayKeysDeep(result)\n}\n\n/**\n * Simply checks if the given document input has a `_rev` that matches the given\n * `revisionId` and throws otherwise.\n *\n * (No code example provided.)\n */\nexport function ifRevisionID<R>(input: unknown, revisionId: string): R\nexport function ifRevisionID(input: unknown, revisionId: string): unknown {\n  const inputRev =\n    typeof input === 'object' && !!input && '_rev' in input && typeof input._rev === 'string'\n      ? input._rev\n      : undefined\n\n  if (typeof inputRev !== 'string') {\n    throw new Error(`Patch specified \\`ifRevisionID\\` but could not find document's revision ID.`)\n  }\n\n  if (revisionId !== inputRev) {\n    throw new Error(\n      `Patch's \\`ifRevisionID\\` \\`${revisionId}\\` does not match document's revision ID \\`${inputRev}\\``,\n    )\n  }\n\n  return input\n}\n\nfunction isNonNullable<T>(t: T): t is NonNullable<T> {\n  return t !== null && t !== undefined\n}\n\nconst indexCache = new WeakMap<KeyedSegment[], Record<string, number | undefined>>()\nexport function getIndexForKey(input: unknown, key: string): number | undefined {\n  if (!Array.isArray(input)) return undefined\n  const cached = indexCache.get(input)\n  if (cached) return cached[key]\n\n  const lookup = input.reduce<Record<string, number | undefined>>((acc, next, index) => {\n    if (typeof next?._key === 'string') acc[next._key] = index\n    return acc\n  }, {})\n\n  indexCache.set(input, lookup)\n  return lookup[key]\n}\n\n/**\n * Gets a value deep inside of an object given a path. If the path does not\n * exist in the object, `undefined` will be returned.\n */\nexport function getDeep<R>(input: unknown, path: SingleValuePath): R\nexport function getDeep(input: unknown, path: SingleValuePath): unknown {\n  const [currentSegment, ...restOfPath] = path\n  if (currentSegment === undefined) return input\n  if (typeof input !== 'object' || input === null) return undefined\n\n  let key\n  if (isKeySegment(currentSegment)) {\n    key = getIndexForKey(input, currentSegment._key)\n  } else if (typeof currentSegment === 'string') {\n    key = currentSegment\n  } else if (typeof currentSegment === 'number') {\n    key = currentSegment\n  }\n\n  if (key === undefined) return undefined\n\n  // Use .at() to support negative indexes on arrays.\n  const nestedInput =\n    typeof key === 'number' && Array.isArray(input)\n      ? input.at(key)\n      : (input as Record<string, unknown>)[key]\n\n  return getDeep(nestedInput, restOfPath)\n}\n\n/**\n * Sets a value deep inside of an object given a path. If the path does not\n * exist in the object, it will be created.\n */\nexport function setDeep<R>(input: unknown, path: SingleValuePath, value: unknown): R\nexport function setDeep(input: unknown, path: SingleValuePath, value: unknown): unknown {\n  const [currentSegment, ...restOfPath] = path\n  if (currentSegment === undefined) return value\n\n  // If the current input is not an object, create a new container.\n  if (typeof input !== 'object' || input === null) {\n    if (typeof currentSegment === 'string') {\n      return {[currentSegment]: setDeep(null, restOfPath, value)}\n    }\n\n    let index: number | undefined\n    if (isKeySegment(currentSegment)) {\n      // When creating a new array via a keyed segment, use index 0.\n      index = 0\n    } else if (typeof currentSegment === 'number' && currentSegment >= 0) {\n      index = currentSegment\n    } else {\n      // For negative numbers in a nonobject we simply return input.\n      return input\n    }\n\n    return [\n      // fill until index\n      ...Array.from({length: index}).fill(null),\n      // then set deep here\n      setDeep(null, restOfPath, value),\n    ]\n  }\n\n  // When input is an array\n  if (Array.isArray(input)) {\n    let index: number | undefined\n    if (isKeySegment(currentSegment)) {\n      index = getIndexForKey(input, currentSegment._key)\n    } else if (typeof currentSegment === 'number') {\n      // Support negative indexes by computing the proper positive index.\n      index = currentSegment < 0 ? input.length + currentSegment : currentSegment\n    }\n    if (index === undefined) return input\n\n    if (index in input) {\n      // Update the element at the resolved index.\n      return input.map((nestedInput, i) =>\n        i === index ? setDeep(nestedInput, restOfPath, value) : nestedInput,\n      )\n    }\n\n    // Expand the array if needed.\n    return [\n      ...input,\n      ...Array.from({length: index - input.length}).fill(null),\n      setDeep(null, restOfPath, value),\n    ]\n  }\n\n  // For keyed segments that arent arrays, do nothing.\n  if (typeof currentSegment === 'object') return input\n\n  // For plain objects, update an existing property if it exists\n  if (currentSegment in input) {\n    return Object.fromEntries(\n      Object.entries(input).map(([key, nestedInput]) =>\n        key === currentSegment\n          ? [key, setDeep(nestedInput, restOfPath, value)]\n          : [key, nestedInput],\n      ),\n    )\n  }\n\n  // ...otherwise create the new nested path.\n  return {...input, [currentSegment]: setDeep(null, restOfPath, value)}\n}\n\n/**\n * Given an object and an exact path as an array, this unsets the value at the\n * given path.\n */\nexport function unsetDeep<R>(input: unknown, path: SingleValuePath): R\nexport function unsetDeep(input: unknown, path: SingleValuePath): unknown {\n  const [currentSegment, ...restOfPath] = path\n  if (currentSegment === undefined) return input\n  if (typeof input !== 'object' || input === null) return input\n\n  let _segment: string | number | undefined\n  if (isKeySegment(currentSegment)) {\n    _segment = getIndexForKey(input, currentSegment._key)\n  } else if (typeof currentSegment === 'string' || typeof currentSegment === 'number') {\n    _segment = currentSegment\n  }\n  if (_segment === undefined) return input\n\n  // For numeric segments in arrays, compute the positive index.\n  let segment: string | number = _segment\n  if (typeof segment === 'number' && Array.isArray(input)) {\n    segment = segment < 0 ? input.length + segment : segment\n  }\n  if (!(segment in input)) return input\n\n  // If we're at the final segment, remove the property/element.\n  if (!restOfPath.length) {\n    if (Array.isArray(input)) {\n      return input.filter((_nestedInput, index) => index !== segment)\n    }\n    return Object.fromEntries(Object.entries(input).filter(([key]) => key !== segment.toString()))\n  }\n\n  // Otherwise, recurse into the nested value.\n  if (Array.isArray(input)) {\n    return input.map((nestedInput, index) =>\n      index === segment ? unsetDeep(nestedInput, restOfPath) : nestedInput,\n    )\n  }\n\n  return Object.fromEntries(\n    Object.entries(input).map(([key, value]) =>\n      key === segment ? [key, unsetDeep(value, restOfPath)] : [key, value],\n    ),\n  )\n}\n","import {\n  type Mutation,\n  type MutationSelection,\n  type PatchOperations,\n  type SanityDocument,\n} from '@sanity/types'\n\nimport {\n  dec,\n  diffMatchPatch,\n  ifRevisionID,\n  inc,\n  insert,\n  set,\n  setIfMissing,\n  unset,\n} from './patchOperations'\n\n/**\n * Represents a set of document that will go into `applyMutations`. Before\n * applying a mutation, it's expected that all relevant documents that the\n * mutations affect are included, including those that do not exist yet.\n * Documents that don't exist have a `null` value.\n */\nexport type DocumentSet<TDocument extends SanityDocument = SanityDocument> = {\n  [TDocumentId in string]?: TDocument | null\n}\n\ntype SupportPatchOperation = Exclude<keyof PatchOperations, 'merge'>\n\n// > If multiple patches are included, then the order of execution is as follows:\n// > - set, setIfMissing, unset, inc, dec, insert.\n// > https://www.sanity.io/docs/http-mutations#5b4db1396e56\nconst patchOperations = {\n  ifRevisionID,\n  set,\n  setIfMissing,\n  unset,\n  inc,\n  dec,\n  insert,\n  diffMatchPatch,\n} satisfies {\n  [K in SupportPatchOperation]: (\n    input: unknown,\n    pathExpressions: NonNullable<PatchOperations[K]>,\n  ) => unknown\n}\n\n/**\n * Implements ID generation:\n *\n * A create mutation creates a new document. It takes the literal document\n * content as its argument. The rules for the new document's identifier are as\n * follows:\n *\n * - If the `_id` attribute is missing, then a new, random, unique ID is\n *   generated.\n * - If the `_id` attribute is present but ends with `.`, then it is used as a\n *   prefix for a new, random, unique ID.\n * - If the _id attribute is present, it is used as-is.\n *\n * [- source](https://www.sanity.io/docs/http-mutations#c732f27330a4)\n */\nexport function getId(id?: string): string {\n  if (!id || typeof id !== 'string') return crypto.randomUUID()\n  if (id.endsWith('.')) return `${id}${crypto.randomUUID()}`\n  return id\n}\n\ninterface ProcessMutationsOptions {\n  /**\n   * The transaction ID that will become the next `_rev` for documents mutated\n   * by the given mutations.\n   */\n  transactionId: string\n  /**\n   * The input document set that the mutations will be applied to.\n   */\n  documents: DocumentSet\n  /**\n   * A list of mutations to apply to the given document set.\n   */\n  mutations: Mutation[]\n  /**\n   * An optional timestamp that will be used for `_createdAt` and `_updatedAt`\n   * timestamp when applicable.\n   */\n  timestamp?: string\n}\n\nexport function getDocumentIds(selection: MutationSelection): string[] {\n  if ('id' in selection) {\n    // NOTE: the `MutationSelection` type within `@sanity/client` (instead of\n    // `@sanity/types`) allows for the ID field to be an array of strings so we\n    // support that as well\n    const array = Array.isArray(selection.id) ? selection.id : [selection.id]\n    const ids = array.filter((id): id is string => typeof id === 'string')\n    return Array.from(new Set(ids))\n  }\n\n  if ('query' in selection) {\n    throw new Error(`'query' in mutations is not supported.`)\n  }\n\n  return []\n}\n\n/**\n * Applies the given mutation to the given document set. Note, it is expected\n * that all relevant documents that the mutations affect should be within the\n * given `document` set. If a document does not exist, it should have the value\n * `null`. If a document is deleted as a result of the mutations, it will still\n * have its document ID present in the returns documents, but it will have a\n * value of `null`.\n *\n * The given `transactionId` will be used as the resulting `_rev` for documents\n * affected by the given set of mutations.\n *\n * If a `timestamp` is given, that will be used as for the relevant `_updatedAt`\n * and `_createdAt` timestamps.\n */\nexport function processMutations({\n  documents,\n  mutations,\n  transactionId,\n  timestamp,\n}: ProcessMutationsOptions): DocumentSet {\n  // early return if there are no mutations given\n  if (!mutations.length) return documents\n\n  const dataset = {...documents}\n  const now = timestamp || new Date().toISOString()\n\n  for (const mutation of mutations) {\n    if ('create' in mutation) {\n      const id = getId(mutation.create._id)\n\n      if (dataset[id]) {\n        throw new Error(\n          `Cannot create document with \\`_id\\` \\`${id}\\` because another document with the same ID already exists.`,\n        )\n      }\n\n      const document: SanityDocument = {\n        // > `_createdAt` and `_updatedAt` may be submitted and will override\n        // > the default which is of course the current time. This can be used\n        // > to reconstruct a data-set with its timestamp structure intact.\n        // >\n        // > [- source](https://www.sanity.io/docs/http-mutations#c732f27330a4)\n        _createdAt: now,\n        _updatedAt: now,\n        ...mutation.create, // prefer the user's `_createdAt` and `_updatedAt`\n        _rev: transactionId,\n        _id: id,\n      }\n\n      dataset[id] = document\n\n      continue\n    }\n\n    if ('createOrReplace' in mutation) {\n      const id = getId(mutation.createOrReplace._id)\n      const prev = dataset[id]\n\n      const document: SanityDocument = {\n        ...mutation.createOrReplace,\n        // otherwise, if the mutation provided, a `_createdAt` time, use it,\n        // otherwise default to now\n        _createdAt:\n          // if there was an existing document, use the previous `_createdAt`\n          // since we're replacing the current document\n          prev?._createdAt ||\n          // if there was no previous document, then we're creating this\n          // document for the first time so we should use the `_createdAt` from\n          // the mutation if the user included it\n          (typeof mutation.createOrReplace['_createdAt'] === 'string' &&\n            mutation.createOrReplace['_createdAt']) ||\n          // otherwise, default to now\n          now,\n\n        _updatedAt:\n          // if there was an existing document, then set the `_updatedAt` to now\n          // since we're replacing the current document\n          prev\n            ? now\n            : // otherwise, we're creating this document for the first time,\n              // in that case, use the user's `_updatedAt` if included in the\n              // mutation\n              (typeof mutation.createOrReplace['_updatedAt'] === 'string' &&\n                mutation.createOrReplace['_updatedAt']) ||\n              // otherwise default to now\n              now,\n        _rev: transactionId,\n        _id: id,\n      }\n\n      dataset[id] = document\n\n      continue\n    }\n\n    if ('createIfNotExists' in mutation) {\n      const id = getId(mutation.createIfNotExists._id)\n      const prev = dataset[id]\n      if (prev) continue\n\n      const document: SanityDocument = {\n        // same logic as `create`:\n        // prefer the user's `_createdAt` and `_updatedAt`\n        _createdAt: now,\n        _updatedAt: now,\n        ...mutation.createIfNotExists,\n        _rev: transactionId,\n        _id: id,\n      }\n\n      dataset[id] = document\n\n      continue\n    }\n\n    if ('delete' in mutation) {\n      for (const id of getDocumentIds(mutation.delete)) {\n        dataset[id] = null\n      }\n\n      continue\n    }\n\n    if ('patch' in mutation) {\n      const {patch} = mutation\n      const ids = getDocumentIds(patch)\n\n      const patched = ids.map((id) => {\n        if (!dataset[id]) {\n          throw new Error(`Cannot patch document with ID \\`${id}\\` because it was not found.`)\n        }\n\n        type Entries<T> = {[K in keyof T]: [K, T[K]]}[keyof T][]\n        const entries = Object.entries(patchOperations) as Entries<typeof patchOperations>\n\n        return entries.reduce((acc, [type, operation]) => {\n          if (patch[type]) {\n            return operation(\n              acc,\n              // @ts-expect-error TS doesn't handle this union very well\n              patch[type],\n            )\n          }\n          return acc\n        }, dataset[id])\n      })\n\n      for (const result of patched) {\n        dataset[result._id] = {\n          ...result,\n          _rev: transactionId,\n          _updatedAt: now,\n        }\n      }\n\n      continue\n    }\n  }\n\n  return dataset\n}\n","import {type MutationEvent} from '@sanity/client'\nimport {type Mutation, type SanityDocument} from '@sanity/types'\nimport {\n  concat,\n  concatMap,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  map,\n  type Observable,\n  of,\n  switchMap,\n  throwError,\n  timer,\n  withLatestFrom,\n} from 'rxjs'\nimport {mergeMap, scan} from 'rxjs/operators'\n\nimport {type StoreContext} from '../store/defineStore'\nimport {type DocumentStoreState} from './documentStore'\nimport {processMutations} from './processMutations'\n\nconst DEFAULT_MAX_BUFFER_SIZE = 20\nconst DEFAULT_DEADLINE_MS = 30000\n\nexport interface RemoteDocument {\n  type: 'sync' | 'mutation'\n  documentId: string\n  document: SanityDocument | null\n  revision?: string\n  previousRev?: string\n  timestamp: string\n}\n\nexport interface SyncEvent {\n  type: 'sync'\n  document: SanityDocument | null\n}\n\nexport type ListenerEvent = SyncEvent | MutationEvent\n\ninterface ListenerSequenceState {\n  /**\n   * Tracks the latest revision from the server that can be applied locally\n   * Once we receive a mutation event that has a `previousRev` that equals `base.revision`\n   * we will move `base.revision` to the event's `resultRev`\n   * `base.revision` will be undefined if document doesn't exist.\n   * `base` is `undefined` until the snapshot event is received\n   */\n  base: {revision: string | undefined} | undefined\n  /**\n   * Array of events to pass on to the stream, e.g. when mutation applies to current head revision, or a chain is complete\n   */\n  emitEvents: ListenerEvent[]\n  /**\n   * Buffer to keep track of events that doesn't line up in a [previousRev, resultRev] -- [previousRev, resultRev] sequence\n   * This can happen if events arrive out of order, or if an event in the middle for some reason gets lost\n   */\n  buffer: MutationEvent[]\n}\n\nexport class OutOfSyncError extends Error {\n  /**\n   * Attach state to the error for debugging/reporting\n   */\n  state: ListenerSequenceState\n  constructor(message: string, state: ListenerSequenceState) {\n    super(message)\n    this.name = 'OutOfSyncError'\n    this.state = state\n  }\n}\n\nexport class DeadlineExceededError extends OutOfSyncError {\n  constructor(message: string, state: ListenerSequenceState) {\n    super(message, state)\n    this.name = 'DeadlineExceededError'\n  }\n}\n\nexport class MaxBufferExceededError extends OutOfSyncError {\n  constructor(message: string, state: ListenerSequenceState) {\n    super(message, state)\n    this.name = 'MaxBufferExceededError'\n  }\n}\n\ninterface SortListenerEventsOptions {\n  maxBufferSize?: number\n  resolveChainDeadline?: number\n}\n\n/**\n * Takes an input observable of listener events that might arrive out of order, and emits them in sequence\n * If we receive mutation events that doesn't line up in [previousRev, resultRev] pairs we'll put them in a buffer and\n * check if we have an unbroken chain every time we receive a new event\n *\n * If the buffer grows beyond `maxBufferSize`, or if `resolveChainDeadline` milliseconds passes before the chain resolves\n * an OutOfSyncError will be thrown on the stream\n *\n * @internal\n */\nexport function sortListenerEvents(options?: SortListenerEventsOptions) {\n  const {resolveChainDeadline = DEFAULT_DEADLINE_MS, maxBufferSize = DEFAULT_MAX_BUFFER_SIZE} =\n    options || {}\n\n  return (input$: Observable<ListenerEvent>): Observable<ListenerEvent> => {\n    return input$.pipe(\n      // Maintain state: current base revision, a buffer of pending mutation events,\n      // and a list of events to emit.\n      scan(\n        (state: ListenerSequenceState, event: ListenerEvent): ListenerSequenceState => {\n          // When a sync event is received, reset the base and clear any pending mutations.\n          if (event.type === 'sync') {\n            return {\n              base: {revision: event.document?._rev},\n              buffer: [],\n              emitEvents: [event],\n            }\n          }\n          // For mutation events we must have a base revision (from a prior sync event)\n          if (event.type === 'mutation') {\n            if (!state.base) {\n              throw new Error(\n                'Invalid state. Cannot process mutation event without a base sync event',\n              )\n            }\n            // Add the new mutation event into the buffer\n            const buffer = state.buffer.concat(event)\n            const emitEvents: MutationEvent[] = []\n            let baseRevision = state.base.revision\n            let progress = true\n\n            // Try to apply as many buffered mutations as possible.\n            while (progress) {\n              progress = false\n              // Look for a mutation whose previousRev matches the current base.\n              const idx = buffer.findIndex((e) => e.previousRev === baseRevision)\n              if (idx !== -1) {\n                // Remove the event from the buffer and apply it.\n                const [next] = buffer.splice(idx, 1)\n                emitEvents.push(next)\n                // If the mutation is a deletion, the new base revision is undefined.\n                baseRevision = next.transition === 'disappear' ? undefined : next.resultRev\n                progress = true\n              }\n            }\n\n            if (buffer.length >= maxBufferSize) {\n              throw new MaxBufferExceededError(\n                `Too many unchainable mutation events (${buffer.length}) waiting to resolve.`,\n                {base: {revision: baseRevision}, buffer, emitEvents},\n              )\n            }\n\n            return {\n              base: {revision: baseRevision},\n              buffer,\n              emitEvents,\n            }\n          }\n          // Any other event is simply forwarded.\n          return {...state, emitEvents: [event]}\n        },\n        {\n          base: undefined,\n          buffer: [] as MutationEvent[],\n          emitEvents: [] as ListenerEvent[],\n        },\n      ),\n      switchMap((state) => {\n        if (state.buffer.length > 0) {\n          return concat(\n            of(state),\n            timer(resolveChainDeadline).pipe(\n              mergeMap(() =>\n                throwError(\n                  () =>\n                    new DeadlineExceededError(\n                      `Did not resolve chain within a deadline of ${resolveChainDeadline}ms`,\n                      state,\n                    ),\n                ),\n              ),\n            ),\n          )\n        }\n        return of(state)\n      }),\n      // Emit all events that are ready to be applied.\n      mergeMap((state) => of(...state.emitEvents)),\n    )\n  }\n}\n\nexport const listen = (\n  {state}: StoreContext<DocumentStoreState>,\n  documentId: string,\n): Observable<RemoteDocument> => {\n  const {sharedListener, fetchDocument} = state.get()\n\n  return sharedListener.events.pipe(\n    concatMap((e) => {\n      if (e.type === 'welcome') {\n        return fetchDocument(documentId).pipe(\n          map((document): SyncEvent => ({type: 'sync', document})),\n        )\n      }\n      if (e.type === 'mutation' && e.documentId === documentId) return of(e)\n      return EMPTY\n    }),\n    sortListenerEvents(),\n    withLatestFrom(\n      state.observable.pipe(\n        map((s) => s.documentStates[documentId]),\n        filter(Boolean),\n        distinctUntilChanged(),\n      ),\n    ),\n    map(([next, documentState]): RemoteDocument => {\n      if (next.type === 'sync') {\n        return {\n          type: 'sync',\n          documentId,\n          document: next.document,\n          revision: next.document?._rev,\n          timestamp: next.document?._updatedAt ?? new Date().toISOString(),\n        }\n      }\n\n      // TODO: from manual testing, mendoza patches seem to be applying\n      // let document\n      // if (next.effects?.apply) {\n      //   document = applyPatch(omit(documentState.remote, '_rev'), next.effects?.apply)\n      // }\n\n      const [document] = Object.values(\n        processMutations({\n          documents: {[documentId]: documentState.remote},\n          mutations: next.mutations as Mutation[],\n          transactionId: next.transactionId,\n          timestamp: next.timestamp,\n        }),\n      )\n\n      const {previousRev, transactionId, timestamp} = next\n\n      return {\n        type: 'mutation',\n        documentId,\n        document: document ?? null,\n        revision: transactionId,\n        timestamp,\n        ...(previousRev && {previousRev}),\n      }\n    }),\n  )\n}\n","// NOTE: this is a stop-gap measure until sychronous groq is out\n// eslint-disable\n// prettier-ignore\nclass e{pattern;patternRe;constructor(e){this.pattern=e,this.patternRe=function(e){const t=[];for(const r of e.split(\".\"))\"*\"===r?t.push(\"[^.]+\"):\"**\"===r?t.push(\".*\"):t.push(r.replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\"));return new RegExp(`^${t.join(\".\")}$`)}(e)}matches(e){return this.patternRe.test(e)}toJSON(){return this.pattern}}class t{type=\"stream\";generator;ticker;isDone;data;constructor(e){this.generator=e,this.ticker=null,this.isDone=!1,this.data=[]}isArray(){return!0}async get(){const e=[];for await(const t of this)e.push(await t.get());return e}async first(e=()=>!0){for await(const t of this)if(e(t))return t}async reduce(e,t){let r=t;for await(const t of this)r=await e(r,t);return r}async*[Symbol.asyncIterator](){let e=0;for(;;){for(;e<this.data.length;e++)yield this.data[e];if(this.isDone)return;await this._nextTick()}}_nextTick(){if(this.ticker)return this.ticker;let e;const t=()=>{this.ticker=new Promise((t=>{e=t}))},r=()=>{e(),t()};return t(),(async()=>{for await(const e of this.generator())this.data.push(e),r();this.isDone=!0,r()})(),this.ticker}}const r=/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;function n(e,t){let r=e.toString();for(;r.length<t;)r=`0${r}`;return r}class o{data;type;constructor(e,t){this.data=e,this.type=t}isArray(){return\"array\"===this.type}get(){return this.data}first(e=()=>!0){if(!this.isArray())throw new Error(\"`first` can only be called on array `StaticValue`s\");const t=this.get();for(const r of t){const t=f(r,\"sync\");if(e(t))return t}}reduce(e,t){if(!this.isArray())throw new Error(\"`reduce` can only be called on array `StaticValue`s\");const r=this.get();let n=t;for(const t of r){n=e(n,f(t,\"sync\"))}return n}[Symbol.asyncIterator](){if(Array.isArray(this.data))return function*(e){for(const t of e)yield f(t,\"async\")}(this.data);throw new Error(`Cannot iterate over: ${this.type}`)}}const i=new o(null,\"null\"),s=new o(!0,\"boolean\"),a=new o(!1,\"boolean\");class c{date;constructor(e){this.date=e}static parseToValue(e){const t=function(e){return r.test(e)?new Date(e):null}(e);return t?new o(new c(t),\"datetime\"):i}equals(e){return this.date.getTime()==e.date.getTime()}add(e){const t=new Date(this.date.getTime());return t.setTime(t.getTime()+1e3*e),new c(t)}difference(e){return(this.date.getTime()-e.date.getTime())/1e3}compareTo(e){return this.date.getTime()-e.date.getTime()}toString(){return function(e){const t=n(e.getUTCFullYear(),4),r=n(e.getUTCMonth()+1,2),o=n(e.getUTCDate(),2),i=n(e.getUTCHours(),2),s=n(e.getUTCMinutes(),2),a=n(e.getUTCSeconds(),2);let c=\"\";const u=e.getMilliseconds();return 0!=u&&(c=`.${n(u,3)}`),`${t}-${r}-${o}T${i}:${s}:${a}${c}Z`}(this.date)}toJSON(){return this.toString()}}function u(e){return Number.isFinite(e)?new o(e,\"number\"):i}function p(e){return new o(e,\"string\")}function l(e){return new o(e,\"datetime\")}function f(e,r){return(n=e)&&\"function\"==typeof n.next&&\"sync\"!==r?new t((async function*(){for await(const t of e)yield f(t,\"async\")})):null==e?i:new o(e,y(e));var n}function y(t){return null===t||typeof t>\"u\"?\"null\":Array.isArray(t)?\"array\":t instanceof e?\"path\":t instanceof c?\"datetime\":typeof t}const d=e=>\"object\"==typeof e&&!!e&&\"then\"in e&&\"function\"==typeof e.then;function h(e){const t=e(),r=t.next();if(r.done)return r.value;function n(e){const r=t.next(e);if(r.done)return r.value;const o=r.value;return o&&d(o)?o.then(n):n(o)}const o=r.value;return o&&d(o)?o.then(n):n(o)}function m(e,t){return\"string\"===e.type&&\"string\"===t.type||\"boolean\"===e.type&&\"boolean\"===t.type||\"null\"===e.type&&\"null\"===t.type||\"number\"===e.type&&\"number\"===t.type?e.data===t.data:\"datetime\"===e.type&&\"datetime\"===t.type&&e.data.equals(t.data)}const b=/([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g,g=/([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g,w=/(\\b\\.+|\\.+\\b)/g;function k(e){return e.replace(w,\"\").match(b)||[]}function v(e){return x(e).map((e=>t=>t.some((t=>e.test(t)))))}function x(e){return(e.replace(w,\"\").match(g)||[]).map((e=>new RegExp(`^${e.slice(0,1024).replace(/\\*/g,\".*\")}$`,\"i\")))}const _={datetime:1,number:2,string:3,boolean:4};function A(e,t){const r=y(e);if(r!==y(t))return null;switch(r){case\"number\":case\"boolean\":return e-t;case\"string\":return e<t?-1:e>t?1:0;case\"datetime\":return e.compareTo(t);default:return null}}function E(e,t){const r=y(e),n=y(t),o=_[r]||100,i=_[n]||100;if(o!==i)return o-i;let s=A(e,t);return null===s&&(s=0),s}const j={\"==\":function(e,t){return m(e,t)?s:a},\"!=\":function(e,t){return m(e,t)?a:s},\">\":function(e,t){if(\"stream\"===e.type||\"stream\"===t.type)return i;const r=A(e.data,t.data);return null===r?i:r>0?s:a},\">=\":function(e,t){if(\"stream\"===e.type||\"stream\"===t.type)return i;const r=A(e.data,t.data);return null===r?i:r>=0?s:a},\"<\":function(e,t){if(\"stream\"===e.type||\"stream\"===t.type)return i;const r=A(e.data,t.data);return null===r?i:r<0?s:a},\"<=\":function(e,t){if(\"stream\"===e.type||\"stream\"===t.type)return i;const r=A(e.data,t.data);return null===r?i:r<=0?s:a},in:function(e,t){return h((function*(){return\"path\"===t.type?\"string\"!==e.type?i:t.data.matches(e.data)?s:a:t.isArray()?(yield t.first((t=>m(e,t))))?s:a:i}))},match:function(e,t){return h((function*(){const r=yield e.get(),n=yield t.get();let o,i=[];if(Array.isArray(r)?i=r.filter((e=>\"string\"==typeof e)):\"string\"==typeof r&&(i=[r]),Array.isArray(n)?o=n.filter((e=>\"string\"==typeof e)):\"string\"==typeof n&&(o=[n]),!o?.length)return a;return function(e,t){return 0!==e.length&&0!==t.length&&t.every((t=>t(e)))}(i.flatMap(k),o.flatMap(v))?s:a}))},\"+\":function(e,r,n){return\"datetime\"===e.type&&\"number\"===r.type?l(e.data.add(r.data)):\"number\"===e.type&&\"number\"===r.type?u(e.data+r.data):\"string\"===e.type&&\"string\"===r.type?p(e.data+r.data):\"object\"===e.type&&\"object\"===r.type?f({...e.data,...r.data},n):\"array\"===e.type&&\"array\"===r.type?f(e.data.concat(r.data),n):e.isArray()&&r.isArray()?\"sync\"===n?h((function*(){const t=[...yield e.get(),...yield r.get()];return new o(t,\"array\")})):new t((async function*(){for await(const t of e)yield t;for await(const e of r)yield e})):i},\"-\":function(e,t){return\"datetime\"===e.type&&\"number\"===t.type?l(e.data.add(-t.data)):\"datetime\"===e.type&&\"datetime\"===t.type?u(e.data.difference(t.data)):\"number\"===e.type&&\"number\"===t.type?u(e.data-t.data):i},\"*\":S(((e,t)=>e*t)),\"/\":S(((e,t)=>e/t)),\"%\":S(((e,t)=>e%t)),\"**\":S(((e,t)=>Math.pow(e,t)))};function S(e){return function(t,r){if(\"number\"===t.type&&\"number\"===r.type){return u(e(t.data,r.data))}return i}}let O=class e{params;source;value;parent;context;isHidden=!1;constructor(e,t,r,n,o){this.params=e,this.source=t,this.value=r,this.context=n,this.parent=o}createNested(t){return this.isHidden?new e(this.params,this.source,t,this.context,this.parent):new e(this.params,this.source,t,this.context,this)}createHidden(e){const t=this.createNested(e);return t.isHidden=!0,t}};function I(e,t,r){return(0,$[e.type])(e,t,r)}const $={This:(e,t)=>t.value,Selector(){throw new Error(\"Selectors can not be evaluated\")},Everything:(e,t)=>t.source,Parameter:({name:e},t,r)=>f(t.params[e],r),Context({key:e},t){if(\"before\"===e||\"after\"===e)return t.context[e]||i;throw new Error(`unknown context key: ${e}`)},Parent({n:e},t){let r=t;for(let t=0;t<e;t++){if(!r.parent)return i;r=r.parent}return r.value},OpCall:({op:e,left:t,right:r},n,o)=>h((function*(){const i=j[e];if(!i)throw new Error(`Unknown operator: ${e}`);const s=yield I(t,n,o),a=yield I(r,n,o);return yield i(s,a,o)})),Select:({alternatives:e,fallback:t},r,n)=>h((function*(){for(const t of e){const e=yield I(t.condition,r,n);if(\"boolean\"===e.type&&!0===e.data)return yield I(t.value,r,n)}return t?yield I(t,r,n):i})),InRange:({base:e,left:t,right:r,isInclusive:n},o,c)=>h((function*(){const u=yield I(e,o,c),p=yield I(t,o,c),l=yield I(r,o,c),f=A(yield u.get(),yield p.get());if(null===f)return i;const y=A(yield u.get(),yield l.get());return null===y?i:n?f>=0&&y<=0?s:a:f>=0&&y<0?s:a})),Filter:({base:e,expr:r},n,s)=>h((function*(){const a=yield I(e,n,s);if(!a.isArray())return i;if(\"sync\"===s){const e=yield a.get(),t=[];for(const o of e){const e=f(o,s),i=n.createNested(e),a=yield I(r,i,s);\"boolean\"===a.type&&!0===a.data&&t.push(o)}return new o(t,\"array\")}return new t((async function*(){for await(const e of a){const t=n.createNested(e),o=await I(r,t,s);\"boolean\"===o.type&&!0===o.data&&(yield e)}}))})),Projection:({base:e,expr:t},r,n)=>h((function*(){const o=yield I(e,r,n);if(\"object\"!==o.type)return i;const s=r.createNested(o);return yield I(t,s,n)})),FuncCall:({func:e,args:t},r,n)=>e(t,r,n),PipeFuncCall:({func:e,base:t,args:r},n,o)=>h((function*(){const i=yield I(t,n,o);return yield e(i,r,n,o)})),AccessAttribute:({base:e,name:t},r,n)=>h((function*(){let o=r.value;return e&&(o=yield I(e,r,n)),\"object\"===o.type&&o.data.hasOwnProperty(t)?f(o.data[t],n):i})),AccessElement:({base:e,index:t},r,n)=>h((function*(){const o=yield I(e,r,n);if(!o.isArray())return i;const s=yield o.get();return f(s[t<0?t+s.length:t],n)})),Slice:({base:e,left:t,right:r,isInclusive:n},o,s)=>h((function*(){const a=yield I(e,o,s);if(!a.isArray())return i;const c=yield a.get();let u=t,p=r;return u<0&&(u=c.length+u),p<0&&(p=c.length+p),n&&p++,u<0&&(u=0),p<0&&(p=0),f(c.slice(u,p),s)})),Deref:({base:e},t,r)=>h((function*(){const n=yield I(e,t,r);if(!t.source.isArray()||\"object\"!==n.type)return i;const o=n.data._ref;if(\"string\"!=typeof o)return i;if(t.context.dereference){return f(yield t.context.dereference({_ref:o}),r)}return(yield t.source.first((e=>\"object\"===e.type&&o==e.data._id)))||i})),Value:({value:e},t,r)=>f(e,r),Group:({base:e},t,r)=>I(e,t,r),Object:({attributes:e},t,r)=>h((function*(){const n={};for(const o of e){const e=o.type;switch(o.type){case\"ObjectAttributeValue\":{const e=yield I(o.value,t,r);n[o.name]=yield e.get();break}case\"ObjectConditionalSplat\":{const e=yield I(o.condition,t,r);if(\"boolean\"!==e.type||!1===e.data)continue;const i=yield I(o.value,t,r);\"object\"===i.type&&Object.assign(n,i.data);break}case\"ObjectSplat\":{const e=yield I(o.value,t,r);\"object\"===e.type&&Object.assign(n,e.data);break}default:throw new Error(`Unknown node type: ${e}`)}}return f(n,r)})),Array:({elements:e},r,n)=>h((function*(){if(\"sync\"===n){const t=[];for(const o of e){const e=yield I(o.value,r,n);if(o.isSplat){if(e.isArray()){const r=yield e.get();t.push(...r)}}else t.push(yield e.get())}return new o(t,\"array\")}return new t((async function*(){for(const t of e){const e=await I(t.value,r,n);if(t.isSplat){if(e.isArray())for await(const t of e)yield t}else yield e}}))})),Tuple(){throw new Error(\"tuples can not be evaluated\")},Or:({left:e,right:t},r,n)=>h((function*(){const o=yield I(e,r,n),c=yield I(t,r,n);return\"boolean\"===o.type&&!0===o.data||\"boolean\"===c.type&&!0===c.data?s:\"boolean\"!==o.type||\"boolean\"!==c.type?i:a})),And:({left:e,right:t},r,n)=>h((function*(){const o=yield I(e,r,n),c=yield I(t,r,n);return\"boolean\"===o.type&&!1===o.data||\"boolean\"===c.type&&!1===c.data?a:\"boolean\"!==o.type||\"boolean\"!==c.type?i:s})),Not:({base:e},t,r)=>h((function*(){const n=yield I(e,t,r);return\"boolean\"!==n.type?i:n.data?a:s})),Neg:({base:e},t,r)=>h((function*(){const n=yield I(e,t,r);return\"number\"!==n.type?i:u(-n.data)})),Pos:({base:e},t,r)=>h((function*(){const n=yield I(e,t,r);return\"number\"!==n.type?i:u(n.data)})),Asc:()=>i,Desc:()=>i,ArrayCoerce:({base:e},t,r)=>h((function*(){const n=yield I(e,t,r);return n.isArray()?n:i})),Map:({base:e,expr:r},n,s)=>h((function*(){const a=yield I(e,n,s);if(!a.isArray())return i;if(\"sync\"===s){const e=yield a.get(),t=[];for(const o of e){const e=f(o,\"sync\"),i=n.createHidden(e),a=yield I(r,i,s);t.push(yield a.get())}return new o(t,\"array\")}return new t((async function*(){for await(const e of a){const t=n.createHidden(e);yield await I(r,t,s)}}))})),FlatMap:({base:e,expr:r},n,s)=>h((function*(){const a=yield I(e,n,s);if(!a.isArray())return i;if(\"sync\"===s){const e=yield a.get(),t=[];for(const o of e){const e=f(o,\"sync\"),i=n.createHidden(e),a=yield I(r,i,s);if(a.isArray()){const e=yield a.get();t.push(...e)}else{const e=yield a.get();t.push(e)}}return new o(t,\"array\")}return new t((async function*(){for await(const e of a){const t=n.createHidden(e),o=await I(r,t,s);if(o.isArray())for await(const e of o)yield e;else yield o}}))}))};function C(e,t={}){const r=f(t.root,\"sync\"),n=f(t.dataset,\"sync\"),o={...t.params},i=new O(o,n,r,function(e={},t){return{timestamp:e.timestamp||new Date,identity:void 0===e.identity?\"me\":e.identity,sanity:e.sanity,after:e.after?f(e.after,t):null,before:e.before?f(e.before,t):null,dereference:e.dereference}}(t,\"sync\"),null),s=I(e,i,\"sync\");if(d(s))throw new Error(\"Unexpected promise when evaluating. This expression may not support evaluateSync.\");return s}function M(e){switch(e.type){case\"Group\":return M(e.base);case\"Value\":case\"Parameter\":return!0;case\"Pos\":case\"Neg\":return M(e.base);case\"OpCall\":switch(e.op){case\"+\":case\"-\":case\"*\":case\"/\":case\"%\":case\"**\":return M(e.left)&&M(e.right);default:return!1}default:return!1}}const T=new O({},i,i,{timestamp:new Date(0),identity:\"me\",before:null,after:null},null);function P(e){return M(e)?function(e){const t=I(e,T,\"sync\");if(d(t))throw new Error(\"BUG: constant evaluate should never return a promise\");return t}(e):null}function N(e,t){return h((function*(){if(\"object\"===e.type)return V(e.data);if(e.isArray()){const r=yield U(e,t);if(r.length>0)return r.join(\"\\n\\n\")}return null}))}function U(e,t){return h((function*(){const r=[],n=yield e.get();for(const e of n){const n=f(e,t);if(\"object\"===n.type){const e=V(n.data);null!==e&&r.push(e)}else if(n.isArray()){const e=yield U(n,t);r.push(...e)}}return r}))}function V(e){if(\"string\"!=typeof e._type)return null;const t=e.children;if(!Array.isArray(t))return null;let r=\"\";for(const e of t)e&&\"object\"==typeof e&&\"string\"==typeof e._type&&\"span\"===e._type&&\"string\"==typeof e.text&&(r+=e.text);return r}const D=1.2;function F(e,t,r){return h((function*(){if(\"OpCall\"===e.type&&\"match\"===e.op){return function(e,t){return h((function*(){const r=yield e.get(),n=yield t.get();let o,i=[];if(Array.isArray(r)?i=r.filter((e=>\"string\"==typeof e)):\"string\"==typeof r&&(i=[r]),Array.isArray(n)?o=n.filter((e=>\"string\"==typeof e)):\"string\"==typeof n&&(o=[n]),!o?.length)return 0;const s=i.flatMap(k),a=o.flatMap(x);if(0===s.length||0===a.length)return 0;let c=0;for(const e of a){const t=s.reduce(((t,r)=>t+(e.test(r)?1:0)),0);c+=2.2*t/(t+D)}return c}))}(yield I(e.left,t,r),yield I(e.right,t,r))}if(\"FuncCall\"===e.type&&\"boost\"===e.name){const n=yield F(e.args[0],t,r),o=yield I(e.args[1],t,r);return\"number\"===o.type&&n>0?n+o.data:0}switch(e.type){case\"Or\":return(yield F(e.left,t,r))+(yield F(e.right,t,r));case\"And\":{const n=yield F(e.left,t,r),o=yield F(e.right,t,r);return 0===n||0===o?0:n+o}default:{const n=yield I(e,t,r);return\"boolean\"===n.type&&!0===n.data?1:0}}}))}function R(e,t){switch(y(e)){case\"array\":for(const r of e)if(R(r,t))return!0;break;case\"object\":if(e._ref)return t.has(e._ref);for(const r of Object.values(e))if(R(r,t))return!0}return!1}const q={anywhere:function(){throw new Error(\"not implemented\")}};q.anywhere.arity=1,q.coalesce=function(e,t,r){return h((function*(){for(const n of e){const e=yield I(n,t,r);if(\"null\"!==e.type)return e}return i}))},q.count=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray())return i;return u(yield n.reduce((e=>e+1),0))}))},q.count.arity=1,q.dateTime=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);return\"datetime\"===n.type?n:\"string\"!==n.type?i:c.parseToValue(n.data)}))},q.dateTime.arity=1,q.defined=function(e,t,r){return h((function*(){return\"null\"===(yield I(e[0],t,r)).type?a:s}))},q.defined.arity=1,q.identity=function(e,t){return p(t.context.identity)},q.identity.arity=0,q.length=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(\"string\"===n.type)return u(function(e){let t=0;for(let r=0;r<e.length;r++){const n=e.charCodeAt(r);n>=55296&&n<=56319||t++}return t}(n.data));if(n.isArray()){return u(yield n.reduce((e=>e+1),0))}return i}))},q.length.arity=1,q.path=function(t,r,n){return h((function*(){const s=yield I(t[0],r,n);return\"string\"!==s.type?i:(a=new e(s.data),new o(a,\"path\"));var a}))},q.path.arity=1,q.string=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);switch(n.type){case\"number\":case\"string\":case\"boolean\":case\"datetime\":return p(`${n.data}`);default:return i}}))},q.string.arity=1,q.references=function(e,t,r){return h((function*(){const n=new Set;for(const o of e){const e=yield I(o,t,r);if(\"string\"===e.type)n.add(e.data);else if(e.isArray()){const t=yield e.get();for(const e of t)\"string\"==typeof e&&n.add(e)}}if(0===n.size)return a;return R(yield t.value.get(),n)?s:a}))},q.references.arity=e=>e>=1,q.round=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(\"number\"!==n.type)return i;const o=n.data;let s=0;if(2===e.length){const n=yield I(e[1],t,r);if(\"number\"!==n.type||n.data<0||!Number.isInteger(n.data))return i;s=n.data}return u(0===s?o<0?-Math.round(-o):Math.round(o):Number(o.toFixed(s)))}))},q.round.arity=e=>e>=1&&e<=2,q.now=function(e,t){return p(t.context.timestamp.toISOString())},q.now.arity=0,q.boost=function(){throw new Error(\"unexpected boost call\")},q.boost.arity=2;const G={lower:function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);return\"string\"!==n.type?i:p(n.data.toLowerCase())}))}};G.lower.arity=1,G.upper=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);return\"string\"!==n.type?i:p(n.data.toUpperCase())}))},G.upper.arity=1,G.split=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(\"string\"!==n.type)return i;const o=yield I(e[1],t,r);return\"string\"!==o.type?i:0===n.data.length?f([],r):0===o.data.length?f(Array.from(n.data),r):f(n.data.split(o.data),r)}))},G.split.arity=2,q.lower=G.lower,q.upper=G.upper,G.startsWith=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(\"string\"!==n.type)return i;const o=yield I(e[1],t,r);return\"string\"!==o.type?i:n.data.startsWith(o.data)?s:a}))},G.startsWith.arity=2;const H={join:function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray())return i;const o=yield I(e[1],t,r);if(\"string\"!==o.type)return i;let s=\"\",a=!1;const c=yield n.get();for(const e of c){const t=f(e,r);switch(a&&(s+=o.data),t.type){case\"number\":case\"string\":case\"boolean\":case\"datetime\":s+=`${t.data}`;break;default:return i}a=!0}return f(s,r)}))}};H.join.arity=2,H.compact=function(e,r,n){return h((function*(){const o=yield I(e[0],r,n);return o.isArray()?new t((async function*(){for await(const e of o)\"null\"!==e.type&&(yield e)})):i}))},H.compact.arity=1,H.unique=function(e,r,n){return h((function*(){const s=yield I(e[0],r,n);if(!s.isArray())return i;if(\"sync\"===n){const e=yield s.get(),t=new Set,r=[];for(const n of e){const e=f(n,\"sync\");switch(e.type){case\"number\":case\"string\":case\"boolean\":case\"datetime\":t.has(n)||(t.add(n),r.push(e));break;default:r.push(e)}}return new o(r,\"array\")}return new t((async function*(){const e=new Set;for await(const t of s)switch(t.type){case\"number\":case\"string\":case\"boolean\":case\"datetime\":e.has(t.data)||(e.add(t.data),yield t);break;default:yield t}}))}))},H.unique.arity=1,H.intersects=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray())return i;const o=yield I(e[1],t,r);return o.isArray()?(yield n.first((e=>!!o.first((t=>m(e,t))))))?s:a:i}))},H.intersects.arity=2;const B={text:function(e,t,r){return h((function*(){const n=yield I(e[0],t,r),o=yield N(n,r);return null===o?i:p(o)}))}};B.text.arity=1;const W={projectId:function(e,t){return t.context.sanity?p(t.context.sanity.projectId):i},dataset:function(e,t){return t.context.sanity?p(t.context.sanity.dataset):i},versionsOf:function(e,t,r){return h((function*(){if(!t.source.isArray())return i;const n=yield I(e[0],t,r);if(\"string\"!==n.type)return i;const o=n.data;return f(yield t.source.reduce(((e,t)=>{if(\"object\"===y(t)){const r=t.get();r&&\"_id\"in r&&2===r._id.split(\".\").length&&r._id.endsWith(`.${o}`)&&\"_version\"in r&&\"object\"==typeof r._version&&e.push(r._id)}return e}),[]),r)}))}};W.versionsOf.arity=1,W.partOfRelease=function(e,t,r){return h((function*(){if(!t.source.isArray())return i;const n=yield I(e[0],t,r);if(\"string\"!==n.type)return i;const o=n.data;return f(yield t.source.reduce(((e,t)=>{if(\"object\"===y(t)){const r=t.get();r&&\"_id\"in r&&2===r._id.split(\".\").length&&r._id.startsWith(`${o}.`)&&\"_version\"in r&&\"object\"==typeof r._version&&e.push(r._id)}return e}),[]),r)}))},W.partOfRelease.arity=1;const Z={order:function(e,t,r,n){return h((function*(){if(!e.isArray())return i;const o=[],s=[];let a=0;for(let e of t){let t=\"asc\";\"Desc\"===e.type?(t=\"desc\",e=e.base):\"Asc\"===e.type&&(e=e.base),o.push(e),s.push(t),a++}const c=[];let u=0;const p=yield e.get();for(const e of p){const t=f(e,n),i=r.createNested(t),s=[yield t.get(),u];for(let e=0;e<a;e++){const t=yield I(o[e],i,n);s.push(yield t.get())}c.push(s),u++}return c.sort(((e,t)=>{for(let r=0;r<a;r++){let n=E(e[r+2],t[r+2]);if(\"desc\"===s[r]&&(n=-n),0!==n)return n}return e[1]-t[1]})),f(c.map((e=>e[0])),n)}))}};Z.order.arity=e=>e>=1,Z.score=function(e,t,r,n){return h((function*(){if(!e.isArray())return i;const o=[],s=[],a=yield e.get();for(const e of a){const i=f(e,n);if(\"object\"!==i.type){o.push(yield i.get());continue}const a=r.createNested(i);let c=\"number\"==typeof i.data._score?i.data._score:0;for(const e of t)c+=(yield F(e,a,n));const u=Object.assign({},i.data,{_score:c});s.push(u)}return s.sort(((e,t)=>t._score-e._score)),f(s,n)}))},Z.score.arity=e=>e>=1;const z={operation:function(e,t){const r=null!==t.context.before,n=null!==t.context.after;return r&&n?p(\"update\"):n?p(\"create\"):r?p(\"delete\"):i},changedAny:()=>{throw new Error(\"not implemented\")}};z.changedAny.arity=1,z.changedAny.mode=\"delta\",z.changedOnly=()=>{throw new Error(\"not implemented\")},z.changedOnly.arity=1,z.changedOnly.mode=\"delta\";const J={changedAny:()=>{throw new Error(\"not implemented\")}};J.changedAny.arity=3,J.changedOnly=()=>{throw new Error(\"not implemented\")},J.changedOnly.arity=3;const Q={min:function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray()||(yield n.first((e=>\"null\"!==e.type&&\"number\"!==e.type))))return i;const o=yield n.get();let s;for(const e of o)\"number\"==typeof e&&(void 0===s||e<s)&&(s=e);return f(s,r)}))}};Q.min.arity=1,Q.max=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray()||(yield n.first((e=>\"null\"!==e.type&&\"number\"!==e.type))))return i;const o=yield n.get();let s;for(const e of o)\"number\"==typeof e&&(void 0===s||e>s)&&(s=e);return f(s,r)}))},Q.max.arity=1,Q.sum=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray()||(yield n.first((e=>\"null\"!==e.type&&\"number\"!==e.type))))return i;return f(yield n.reduce(((e,t)=>\"number\"!==t.type?e:e+t.data),0),r)}))},Q.sum.arity=1,Q.avg=function(e,t,r){return h((function*(){const n=yield I(e[0],t,r);if(!n.isArray()||(yield n.first((e=>\"null\"!==e.type&&\"number\"!==e.type))))return i;const o=yield n.reduce(((e,t)=>\"number\"!==t.type?e:e+1),0),s=yield n.reduce(((e,t)=>\"number\"!==t.type?e:e+t.data),0);return 0===o?i:f(s/o,r)}))},Q.avg.arity=1;const L={now:function(e,t){return l(new c(t.context.timestamp))}};L.now.arity=0;const Y={global:q,string:G,array:H,pt:B,delta:z,diff:J,sanity:W,math:Q,dateTime:L};class K{string;marks;index;parseOptions;allowBoost=!1;constructor(e,t,r){this.string=e,this.marks=t,this.index=0,this.parseOptions=r}hasMark(e=0){return this.index+e<this.marks.length}getMark(e=0){return this.marks[this.index+e]}shift(){this.index+=1}process(e){const t=this.marks[this.index];this.shift();const r=e[t.name];if(!r)throw new Error(`Unknown handler: ${t.name}`);return r.call(e,this,t)}processString(){return this.shift(),this.processStringEnd()}processStringEnd(){const e=this.marks[this.index-1],t=this.marks[this.index];return this.shift(),this.string.slice(e.position,t.position)}slice(e){const t=this.marks[this.index].position;return this.string.slice(t,t+e)}}const X=/^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/,ee=/^\\d+/,te=/^[a-zA-Z_][a-zA-Z_0-9]*/;function re(e,t,r){let n,o=t;switch(e[t]){case\"+\":{let r=re(e,se(e,t+1),10);if(\"error\"===r.type)return r;n=[{name:\"pos\",position:o}].concat(r.marks),t=r.position;break}case\"-\":{let r=re(e,se(e,t+1),8);if(\"error\"===r.type)return r;n=[{name:\"neg\",position:o}].concat(r.marks),t=r.position;break}case\"(\":{let r=re(e,se(e,t+1),0);if(\"error\"===r.type)return r;switch(e[t=se(e,r.position)]){case\",\":for(n=[{name:\"tuple\",position:o}].concat(r.marks),t=se(e,t+1);;){if(r=re(e,t,0),\"error\"===r.type)return r;if(\",\"!==e[t=se(e,r.position)])break;t=se(e,t+1)}if(\")\"!==e[t])return{type:\"error\",position:t};t++,n.push({name:\"tuple_end\",position:t});break;case\")\":t++,n=[{name:\"group\",position:o}].concat(r.marks);break;default:return{type:\"error\",position:t}}break}case\"!\":{let r=re(e,se(e,t+1),10);if(\"error\"===r.type)return r;n=[{name:\"not\",position:o}].concat(r.marks),t=r.position;break}case\"{\":{let r=ie(e,t);if(\"error\"===r.type)return r;n=r.marks,t=r.position;break}case\"[\":if(n=[{name:\"array\",position:t}],\"]\"!==e[t=se(e,t+1)])for(;;){\"...\"===e.slice(t,t+3)&&(n.push({name:\"array_splat\",position:t}),t=se(e,t+3));let r=re(e,t,0);if(\"error\"===r.type)return r;if(n=n.concat(r.marks),\",\"!==e[t=se(e,t=r.position)]||\"]\"===e[t=se(e,t+1)])break}if(\"]\"!==e[t])return{type:\"error\",position:t};t++,n.push({name:\"array_end\",position:t});break;case\"'\":case'\"':{let r=function(e,t){let r=e[t];t+=1;const n=[{name:\"str\",position:t}];e:for(;;t++){if(t>e.length)return{type:\"error\",position:t};switch(e[t]){case r:n.push({name:\"str_end\",position:t}),t++;break e;case\"\\\\\":n.push({name:\"str_pause\",position:t}),\"u\"===e[t+1]?\"{\"===e[t+2]?(n.push({name:\"unicode_hex\",position:t+3}),t=e.indexOf(\"}\",t+3),n.push({name:\"unicode_hex_end\",position:t})):(n.push({name:\"unicode_hex\",position:t+2}),n.push({name:\"unicode_hex_end\",position:t+6}),t+=5):(n.push({name:\"single_escape\",position:t+1}),t+=1),n.push({name:\"str_start\",position:t+1})}}return{type:\"success\",marks:n,position:t}}(e,t);if(\"error\"===r.type)return r;n=r.marks,t=r.position;break}case\"^\":for(t++,n=[];\".\"===e[t]&&\"^\"===e[t+1];)n.push({name:\"dblparent\",position:o}),t+=2;n.push({name:\"parent\",position:o});break;case\"@\":n=[{name:\"this\",position:o}],t++;break;case\"*\":n=[{name:\"everything\",position:o}],t++;break;case\"$\":{let r=ae(e,t+1,te);r&&(n=[{name:\"param\",position:o},{name:\"ident\",position:o+1},{name:\"ident_end\",position:t+=1+r}]);break}default:{let r=ae(e,t,ee);if(r){let i=\"integer\";if(\".\"===e[t+=r]){let r=ae(e,t+1,ee);r&&(i=\"float\",t+=1+r)}if(\"e\"===e[t]||\"E\"===e[t]){i=\"sci\",(\"+\"===e[++t]||\"-\"===e[t])&&t++;let r=ae(e,t,ee);if(!r)return{type:\"error\",position:t};t+=r}n=[{name:i,position:o},{name:i+\"_end\",position:t}];break}let i=ae(e,t,te);if(i){switch(e[t+=i]){case\":\":case\"(\":{let r=oe(e,o,t);if(\"error\"===r.type)return r;n=r.marks,t=r.position;break}default:n=[{name:\"this_attr\",position:o},{name:\"ident\",position:o},{name:\"ident_end\",position:t}]}break}}}if(!n)return{type:\"error\",position:t};let i,s=12;e:for(;;){let a=se(e,t);if(a===e.length){t=a;break}if(i=ne(e,a),\"success\"!==i.type)switch(e[a]){case\"=\":switch(e[a+1]){case\">\":{if(r>1||s<=1)break e;let i=re(e,se(e,a+2),1);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"pair\",position:o}),t=i.position,s=1;break}case\"=\":{if(r>4||s<=4)break e;let i=re(e,se(e,a+2),5);if(\"error\"===i.type)return i;n.unshift({name:\"comp\",position:o}),n.push({name:\"op\",position:a},{name:\"op_end\",position:a+2}),n=n.concat(i.marks),t=i.position,s=4;break}default:break e}break;case\"+\":{if(r>6||s<6)break e;let i=re(e,se(e,a+1),7);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"add\",position:o}),t=i.position,s=6;break}case\"-\":{if(r>6||s<6)break e;let i=re(e,se(e,a+1),7);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"sub\",position:o}),t=i.position,s=6;break}case\"*\":{if(\"*\"===e[a+1]){if(r>8||s<=8)break e;let i=re(e,se(e,a+2),8);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"pow\",position:o}),t=i.position,s=8;break}if(r>7||s<7)break e;let i=re(e,se(e,a+1),8);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"mul\",position:o}),t=i.position,s=7;break}case\"/\":{if(r>7||s<7)break e;let i=re(e,se(e,a+1),8);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"div\",position:o}),t=i.position,s=7;break}case\"%\":{if(r>7||s<7)break e;let i=re(e,se(e,a+1),8);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"mod\",position:o}),t=i.position,s=7;break}case\"<\":case\">\":{if(r>4||s<=4)break e;let i=a+1;\"=\"===e[i]&&i++;let c=re(e,se(e,i),5);if(\"error\"===c.type)return c;n.unshift({name:\"comp\",position:o}),n.push({name:\"op\",position:a},{name:\"op_end\",position:i}),n=n.concat(c.marks),t=c.position,s=4;break}case\"|\":if(\"|\"===e[a+1]){if(r>2||s<2)break e;let i=re(e,se(e,a+2),3);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"or\",position:o}),t=i.position,s=2}else{if(r>11||s<11)break e;let i=se(e,a+1),c=ae(e,i,te);if(!c)return{type:\"error\",position:i};if(\"(\"===e[t=i+c]||\":\"===e[t]){let r=oe(e,i,t);if(\"error\"===r.type)return r;n=n.concat(r.marks),n.unshift({name:\"pipecall\",position:o}),t=r.position,s=11}}break;case\"&\":{if(\"&\"!=e[a+1]||r>3||s<3)break e;let i=re(e,se(e,a+2),4);if(\"error\"===i.type)return i;n=n.concat(i.marks),n.unshift({name:\"and\",position:o}),t=i.position,s=3;break}case\"!\":{if(\"=\"!==e[a+1]||r>4||s<=4)break e;let i=re(e,se(e,a+2),5);if(\"error\"===i.type)return i;n.unshift({name:\"comp\",position:o}),n.push({name:\"op\",position:a},{name:\"op_end\",position:a+2}),n=n.concat(i.marks),t=i.position,s=4;break}case\"d\":if(\"desc\"!==e.slice(a,a+4)||r>4||s<4)break e;n.unshift({name:\"desc\",position:o}),t=a+4,s=4;break;case\"a\":if(\"asc\"!==e.slice(a,a+3)||r>4||s<4)break e;n.unshift({name:\"asc\",position:o}),t=a+3,s=4;break;default:switch(ce(e,a,te)){case\"in\":{if(r>4||s<=4)break e;let i=!1;\"(\"===e[t=se(e,a+2)]&&(i=!0,t=se(e,t+1));let c=t,u=re(e,t,5);if(\"error\"===u.type)return u;if(\".\"===e[t=se(e,u.position)]&&\".\"===e[t+1]){let r=\"inc_range\";\".\"===e[t+2]?(r=\"exc_range\",t=se(e,t+3)):t=se(e,t+2);let i=re(e,t,5);if(\"error\"===i.type)return i;n.unshift({name:\"in_range\",position:o}),n=n.concat({name:r,position:c},u.marks,i.marks),t=i.position}else n.unshift({name:\"comp\",position:o}),n.push({name:\"op\",position:a},{name:\"op_end\",position:a+2}),n=n.concat(u.marks);if(i){if(\")\"!==e[t=se(e,t)])return{type:\"error\",position:t};t++}s=4;break}case\"match\":{if(r>4||s<=4)break e;let i=re(e,se(e,a+5),5);if(\"error\"===i.type)return i;n.unshift({name:\"comp\",position:o}),n.push({name:\"op\",position:a},{name:\"op_end\",position:a+5}),n=n.concat(i.marks),t=i.position,s=4;break}default:break e}}else{for(n.unshift({name:\"traverse\",position:o});\"success\"===i.type;)n=n.concat(i.marks),i=ne(e,se(e,t=i.position));n.push({name:\"traversal_end\",position:t})}}return{type:\"success\",marks:n,position:t,failPosition:\"error\"===i?.type&&i.position}}function ne(e,t){let r=t;switch(e[t]){case\".\":{let n=t=se(e,t+1),o=ae(e,t,te);return o?{type:\"success\",marks:[{name:\"attr_access\",position:r},{name:\"ident\",position:n},{name:\"ident_end\",position:t+=o}],position:t}:{type:\"error\",position:t}}case\"-\":if(\">\"!==e[t+1])return{type:\"error\",position:t};let n=[{name:\"deref\",position:r}],o=se(e,t+=2),i=ae(e,o,te);return i&&(t=o+i,n.push({name:\"deref_attr\",position:o},{name:\"ident\",position:o},{name:\"ident_end\",position:t})),{type:\"success\",marks:n,position:t};case\"[\":{if(\"]\"===e[t=se(e,t+1)])return{type:\"success\",marks:[{name:\"array_postfix\",position:r}],position:t+1};let n=t,o=re(e,t,0);if(\"error\"===o.type)return o;if(\".\"===e[t=se(e,o.position)]&&\".\"===e[t+1]){let i=\"inc_range\";\".\"===e[t+2]?(i=\"exc_range\",t+=3):t+=2;let s=re(e,t=se(e,t),0);return\"error\"===s.type?s:\"]\"!==e[t=se(e,s.position)]?{type:\"error\",position:t}:{type:\"success\",marks:[{name:\"slice\",position:r},{name:i,position:n}].concat(o.marks,s.marks),position:t+1}}return\"]\"!==e[t]?{type:\"error\",position:t}:{type:\"success\",marks:[{name:\"square_bracket\",position:r}].concat(o.marks),position:t+1}}case\"|\":if(\"{\"===e[t=se(e,t+1)]){let n=ie(e,t);return\"error\"===n.type||n.marks.unshift({name:\"projection\",position:r}),n}break;case\"{\":{let n=ie(e,t);return\"error\"===n.type||n.marks.unshift({name:\"projection\",position:r}),n}}return{type:\"error\",position:t}}function oe(e,t,r){let n=[];if(n.push({name:\"func_call\",position:t}),\":\"===e[r]&&\":\"===e[r+1]){n.push({name:\"namespace\",position:t}),n.push({name:\"ident\",position:t},{name:\"ident_end\",position:r});let o=ae(e,r=se(e,r+2),te);if(!o)return{type:\"error\",position:r};if(n.push({name:\"ident\",position:r},{name:\"ident_end\",position:r+o}),\"(\"!==e[r=se(e,r+o)])return{type:\"error\",position:r};r=se(e,++r)}else n.push({name:\"ident\",position:t},{name:\"ident_end\",position:r}),r=se(e,r+1);let o=r;if(\")\"!==e[r])for(;;){let t=re(e,r,0);if(\"error\"===t.type)return t;if(n=n.concat(t.marks),o=t.position,\",\"!==e[r=se(e,t.position)]||\")\"===e[r=se(e,r+1)])break}return\")\"!==e[r]?{type:\"error\",position:r}:(n.push({name:\"func_args_end\",position:o}),{type:\"success\",marks:n,position:r+1})}function ie(e,t){let r=[{name:\"object\",position:t}];for(t=se(e,t+1);\"}\"!==e[t];){let n=t;if(\"...\"===e.slice(t,t+3))if(\"}\"!==e[t=se(e,t+3)]&&\",\"!==e[t]){let o=re(e,t,0);if(\"error\"===o.type)return o;r.push({name:\"object_splat\",position:n}),r=r.concat(o.marks),t=o.position}else r.push({name:\"object_splat_this\",position:n});else{let o=re(e,t,0);if(\"error\"===o.type)return o;let i=se(e,o.position);if(\"str\"===o.marks[0].name&&\":\"===e[i]){let s=re(e,se(e,i+1),0);if(\"error\"===s.type)return s;r.push({name:\"object_pair\",position:n}),r=r.concat(o.marks,s.marks),t=s.position}else r=r.concat({name:\"object_expr\",position:t},o.marks),t=o.position}if(\",\"!==e[t=se(e,t)])break;t=se(e,t+1)}return\"}\"!==e[t]?{type:\"error\",position:t}:(t++,r.push({name:\"object_end\",position:t}),{type:\"success\",marks:r,position:t})}function se(e,t){return t+ae(e,t,X)}function ae(e,t,r){let n=r.exec(e.slice(t));return n?n[0].length:0}function ce(e,t,r){let n=r.exec(e.slice(t));return n?n[0]:null}function ue(e,t){return r=>t(e(r))}function pe(e){return t=>({type:\"Map\",base:t,expr:e({type:\"This\"})})}function le(e,t){if(!t)return{type:\"a-a\",build:e};switch(t.type){case\"a-a\":return{type:\"a-a\",build:ue(e,t.build)};case\"a-b\":return{type:\"a-b\",build:ue(e,t.build)};case\"b-b\":return{type:\"a-a\",build:ue(e,pe(t.build))};case\"b-a\":return{type:\"a-a\",build:ue(e,(r=t.build,e=>({type:\"FlatMap\",base:e,expr:r({type:\"This\"})})))};default:throw new Error(`unknown type: ${t.type}`)}var r}function fe(e,t){if(!t)return{type:\"b-b\",build:e};switch(t.type){case\"a-a\":case\"b-a\":return{type:\"b-a\",build:ue(e,t.build)};case\"a-b\":case\"b-b\":return{type:\"b-b\",build:ue(e,t.build)};default:throw new Error(`unknown type: ${t.type}`)}}const ye={\"'\":\"'\",'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"};function de(e){const t=parseInt(e,16);return String.fromCharCode(t)}class he extends Error{name=\"GroqQueryError\"}const me={group:e=>({type:\"Group\",base:e.process(me)}),everything:()=>({type:\"Everything\"}),this:()=>({type:\"This\"}),parent:()=>({type:\"Parent\",n:1}),dblparent:e=>({type:\"Parent\",n:e.process(me).n+1}),traverse(e){const t=e.process(me),r=[];for(;\"traversal_end\"!==e.getMark().name;)r.push(e.process(ge));e.shift();let n=null;for(let e=r.length-1;e>=0;e--)n=r[e](n);if((\"Everything\"===t.type||\"Array\"===t.type||\"PipeFuncCall\"===t.type)&&(n=le((e=>e),n)),null===n)throw new Error(\"BUG: unexpected empty traversal\");return n.build(t)},this_attr(e){const t=e.processString();return\"null\"===t?{type:\"Value\",value:null}:\"true\"===t?{type:\"Value\",value:!0}:\"false\"===t?{type:\"Value\",value:!1}:{type:\"AccessAttribute\",name:t}},neg:e=>({type:\"Neg\",base:e.process(me)}),pos:e=>({type:\"Pos\",base:e.process(me)}),add:e=>({type:\"OpCall\",op:\"+\",left:e.process(me),right:e.process(me)}),sub:e=>({type:\"OpCall\",op:\"-\",left:e.process(me),right:e.process(me)}),mul:e=>({type:\"OpCall\",op:\"*\",left:e.process(me),right:e.process(me)}),div:e=>({type:\"OpCall\",op:\"/\",left:e.process(me),right:e.process(me)}),mod:e=>({type:\"OpCall\",op:\"%\",left:e.process(me),right:e.process(me)}),pow:e=>({type:\"OpCall\",op:\"**\",left:e.process(me),right:e.process(me)}),comp(e){const t=e.process(me);return{type:\"OpCall\",op:e.processString(),left:t,right:e.process(me)}},in_range(e){const t=e.process(me),r=\"inc_range\"===e.getMark().name;e.shift();return{type:\"InRange\",base:t,left:e.process(me),right:e.process(me),isInclusive:r}},str(e){let t=\"\";e:for(;e.hasMark();){const r=e.getMark();switch(r.name){case\"str_end\":t+=e.processStringEnd();break e;case\"str_pause\":t+=e.processStringEnd();break;case\"str_start\":e.shift();break;case\"single_escape\":{const r=e.slice(1);e.shift(),t+=ye[r];break}case\"unicode_hex\":e.shift(),t+=de(e.processStringEnd());break;default:throw new Error(`unexpected mark: ${r.name}`)}}return{type:\"Value\",value:t}},integer(e){const t=e.processStringEnd();return{type:\"Value\",value:Number(t)}},float(e){const t=e.processStringEnd();return{type:\"Value\",value:Number(t)}},sci(e){const t=e.processStringEnd();return{type:\"Value\",value:Number(t)}},object(e){const t=[];for(;\"object_end\"!==e.getMark().name;)t.push(e.process(be));return e.shift(),{type:\"Object\",attributes:t}},array(e){const t=[];for(;\"array_end\"!==e.getMark().name;){let r=!1;\"array_splat\"===e.getMark().name&&(r=!0,e.shift());const n=e.process(me);t.push({type:\"ArrayElement\",value:n,isSplat:r})}return e.shift(),{type:\"Array\",elements:t}},tuple(e){const t=[];for(;\"tuple_end\"!==e.getMark().name;)t.push(e.process(me));return e.shift(),{type:\"Tuple\",members:t}},func_call(e){let t=\"global\";\"namespace\"===e.getMark().name&&(e.shift(),t=e.processString());const r=e.processString();if(\"global\"===t&&\"select\"===r){const t={type:\"Select\",alternatives:[]};for(;\"func_args_end\"!==e.getMark().name;)if(\"pair\"===e.getMark().name){if(t.fallback)throw new he(\"unexpected argument to select()\");e.shift();const r=e.process(me),n=e.process(me);t.alternatives.push({type:\"SelectAlternative\",condition:r,value:n})}else{if(t.fallback)throw new he(\"unexpected argument to select()\");const r=e.process(me);t.fallback=r}return e.shift(),t}const n=[];for(;\"func_args_end\"!==e.getMark().name;)xe(t,r,n.length)?(e.process(we),n.push({type:\"Selector\"})):n.push(e.process(me));if(e.shift(),\"global\"===t&&(\"before\"===r||\"after\"===r)&&\"delta\"===e.parseOptions.mode)return{type:\"Context\",key:r};if(\"global\"===t&&\"boost\"===r&&!e.allowBoost)throw new he(\"unexpected boost\");const o=Y[t];if(!o)throw new he(`Undefined namespace: ${t}`);const i=o[r];if(!i)throw new he(`Undefined function: ${r}`);if(void 0!==i.arity&&ve(r,i.arity,n.length),void 0!==i.mode&&i.mode!==e.parseOptions.mode)throw new he(`Undefined function: ${r}`);return{type:\"FuncCall\",func:i,namespace:t,name:r,args:n}},pipecall(e){const t=e.process(me);e.shift();let r=\"global\";if(\"namespace\"===e.getMark().name&&(e.shift(),r=e.processString()),\"global\"!==r)throw new he(`Undefined namespace: ${r}`);const n=e.processString(),o=[],i=e.allowBoost;for(\"score\"===n&&(e.allowBoost=!0);;){const t=e.getMark().name;if(\"func_args_end\"===t)break;if(\"order\"===n){if(\"asc\"===t){e.shift(),o.push({type:\"Asc\",base:e.process(me)});continue}if(\"desc\"===t){e.shift(),o.push({type:\"Desc\",base:e.process(me)});continue}}o.push(e.process(me))}e.shift(),e.allowBoost=i;const s=Z[n];if(!s)throw new he(`Undefined pipe function: ${n}`);return s.arity&&ve(n,s.arity,o.length),{type:\"PipeFuncCall\",func:s,base:t,name:n,args:o}},pair(){throw new he(\"unexpected =>\")},and:e=>({type:\"And\",left:e.process(me),right:e.process(me)}),or:e=>({type:\"Or\",left:e.process(me),right:e.process(me)}),not:e=>({type:\"Not\",base:e.process(me)}),asc(){throw new he(\"unexpected asc\")},desc(){throw new he(\"unexpected desc\")},param(e){const t=e.processString();return e.parseOptions.params&&e.parseOptions.params.hasOwnProperty(t)?{type:\"Value\",value:e.parseOptions.params[t]}:{type:\"Parameter\",name:t}}},be={object_expr(e){if(\"pair\"===e.getMark().name){e.shift();return{type:\"ObjectConditionalSplat\",condition:e.process(me),value:e.process(me)}}const t=e.process(me);return{type:\"ObjectAttributeValue\",name:ke(t),value:t}},object_pair(e){const t=e.process(me);if(\"Value\"!==t.type)throw new Error(\"name must be string\");const r=e.process(me);return{type:\"ObjectAttributeValue\",name:t.value,value:r}},object_splat:e=>({type:\"ObjectSplat\",value:e.process(me)}),object_splat_this:()=>({type:\"ObjectSplat\",value:{type:\"This\"}})},ge={square_bracket(e){const t=e.process(me),r=P(t);return r&&\"number\"===r.type?e=>function(e,t){if(!t)return{type:\"a-b\",build:e};switch(t.type){case\"a-a\":case\"b-a\":return{type:\"a-a\",build:ue(e,t.build)};case\"a-b\":case\"b-b\":return{type:\"a-b\",build:ue(e,t.build)};default:throw new Error(`unknown type: ${t.type}`)}}((e=>({type:\"AccessElement\",base:e,index:r.data})),e):r&&\"string\"===r.type?e=>fe((e=>({type:\"AccessAttribute\",base:e,name:r.data})),e):e=>le((e=>({type:\"Filter\",base:e,expr:t})),e)},slice(e){const t=\"inc_range\"===e.getMark().name;e.shift();const r=e.process(me),n=e.process(me),o=P(r),i=P(n);if(!o||!i||\"number\"!==o.type||\"number\"!==i.type)throw new he(\"slicing must use constant numbers\");return e=>le((e=>({type:\"Slice\",base:e,left:o.data,right:i.data,isInclusive:t})),e)},projection(e){const t=e.process(me);return e=>function(e,t){if(!t)return{type:\"b-b\",build:e};switch(t.type){case\"a-a\":return{type:\"a-a\",build:ue(pe(e),t.build)};case\"a-b\":return{type:\"a-b\",build:ue(pe(e),t.build)};case\"b-a\":return{type:\"b-a\",build:ue(e,t.build)};case\"b-b\":return{type:\"b-b\",build:ue(e,t.build)};default:throw new Error(`unknown type: ${t.type}`)}}((e=>({type:\"Projection\",base:e,expr:t})),e)},attr_access(e){const t=e.processString();return e=>fe((e=>({type:\"AccessAttribute\",base:e,name:t})),e)},deref(e){let t=null;\"deref_attr\"===e.getMark().name&&(e.shift(),t=e.processString());return e=>fe((e=>(e=>t?{type:\"AccessAttribute\",base:e,name:t}:e)({type:\"Deref\",base:e})),e)},array_postfix:()=>e=>le((e=>({type:\"ArrayCoerce\",base:e})),e)},we={group:e=>(e.process(we),null),everything(){throw new Error(\"Invalid selector syntax\")},this(){throw new Error(\"Invalid selector syntax\")},parent(){throw new Error(\"Invalid selector syntax\")},dblparent(){throw new Error(\"Invalid selector syntax\")},traverse(e){for(e.process(we);\"traversal_end\"!==e.getMark().name;)e.process(ge);return e.shift(),null},this_attr:e=>(e.processString(),null),neg(){throw new Error(\"Invalid selector syntax\")},pos(){throw new Error(\"Invalid selector syntax\")},add(){throw new Error(\"Invalid selector syntax\")},sub(){throw new Error(\"Invalid selector syntax\")},mul(){throw new Error(\"Invalid selector syntax\")},div(){throw new Error(\"Invalid selector syntax\")},mod(){throw new Error(\"Invalid selector syntax\")},pow(){throw new Error(\"Invalid selector syntax\")},comp(){throw new Error(\"Invalid selector syntax\")},in_range(){throw new Error(\"Invalid selector syntax\")},str(){throw new Error(\"Invalid selector syntax\")},integer(){throw new Error(\"Invalid selector syntax\")},float(){throw new Error(\"Invalid selector syntax\")},sci(){throw new Error(\"Invalid selector syntax\")},object(){throw new Error(\"Invalid selector syntax\")},array(){throw new Error(\"Invalid selector syntax\")},tuple(){throw new Error(\"Invalid selector syntax\")},func_call(e,t){const r=me.func_call(e,t);if(\"anywhere\"===r.name&&1===r.args.length)return null;throw new Error(\"Invalid selector syntax\")},pipecall(){throw new Error(\"Invalid selector syntax\")},pair(){throw new Error(\"Invalid selector syntax\")},and(){throw new Error(\"Invalid selector syntax\")},or(){throw new Error(\"Invalid selector syntax\")},not(){throw new Error(\"Invalid selector syntax\")},asc(){throw new Error(\"Invalid selector syntax\")},desc(){throw new Error(\"Invalid selector syntax\")},param(){throw new Error(\"Invalid selector syntax\")}};function ke(e){if(\"AccessAttribute\"===e.type&&!e.base)return e.name;if(\"PipeFuncCall\"===e.type||\"Deref\"===e.type||\"Map\"===e.type||\"Projection\"===e.type||\"Slice\"===e.type||\"Filter\"===e.type||\"AccessElement\"===e.type||\"ArrayCoerce\"===e.type||\"Group\"===e.type)return ke(e.base);throw new he(`Cannot determine property key for type: ${e.type}`)}function ve(e,t,r){if(\"number\"==typeof t){if(r!==t)throw new he(`Incorrect number of arguments to function ${e}(). Expected ${t}, got ${r}.`)}else if(t&&!t(r))throw new he(`Incorrect number of arguments to function ${e}().`)}function xe(e,t,r){return\"diff\"==e&&2==r&&[\"changedAny\",\"changedOnly\"].includes(t)}class _e extends Error{position;name=\"GroqSyntaxError\";constructor(e){super(`Syntax error in GROQ query at position ${e}`),this.position=e}}function Ae(e,t={}){const r=function(e){let t=0;t=se(e,t);let r=re(e,t,0);return\"error\"===r.type?r:(t=se(e,r.position),t!==e.length?(r.failPosition&&(t=r.failPosition-1),{type:\"error\",position:t}):(delete r.position,delete r.failPosition,r))}(e);if(\"error\"===r.type)throw new _e(r.position);return new K(e,r.marks,t).process(me)}export{C as evaluateSync,Ae as parse};\n","import {makePatches, stringifyPatches} from '@sanity/diff-match-patch'\nimport {\n  isKeyedObject,\n  type PatchOperations as AllPatchOperations,\n  type Path,\n  type SanityDocument,\n} from '@sanity/types'\n\nimport {stringifyPath} from './patchOperations'\n\nexport type PatchOperations = Pick<\n  AllPatchOperations,\n  'diffMatchPatch' | 'set' | 'setIfMissing' | 'unset' | 'insert'\n>\n\nconst isRecord = (value: unknown): value is Record<string, unknown> =>\n  typeof value === 'object' && !!value && !Array.isArray(value)\n\nconst ignoredKeys = ['_id', '_type', '_createdAt', '_updatedAt', '_rev']\n\nexport function diffPatch(before: SanityDocument, after: SanityDocument): PatchOperations[] {\n  return diffRecursive(before, after, [])\n}\n\n/**\n * Recursively diff two values given a current path.\n *\n * The rules are:\n * - If the two values are identical, return no patches.\n * - If the two values are of different types, issue a set patch for the entire path.\n * - If both values are strings, compute a diffmatchpatch patch.\n * - If both values are numbers, booleans, null, etc., use a set patch.\n * - If both values are arrays, delegate to diffArray.\n * - If both values are objects then:\n *    - For each key (ignoring keys that start with `_`), if the key is missing in `after` then\n *      issue an unset patch; if extra then a set patch; otherwise, recursively diff.\n */\nfunction diffRecursive(before: unknown, after: unknown, path: Path): PatchOperations[] {\n  if (before === after) return []\n\n  const patches: PatchOperations[] = []\n  const pathStr = stringifyPath(path)\n\n  // Handle null (remember that typeof null is \"object\")\n  if (before === null || after === null) {\n    if (before !== after) {\n      patches.push({set: {[pathStr]: after}})\n    }\n    return patches\n  }\n\n  // If types differ (or one is an array and the other isnt)  replace whole value.\n  if (typeof before !== typeof after || Array.isArray(before) !== Array.isArray(after)) {\n    patches.push({set: {[pathStr]: after}})\n    return patches\n  }\n\n  // If both are strings, diff them using diffmatchpatch.\n  if (typeof before === 'string' && typeof after === 'string') {\n    const dmpPatches = makePatches(before, after)\n    const patchStr = stringifyPatches(dmpPatches)\n    patches.push({diffMatchPatch: {[pathStr]: patchStr}})\n    return patches\n  }\n\n  // If both are numbers then simply set the value if they differ.\n  if (typeof before === 'number' && typeof after === 'number') {\n    patches.push({set: {[pathStr]: after}})\n    return patches\n  }\n\n  // For other primitive values (boolean, undefined, etc.) use strict comparison.\n  if (typeof before !== 'object') {\n    if (before !== after) {\n      patches.push({set: {[pathStr]: after}})\n    }\n    return patches\n  }\n\n  // If both values are arrays, handle with diffArray.\n  if (Array.isArray(before) && Array.isArray(after)) {\n    patches.push(...diffArray(before, after, path))\n    return patches\n  }\n\n  if (!isRecord(after) || !isRecord(before)) return patches\n\n  // Both are plain objects.\n  const beforeKeys = Object.keys(before).filter((k) => !ignoredKeys.includes(k))\n  const afterKeys = Object.keys(after).filter((k) => !ignoredKeys.includes(k))\n  const allKeys = new Set([...beforeKeys, ...afterKeys])\n  for (const key of allKeys) {\n    const subPath = [...path, key]\n    if (!(key in after)) {\n      // Field removed  unset it.\n      patches.push({unset: [stringifyPath(subPath)]})\n    } else if (!(key in before)) {\n      // Field added  set it.\n      patches.push({set: {[stringifyPath(subPath)]: after[key]}})\n    } else {\n      // Field exists in both  recursively diff.\n      patches.push(...diffRecursive(before[key], after[key], subPath))\n    }\n  }\n  return patches\n}\n\n/**\n * Diff two arrays.\n *\n * If both arrays are keyed (every element is an object with a string `_key` property)\n * then we:\n *\n * 1. Unset any items that were removed (using the keyed path, e.g. `items[_key==\"foo\"]`).\n * 2. Recursively diff any items that exist in both arrays.\n * 3. For any items in `after` that do not exist in `before`, group them and emit an insert patch.\n *\n * For nonkeyed arrays we simply compare indices, unsetting extra items from `before` and\n * inserting new items at the end.\n */\nfunction diffArray(beforeArr: unknown[], afterArr: unknown[], path: Path): PatchOperations[] {\n  const pathStr = stringifyPath(path)\n\n  // Helper: determine if every element is an object with a `_key` property.\n  const isKeyedArray = (arr: unknown[]) => arr.every((item) => isKeyedObject(item))\n\n  // For keyed arrays, we collect patches in three buckets.\n  if (isKeyedArray(beforeArr) && isKeyedArray(afterArr)) {\n    // SPECIAL FIX: If the array is empty, produce an insert patch that prepends the new items.\n    if (beforeArr.length === 0 && afterArr.length > 0) {\n      return [\n        {\n          insert: {\n            before: stringifyPath([...path, 0]),\n            items: afterArr,\n          },\n        },\n      ]\n    }\n\n    const unsetPatches: PatchOperations[] = []\n    const diffPatches: PatchOperations[] = []\n    const insertPatches: PatchOperations[] = []\n\n    // Build maps from _key  {item, index}\n    const beforeMap = new Map<string, {item: unknown; index: number}>()\n    beforeArr.forEach((item, index) => {\n      // We assume item has a _key because of isKeyedArray.\n      beforeMap.set(item._key, {item, index})\n    })\n    const afterMap = new Map<string, {item: unknown; index: number}>()\n    afterArr.forEach((item, index) => {\n      afterMap.set(item._key, {item, index})\n    })\n\n    // 1. Unset removed items.\n    for (const [key] of beforeMap.entries()) {\n      if (!afterMap.has(key)) {\n        unsetPatches.push({unset: [stringifyPath([...path, {_key: key}])]})\n      }\n    }\n\n    // 2. Diff items that exist in both arrays.\n    for (const [key, {item: afterItem}] of afterMap.entries()) {\n      if (beforeMap.has(key)) {\n        diffPatches.push(\n          ...diffRecursive(beforeMap.get(key)!.item, afterItem, [...path, {_key: key}]),\n        )\n      }\n    }\n\n    // 3. Find contiguous new items in `after` and insert them.\n    let newItemsGroup: unknown[] = []\n    let insertPosition: {op: 'before' | 'after'; refKey: string} | null = null\n    for (let i = 0; i < afterArr.length; i++) {\n      const item = afterArr[i]\n      if (!beforeMap.has(item._key)) {\n        // New item.\n        if (newItemsGroup.length === 0) {\n          if (i === 0) {\n            // Look ahead for the first existing item.\n            let j = i\n            while (j < afterArr.length && !beforeMap.has(afterArr[j]._key)) {\n              j++\n            }\n            if (j < afterArr.length) {\n              insertPosition = {op: 'before', refKey: afterArr[j]._key}\n            } else if (beforeArr.length > 0) {\n              // Fallback: all items are new  use the last before item as anchor.\n              insertPosition = {op: 'after', refKey: beforeArr[beforeArr.length - 1]._key}\n            }\n          } else {\n            // Look backward for an existing item.\n            let j = i - 1\n            while (j >= 0 && !beforeMap.has(afterArr[j]._key)) {\n              j--\n            }\n            if (j >= 0) {\n              insertPosition = {op: 'after', refKey: afterArr[j]._key}\n            } else {\n              // Fallback  look ahead.\n              let k = i\n              while (k < afterArr.length && !beforeMap.has(afterArr[k]._key)) {\n                k++\n              }\n              if (k < afterArr.length) {\n                insertPosition = {op: 'before', refKey: afterArr[k]._key}\n              }\n            }\n          }\n        }\n        newItemsGroup.push(item)\n      } else {\n        // Flush any pending group.\n        if (newItemsGroup.length > 0 && insertPosition) {\n          if (insertPosition.op === 'before') {\n            insertPatches.push({\n              insert: {\n                before: stringifyPath([...path, {_key: insertPosition.refKey}]),\n                items: newItemsGroup,\n              },\n            })\n          } else {\n            insertPatches.push({\n              insert: {\n                after: stringifyPath([...path, {_key: insertPosition.refKey}]),\n                items: newItemsGroup,\n              },\n            })\n          }\n          newItemsGroup = []\n          insertPosition = null\n        }\n      }\n    }\n    // Flush any remaining group (at the end of the array).\n    if (newItemsGroup.length > 0 && insertPosition) {\n      if (insertPosition.op === 'after') {\n        insertPatches.push({\n          insert: {\n            after: stringifyPath([...path, {_key: insertPosition.refKey}]),\n            items: newItemsGroup,\n          },\n        })\n      } else {\n        insertPatches.push({\n          insert: {\n            before: stringifyPath([...path, {_key: insertPosition.refKey}]),\n            items: newItemsGroup,\n          },\n        })\n      }\n    }\n\n    // If every item in the \"after\" array is new (fallback branch) then\n    // output the insert patch before the unset patches so that when applied\n    // the insert anchor is resolved against the original document.\n    const allNew = afterArr.every((item) => !beforeMap.has(item._key))\n    if (allNew) {\n      return [...insertPatches, ...unsetPatches, ...diffPatches]\n    }\n    return [...unsetPatches, ...diffPatches, ...insertPatches]\n  } else {\n    // Nonkeyed arrays: diff by index.\n    const patches: PatchOperations[] = []\n    const minLength = Math.min(beforeArr.length, afterArr.length)\n    for (let i = 0; i < minLength; i++) {\n      patches.push(...diffRecursive(beforeArr[i], afterArr[i], [...path, i]))\n    }\n    // Unset extra items from before.\n    for (let i = afterArr.length; i < beforeArr.length; i++) {\n      patches.push({unset: [stringifyPath([...path, i])]})\n    }\n    // Insert any extra items from after.\n    if (afterArr.length > beforeArr.length) {\n      const newItems = afterArr.slice(beforeArr.length)\n      if (beforeArr.length > 0) {\n        patches.push({\n          insert: {after: stringifyPath([...path, beforeArr.length - 1]), items: newItems},\n        })\n      } else {\n        // If the array was empty, simply set the whole array.\n        patches.push({set: {[pathStr]: afterArr}})\n      }\n    }\n    return patches\n  }\n}\n","interface MultiKeyWeakMapNode {\n  value: unknown\n  next: WeakMap<object, MultiKeyWeakMapNode>\n}\n\nexport class MultiKeyWeakMap<T = unknown> {\n  // The root of our nested WeakMap structure.\n  #rootMap = new WeakMap<object, MultiKeyWeakMapNode>()\n\n  // Instead of random IDs, we use a counter for deterministic IDs.\n  static #globalIdCounter = 0\n  // Each instance keeps a cache mapping a key to its assigned ID.\n  #idCache = new WeakMap<object, number>()\n\n  /**\n   * Assigns a numeric ID to the key.\n   */\n  #assignId(key: object): number {\n    const cachedId = this.#idCache.get(key)\n    if (cachedId !== undefined) return cachedId\n\n    const id = MultiKeyWeakMap.#globalIdCounter\n    this.#idCache.set(key, id)\n    MultiKeyWeakMap.#globalIdCounter++\n    return id\n  }\n\n  /**\n   * Remove duplicate keys and arrange them in a consistent order\n   * by sorting according to their assigned IDs.\n   */\n  #arrangeKeys(keys: object[]): object[] {\n    const uniqueKeys = Array.from(new Set(keys))\n    const keyed = uniqueKeys.map((key) => [this.#assignId(key), key] as const)\n    keyed.sort((a, b) => a[0] - b[0])\n    return keyed.map(([, key]) => key)\n  }\n\n  /**\n   * Recursively search the nested WeakMap structure for the value.\n   */\n  #getDeep(keys: object[], map: WeakMap<object, MultiKeyWeakMapNode>): unknown {\n    if (keys.length === 0) return undefined\n\n    const [firstKey, ...restKeys] = keys\n    const node = map.get(firstKey)\n    if (!node) return undefined\n    if (restKeys.length === 0) return node.value\n    return this.#getDeep(restKeys, node.next)\n  }\n\n  /**\n   * Recursively create nodes along the key chain until the final key\n   * is reached, then assign the value.\n   */\n  #setDeep(keys: object[], map: WeakMap<object, MultiKeyWeakMapNode>, value: unknown): void {\n    if (keys.length === 0) return\n\n    const [firstKey, ...restKeys] = keys\n    let node = map.get(firstKey)\n    if (!node) {\n      node = {\n        value: undefined,\n        next: new WeakMap(),\n      }\n      map.set(firstKey, node)\n    }\n\n    if (restKeys.length === 0) {\n      node.value = value\n    } else {\n      this.#setDeep(restKeys, node.next, value)\n    }\n  }\n\n  /**\n   * Retrieves the value associated with the array of keys.\n   * The keys are de-duplicated and sorted so that the order does not matter.\n   */\n  get(keys: object[]): T | undefined {\n    const arrangedKeys = this.#arrangeKeys(keys)\n    return this.#getDeep(arrangedKeys, this.#rootMap) as T | undefined\n  }\n\n  /**\n   * Associates the value with the given array of keys.\n   */\n  set(keys: object[], value: T): void {\n    const arrangedKeys = this.#arrangeKeys(keys)\n    this.#setDeep(arrangedKeys, this.#rootMap, value)\n  }\n}\n","import {type SanityDocument} from '@sanity/types'\nimport {type ExprNode} from 'groq-js'\nimport {createSelector} from 'reselect'\n\nimport {type SelectorContext} from '../store/createStateSourceAction'\nimport {getDraftId, getPublishedId} from '../utils/ids'\nimport {MultiKeyWeakMap} from '../utils/MultiKeyWeakMap'\nimport {evaluateSync, parse} from './_synchronous-groq-js.mjs'\nimport {type DocumentAction} from './actions'\nimport {ActionError, PermissionActionError, processActions} from './processActions'\nimport {type DocumentSet} from './processMutations'\nimport {type SyncTransactionState} from './reducers'\n\nexport type Grant = 'read' | 'update' | 'create' | 'history'\n\nexport type DatasetAcl = {\n  filter: string\n  permissions: Grant[]\n}[]\n\nexport function createGrantsLookup(datasetAcl: DatasetAcl): Record<Grant, ExprNode> {\n  const filtersByGrant: Record<Grant, Set<string>> = {\n    create: new Set(),\n    history: new Set(),\n    read: new Set(),\n    update: new Set(),\n  }\n\n  for (const entry of datasetAcl) {\n    for (const grant of entry.permissions) {\n      const set = filtersByGrant[grant]\n      set.add(entry.filter)\n      filtersByGrant[grant] = set\n    }\n  }\n\n  return Object.fromEntries(\n    Object.entries(filtersByGrant).map(([grant, filters]) => {\n      const combinedFilter = Array.from(filters)\n        .map((i) => `(${i})`)\n        .join('||')\n\n      if (!combinedFilter) return [grant, parse('false')]\n      return [grant, parse(`$document {\"_\": ${combinedFilter}}._`)]\n    }),\n  ) as Record<Grant, ExprNode>\n}\n\n// Cache for documents based on an array of document objects.\nconst documentsCache = new MultiKeyWeakMap<DocumentSet>()\n// Use a WeakMap so that when a computed DocumentSet is no longer in use,\n// its nested cache for actions can be garbage-collected.\nconst actionsCache = new WeakMap<DocumentSet, Map<string, DocumentAction[]>>()\n\nconst nullReplacer: object = {}\n\n// Compute documents from state and actions.\n// (If the same documents are computed, the MultiKeyWeakMap will return the same instance.)\nconst documentsSelector = createSelector(\n  [\n    ({state: {documentStates}}: SelectorContext<SyncTransactionState>) => documentStates,\n    (_context: SelectorContext<SyncTransactionState>, actions: DocumentAction | DocumentAction[]) =>\n      actions,\n  ],\n  (documentStates, actions) => {\n    const documentIds = new Set(\n      (Array.isArray(actions) ? actions : [actions])\n        .map((i) => i.documentId)\n        .filter((i) => typeof i === 'string')\n        .flatMap((documentId) => [getPublishedId(documentId), getDraftId(documentId)]),\n    )\n\n    const documents: DocumentSet = {}\n\n    for (const documentId of documentIds) {\n      const local = documentStates[documentId]?.local\n\n      // early exit if we don't have all the documents yet\n      if (local === undefined) return undefined\n      documents[documentId] = local\n    }\n\n    // Create a key from the documents values (using a nullReplacer when needed).\n    const keys = Object.values(\n      // value in this record will be `undefined` because\n      // of the early return if undefined is found above\n      documents as Record<string, SanityDocument | null>,\n    ).map((doc) => (doc === null ? nullReplacer : doc))\n    const cached = documentsCache.get(keys)\n    if (cached) return cached\n\n    documentsCache.set(keys, documents)\n    return documents\n  },\n)\n\n// Cache the actions array based on a serialized version, but attach the cache\n// to the computed documents. That way if the computed documents object is no longer in use,\n// the cache is eligible for GC.\nconst memoizedActionsSelector = createSelector(\n  [\n    documentsSelector,\n    (_state: SelectorContext<SyncTransactionState>, actions: DocumentAction | DocumentAction[]) =>\n      actions,\n  ],\n  (documents, actions) => {\n    if (!documents) return undefined\n\n    // Get (or create) the nested Map for this computed documents.\n    let nestedCache = actionsCache.get(documents)\n    if (!nestedCache) {\n      nestedCache = new Map<string, DocumentAction[]>()\n      actionsCache.set(documents, nestedCache)\n    }\n\n    const normalizedActions = Array.isArray(actions) ? actions : [actions]\n\n    // Use JSON.stringify to get a serialized key for the actions.\n    // TODO: considering swapping thisfor a more efficient or stable hash\n    const actionsKey = JSON.stringify(normalizedActions)\n    const cached = nestedCache.get(actionsKey)\n    if (cached) return cached\n\n    nestedCache.set(actionsKey, normalizedActions)\n    return normalizedActions\n  },\n)\n\nfunction checkGrant(grantExpr: ExprNode, document: SanityDocument): boolean {\n  return evaluateSync(grantExpr, {params: {document}}).get()\n}\n\n/** @beta */\nexport interface PermissionDeniedReason {\n  type: 'precondition' | 'access'\n  message: string\n  documentId?: string\n}\n\n/** @beta */\nexport type DocumentPermissionsResult =\n  | {\n      allowed: false\n      message: string\n      reasons: PermissionDeniedReason[]\n    }\n  | {allowed: true; message?: undefined; reasons?: undefined}\n\nconst enNarrowConjunction = new Intl.ListFormat('en', {style: 'narrow', type: 'conjunction'})\n\nexport const calculatePermissions = createSelector(\n  [\n    ({state: {grants}}: SelectorContext<SyncTransactionState>) => grants,\n    documentsSelector,\n    memoizedActionsSelector,\n  ],\n  (\n    grants: Record<Grant, ExprNode> | undefined,\n    documents: DocumentSet | undefined,\n    actions: DocumentAction[] | undefined,\n  ): DocumentPermissionsResult | undefined => {\n    if (!documents) return undefined\n    if (!grants) return undefined\n    if (!actions) return undefined\n\n    const timestamp = new Date().toISOString()\n    const reasons: PermissionDeniedReason[] = []\n\n    try {\n      processActions({\n        actions,\n        transactionId: crypto.randomUUID(),\n        working: documents,\n        base: documents,\n        timestamp,\n        grants,\n      })\n    } catch (error) {\n      if (error instanceof PermissionActionError) {\n        reasons.push({\n          message: error.message,\n          documentId: error.documentId,\n          type: 'access',\n        })\n      } else if (error instanceof ActionError) {\n        reasons.push({\n          message: error.message,\n          documentId: error.documentId,\n          type: 'precondition',\n        })\n      } else {\n        throw error\n      }\n    }\n\n    for (const action of actions) {\n      // Check edit actions with no patches\n      if (action.type === 'document.edit' && !action.patches?.length) {\n        const docId = action.documentId\n        const doc = documents[getDraftId(docId)] ?? documents[getPublishedId(docId)]\n        if (!doc) {\n          reasons.push({\n            type: 'precondition',\n            message: `The document with ID \"${docId}\" could not be found. Please check that it exists before editing.`,\n            documentId: docId,\n          })\n        } else if (!checkGrant(grants.update, doc)) {\n          reasons.push({\n            type: 'access',\n            message: `You are not allowed to edit the document with ID \"${docId}\".`,\n            documentId: docId,\n          })\n        }\n      }\n    }\n\n    const allowed = reasons.length === 0\n    if (allowed) return {allowed}\n\n    const sortedReasons = reasons\n      .map((reason, index) => ({...reason, index}))\n      .sort((a, b) => {\n        if (a.type !== b.type) return a.type === 'access' ? -1 : 1\n        return a.message.localeCompare(b.message, 'en-US')\n      })\n      .map(({index: _index, ...reason}) => reason)\n\n    return {\n      allowed,\n      reasons: sortedReasons,\n      message: enNarrowConjunction.format(sortedReasons.map((i) => i.message)),\n    }\n  },\n)\n","import {\n  type Mutation,\n  type PatchOperations,\n  type Reference,\n  type SanityDocument,\n} from '@sanity/types'\nimport {type ExprNode} from 'groq-js'\nimport {isEqual} from 'lodash-es'\n\nimport {getDraftId, getPublishedId} from '../utils/ids'\nimport {evaluateSync} from './_synchronous-groq-js.mjs'\nimport {type DocumentAction} from './actions'\nimport {diffPatch} from './diffPatch'\nimport {type Grant} from './permissions'\nimport {type DocumentSet, getId, processMutations} from './processMutations'\nimport {type HttpAction} from './reducers'\n\nfunction checkGrant(grantExpr: ExprNode, document: SanityDocument): boolean {\n  return evaluateSync(grantExpr, {params: {document}}).get()\n}\n\ninterface ProcessActionsOptions {\n  /**\n   * The ID of this transaction. This will become the resulting `_rev` for all\n   * documents affected by changes derived from the current set of actions.\n   */\n  transactionId: string\n\n  /**\n   * The actions to apply to the given documents\n   */\n  actions: DocumentAction[]\n\n  /**\n   * The set of documents these actions were intended to be applied to. These\n   * set of documents should be captured right before a queued action is\n   * applied.\n   */\n  base: DocumentSet\n\n  /**\n   * The current \"working\" set of documents. A patch will be created by applying\n   * the actions to the base. This patch will then be applied to the working\n   * set for conflict resolution. Initially, this value should match the base\n   * set.\n   */\n  working: DocumentSet\n\n  /**\n   * The timestamp to use for `_updateAt` and other similar timestamps for this\n   * transaction\n   */\n  timestamp: string\n\n  /**\n   * the lookup with pre-parsed GROQ expressions\n   */\n  grants: Record<Grant, ExprNode>\n\n  // // TODO: implement initial values from the schema?\n  // initialValues?: {[TDocumentType in string]?: {_type: string}}\n}\n\ninterface ProcessActionsResult {\n  /**\n   * The resulting document set after the actions have been applied. This is\n   * derived from the working documents.\n   */\n  working: DocumentSet\n  /**\n   * The document set before the actions have been applied. This is simply the\n   * input of the `working` document set.\n   */\n  previous: DocumentSet\n  /**\n   * The outgoing action that were collected when applying the actions. These\n   * are sent to the Actions HTTP API\n   */\n  outgoingActions: HttpAction[]\n  /**\n   * The outgoing mutations that were collected when applying the actions. These\n   * are here for debugging purposes.\n   */\n  outgoingMutations: Mutation[]\n  /**\n   * The previous revisions of the given documents before the actions were applied.\n   */\n  previousRevs: {[TDocumentId in string]?: string}\n}\n\ninterface ActionErrorOptions {\n  message: string\n  documentId: string\n  transactionId: string\n}\n\n/**\n * Thrown when a precondition for an action failed.\n */\nexport class ActionError extends Error implements ActionErrorOptions {\n  documentId!: string\n  transactionId!: string\n\n  constructor(options: ActionErrorOptions) {\n    super(options.message)\n    Object.assign(this, options)\n  }\n}\n\nexport class PermissionActionError extends ActionError {}\n\n/**\n * Applies the given set of actions to the working set of documents and converts\n * high-level actions into lower-level outgoing mutations/actions that respect\n * the current state of the working documents.\n *\n * Supports a \"base\" and \"working\" set of documents to allow actions to be\n * applied on top of a different working set of documents in a 3-way merge\n *\n * Actions are applied to the base set of documents first. The difference\n * between the base before and after is used to create a patch. This patch is\n * then applied to the working set of documents and is set as the outgoing patch\n * sent to the server.\n */\nexport function processActions({\n  actions,\n  transactionId,\n  working: initialWorking,\n  base: initialBase,\n  timestamp,\n  grants,\n}: ProcessActionsOptions): ProcessActionsResult {\n  let working: DocumentSet = {...initialWorking}\n  let base: DocumentSet = {...initialBase}\n\n  const outgoingActions: HttpAction[] = []\n  const outgoingMutations: Mutation[] = []\n\n  for (const action of actions) {\n    switch (action.type) {\n      case 'document.create': {\n        const documentId = getId(action.documentId)\n        const draftId = getDraftId(documentId)\n        const publishedId = getPublishedId(documentId)\n\n        if (working[draftId]) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `A draft version of this document already exists. Please use or discard the existing draft before creating a new one.`,\n          })\n        }\n\n        // Spread the (possibly undefined) published version directly.\n        const newDocBase = {...base[publishedId], _type: action.documentType, _id: draftId}\n        const newDocWorking = {...working[publishedId], _type: action.documentType, _id: draftId}\n        const mutations: Mutation[] = [{create: newDocWorking}]\n\n        base = processMutations({\n          documents: base,\n          transactionId,\n          mutations: [{create: newDocBase}],\n          timestamp,\n        })\n        working = processMutations({\n          documents: working,\n          transactionId,\n          mutations,\n          timestamp,\n        })\n\n        if (!checkGrant(grants.create, working[draftId] as SanityDocument)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to create a draft for document \"${documentId}\".`,\n          })\n        }\n\n        outgoingMutations.push(...mutations)\n        outgoingActions.push({\n          actionType: 'sanity.action.document.version.create',\n          publishedId,\n          attributes: newDocWorking,\n        })\n        continue\n      }\n\n      case 'document.delete': {\n        const documentId = action.documentId\n        const draftId = getDraftId(documentId)\n        const publishedId = getPublishedId(documentId)\n\n        if (!working[publishedId]) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: working[draftId]\n              ? 'Cannot delete a document without a published version.'\n              : 'The document you are trying to delete does not exist.',\n          })\n        }\n\n        const cantDeleteDraft = working[draftId] && !checkGrant(grants.update, working[draftId])\n        const cantDeletePublished =\n          working[publishedId] && !checkGrant(grants.update, working[publishedId])\n\n        if (cantDeleteDraft || cantDeletePublished) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to delete this document.`,\n          })\n        }\n\n        const mutations: Mutation[] = [{delete: {id: publishedId}}, {delete: {id: draftId}}]\n        const includeDrafts = working[draftId] ? [draftId] : undefined\n\n        base = processMutations({documents: base, transactionId, mutations, timestamp})\n        working = processMutations({documents: working, transactionId, mutations, timestamp})\n\n        outgoingMutations.push(...mutations)\n        outgoingActions.push({\n          actionType: 'sanity.action.document.delete',\n          publishedId,\n          ...(includeDrafts ? {includeDrafts} : {}),\n        })\n        continue\n      }\n\n      case 'document.discard': {\n        const documentId = getId(action.documentId)\n        const draftId = getDraftId(documentId)\n        const mutations: Mutation[] = [{delete: {id: draftId}}]\n\n        if (!working[draftId]) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `There is no draft available to discard for document \"${documentId}\".`,\n          })\n        }\n\n        if (!checkGrant(grants.update, working[draftId])) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to discard changes for document \"${documentId}\".`,\n          })\n        }\n\n        base = processMutations({documents: base, transactionId, mutations, timestamp})\n        working = processMutations({documents: working, transactionId, mutations, timestamp})\n\n        outgoingMutations.push(...mutations)\n        outgoingActions.push({\n          actionType: 'sanity.action.document.version.discard',\n          versionId: draftId,\n        })\n        continue\n      }\n\n      case 'document.edit': {\n        const documentId = getId(action.documentId)\n        const draftId = getDraftId(documentId)\n        const publishedId = getPublishedId(documentId)\n        const userPatches = action.patches?.map((patch) => ({patch: {id: draftId, ...patch}}))\n\n        // skip this action if there are no associated patches\n        if (!userPatches?.length) continue\n\n        if (\n          (!working[draftId] && !working[publishedId]) ||\n          (!base[draftId] && !base[publishedId])\n        ) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `Cannot edit document because it does not exist in draft or published form.`,\n          })\n        }\n\n        const baseMutations: Mutation[] = []\n        if (!base[draftId] && base[publishedId]) {\n          baseMutations.push({create: {...base[publishedId], _id: draftId}})\n        }\n\n        // the first if statement should make this never be null or undefined\n        const baseBefore = (base[draftId] ?? base[publishedId]) as SanityDocument\n        if (userPatches) {\n          baseMutations.push(...userPatches)\n        }\n\n        base = processMutations({\n          documents: base,\n          transactionId,\n          mutations: baseMutations,\n          timestamp,\n        })\n        // this one will always be defined because a patch mutation will never\n        // delete an input document\n        const baseAfter = base[draftId] as SanityDocument\n\n        // TODO: consider replacing with `sanity-diff-patch`. There seems to be\n        // bug in `sanity-diff-patch` where differing strings are not creating\n        // diff-match patches.\n        const patches = diffPatch(baseBefore, baseAfter)\n\n        const workingMutations: Mutation[] = []\n        if (!working[draftId] && working[publishedId]) {\n          const newDraftFromPublished = {...working[publishedId], _id: draftId}\n\n          if (!checkGrant(grants.create, newDraftFromPublished)) {\n            throw new PermissionActionError({\n              documentId,\n              transactionId,\n              message: `You do not have permission to create a draft for editing this document.`,\n            })\n          }\n\n          workingMutations.push({create: newDraftFromPublished})\n        }\n\n        // the first if statement should make this never be null or undefined\n        const workingBefore = (working[draftId] ?? working[publishedId]) as SanityDocument\n        if (!checkGrant(grants.update, workingBefore)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to edit document \"${documentId}\".`,\n          })\n        }\n        workingMutations.push(...patches.map((patch) => ({patch: {id: draftId, ...patch}})))\n\n        working = processMutations({\n          documents: working,\n          transactionId,\n          mutations: workingMutations,\n          timestamp,\n        })\n\n        outgoingMutations.push(...workingMutations)\n        outgoingActions.push(\n          ...patches.map(\n            (patch): HttpAction => ({\n              actionType: 'sanity.action.document.edit',\n              draftId,\n              publishedId,\n              patch: patch as PatchOperations,\n            }),\n          ),\n        )\n\n        continue\n      }\n\n      case 'document.publish': {\n        const documentId = getId(action.documentId)\n        const draftId = getDraftId(documentId)\n        const publishedId = getPublishedId(documentId)\n\n        const workingDraft = working[draftId]\n        const baseDraft = base[draftId]\n        if (!workingDraft || !baseDraft) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `Cannot publish because no draft version was found for document \"${documentId}\".`,\n          })\n        }\n\n        // Before proceeding, verify that the working draft is identical to the base draft.\n        // TODO: is it enough just to check for the _rev or nah?\n        if (!isEqual(workingDraft, baseDraft)) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `Publish aborted: The document has changed elsewhere. Please try again.`,\n          })\n        }\n\n        const newPublishedFromDraft = {...strengthenOnPublish(workingDraft), _id: publishedId}\n\n        const mutations: Mutation[] = [\n          {delete: {id: draftId}},\n          {createOrReplace: newPublishedFromDraft},\n        ]\n\n        if (working[draftId] && !checkGrant(grants.update, working[draftId])) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `Publish failed: You do not have permission to update the draft for \"${documentId}\".`,\n          })\n        }\n\n        if (working[publishedId] && !checkGrant(grants.update, newPublishedFromDraft)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `Publish failed: You do not have permission to update the published version of \"${documentId}\".`,\n          })\n        } else if (!working[publishedId] && !checkGrant(grants.create, newPublishedFromDraft)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `Publish failed: You do not have permission to publish a new version of \"${documentId}\".`,\n          })\n        }\n\n        base = processMutations({documents: base, transactionId, mutations, timestamp})\n        working = processMutations({documents: working, transactionId, mutations, timestamp})\n\n        outgoingMutations.push(...mutations)\n        outgoingActions.push({\n          actionType: 'sanity.action.document.publish',\n          draftId,\n          publishedId,\n        })\n        continue\n      }\n\n      case 'document.unpublish': {\n        const documentId = getId(action.documentId)\n        const draftId = getDraftId(documentId)\n        const publishedId = getPublishedId(documentId)\n\n        if (!working[publishedId] && !base[publishedId]) {\n          throw new ActionError({\n            documentId,\n            transactionId,\n            message: `Cannot unpublish because the document \"${documentId}\" is not currently published.`,\n          })\n        }\n\n        const sourceDoc = working[publishedId] ?? (base[publishedId] as SanityDocument)\n        const newDraftFromPublished = {...sourceDoc, _id: draftId}\n        const mutations: Mutation[] = [\n          {delete: {id: publishedId}},\n          {createIfNotExists: newDraftFromPublished},\n        ]\n\n        if (!checkGrant(grants.update, sourceDoc)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to unpublish the document \"${documentId}\".`,\n          })\n        }\n\n        if (!working[draftId] && !checkGrant(grants.create, newDraftFromPublished)) {\n          throw new PermissionActionError({\n            documentId,\n            transactionId,\n            message: `You do not have permission to create a draft from the published version of \"${documentId}\".`,\n          })\n        }\n\n        base = processMutations({\n          documents: base,\n          transactionId,\n          mutations: [\n            {delete: {id: publishedId}},\n            {createIfNotExists: {...(base[publishedId] ?? sourceDoc), _id: draftId}},\n          ],\n          timestamp,\n        })\n        working = processMutations({documents: working, transactionId, mutations, timestamp})\n\n        outgoingMutations.push(...mutations)\n        outgoingActions.push({\n          actionType: 'sanity.action.document.unpublish',\n          draftId,\n          publishedId,\n        })\n        continue\n      }\n\n      default: {\n        throw new Error(\n          `Unknown action type: \"${\n            // @ts-expect-error invalid input\n            action.type\n          }\". Please contact support if this issue persists.`,\n        )\n      }\n    }\n  }\n\n  const previousRevs = Object.fromEntries(\n    Object.entries(initialWorking).map(([id, doc]) => [id, doc?._rev]),\n  )\n\n  return {\n    working,\n    outgoingActions,\n    outgoingMutations,\n    previous: initialWorking,\n    previousRevs,\n  }\n}\n\nfunction strengthenOnPublish(draft: SanityDocument): SanityDocument {\n  const isStrengthenReference = (\n    value: object,\n  ): value is Reference & Required<Pick<Reference, '_strengthenOnPublish'>> =>\n    '_strengthenOnPublish' in value\n\n  function strengthen(value: unknown): unknown {\n    if (typeof value !== 'object' || !value) return value\n\n    if (isStrengthenReference(value)) {\n      const {_strengthenOnPublish, _weak, ...rest} = value\n      return {\n        ...rest,\n        ...(_strengthenOnPublish.weak && {_weak: true}),\n      }\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(strengthen)\n    }\n\n    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, strengthen(v)]))\n  }\n\n  return strengthen(draft) as SanityDocument\n}\n","import {getPublishedId} from '@sanity/client/csm'\nimport {type Mutation, type PatchOperations, type SanityDocumentLike} from '@sanity/types'\nimport {omit} from 'lodash-es'\n\nimport {type StoreContext} from '../store/defineStore'\nimport {getDraftId, insecureRandomId} from '../utils/ids'\nimport {type DocumentAction} from './actions'\nimport {DOCUMENT_STATE_CLEAR_DELAY} from './documentConstants'\nimport {type DocumentState, type DocumentStoreState} from './documentStore'\nimport {type RemoteDocument} from './listen'\nimport {ActionError, processActions} from './processActions'\nimport {type DocumentSet} from './processMutations'\n\nconst EMPTY_REVISIONS: NonNullable<Required<DocumentState['unverifiedRevisions']>> = {}\n\nexport type SyncTransactionState = Pick<\n  DocumentStoreState,\n  'queued' | 'applied' | 'documentStates' | 'outgoing' | 'grants'\n>\n\ntype ActionMap = {\n  create: 'sanity.action.document.version.create'\n  discard: 'sanity.action.document.version.discard'\n  unpublish: 'sanity.action.document.unpublish'\n  delete: 'sanity.action.document.delete'\n  edit: 'sanity.action.document.edit'\n  publish: 'sanity.action.document.publish'\n}\n\ntype OptimisticLock = {\n  ifDraftRevisionId?: string\n  ifPublishedRevisionId?: string\n}\n\nexport type HttpAction =\n  | {actionType: ActionMap['create']; publishedId: string; attributes: SanityDocumentLike}\n  | {actionType: ActionMap['discard']; versionId: string; purge?: boolean}\n  | {actionType: ActionMap['unpublish']; draftId: string; publishedId: string}\n  | {actionType: ActionMap['delete']; publishedId: string; includeDrafts?: string[]}\n  | {actionType: ActionMap['edit']; draftId: string; publishedId: string; patch: PatchOperations}\n  | ({actionType: ActionMap['publish']; draftId: string; publishedId: string} & OptimisticLock)\n\n/**\n * Represents a transaction that is queued to be applied but has not yet been\n * applied. A transaction will remain in a queued state until all required\n * documents for the transactions are available locally.\n */\nexport interface QueuedTransaction {\n  /**\n   * the ID of this transaction. this is generated client-side.\n   */\n  transactionId: string\n  /**\n   * the high-level actions associated with this transaction. note that these\n   * actions don't mention draft IDs and is meant to abstract away the draft\n   * model from users.\n   */\n  actions: DocumentAction[]\n  /**\n   * An optional flag set to disable this transaction from being batched with\n   * other transactions.\n   */\n  disableBatching?: boolean\n}\n\n/**\n * Represents a transaction that has been applied locally but has not been\n * committed/transitioned-to-outgoing. These transactions are visible to the\n * user but may be rebased upon a new working document set. Applied transactions\n * also contain the resulting `outgoingActions` that will be submitted to\n * Content Lake. These `outgoingActions` depend on the state of the working\n * documents so they are recomputed on rebase and are only relevant to applied\n * actions (we cannot compute `outgoingActions` for queued transactions because\n * we haven't resolved the set of documents the actions are dependent on yet).\n *\n * In order to support better conflict resolution, the original `previous` set\n * is saved as the `base` set.\n */\nexport interface AppliedTransaction extends QueuedTransaction {\n  /**\n   * the resulting set of documents after the actions have been applied\n   */\n  working: DocumentSet\n\n  /**\n   * the previous set of documents before the action was applied\n   */\n  previous: DocumentSet\n\n  /**\n   * the original `previous` document set captured when this action was\n   * originally applied. this is used as a reference point to do a 3-way merge\n   * if this applied transaction ever needs to be reapplied on a different\n   * set of documents.\n   */\n  base: DocumentSet\n\n  /**\n   * the `_rev`s from `previous` document set\n   */\n  previousRevs: {[TDocumentId in string]?: string}\n\n  /**\n   * a timestamp for when this transaction was applied locally\n   */\n  timestamp: string\n\n  /**\n   * the resulting HTTP actions derived from the state of the `working` document\n   * set. these are sent to Content Lake as-is when this transaction is batched\n   * and transitioned into an outgoing transaction.\n   */\n  outgoingActions: HttpAction[]\n\n  /**\n   * similar to `outgoingActions` but comprised of mutations instead of action.\n   * this left here for debugging purposes but could be used to send mutations\n   * to Content Lake instead of actions.\n   */\n  outgoingMutations: Mutation[]\n}\n\n/**\n * Represents a set of applied transactions batched into a single outgoing\n * transaction. An outgoing transaction is the result of batching many applied\n * actions. An outgoing transaction may be reverted locally if the server\n * does not accept it.\n */\nexport interface OutgoingTransaction extends AppliedTransaction {\n  disableBatching: boolean\n  batchedTransactionIds: string[]\n}\n\nexport interface UnverifiedDocumentRevision {\n  transactionId: string\n  documentId: string\n  previousRev: string | undefined\n  timestamp: string\n}\n\nexport function queueTransaction(\n  prev: SyncTransactionState,\n  transaction: QueuedTransaction,\n): SyncTransactionState {\n  const {transactionId, actions} = transaction\n  const prevWithSubscriptionIds = getDocumentIdsFromActions(actions).reduce(\n    (acc, id) => addSubscriptionIdToDocument(acc, id, transactionId),\n    prev,\n  )\n\n  return {\n    ...prevWithSubscriptionIds,\n    queued: [...prev.queued, transaction],\n  }\n}\n\nexport function removeQueuedTransaction(\n  prev: SyncTransactionState,\n  transactionId: string,\n): SyncTransactionState {\n  const transaction = prev.queued.find((t) => t.transactionId === transactionId)\n  if (!transaction) return prev\n\n  const prevWithSubscriptionIds = getDocumentIdsFromActions(transaction.actions).reduce(\n    (acc, id) => removeSubscriptionIdFromDocument(acc, id, transactionId),\n    prev,\n  )\n\n  return {\n    ...prevWithSubscriptionIds,\n    queued: prev.queued.filter((t) => transactionId !== t.transactionId),\n  }\n}\n\nexport function applyFirstQueuedTransaction(prev: SyncTransactionState): SyncTransactionState {\n  const queued = prev.queued.at(0)\n  if (!queued) return prev\n  if (!prev.grants) return prev\n\n  const ids = getDocumentIdsFromActions(queued.actions)\n  // the local value is only ever `undefined` if it has not been loaded yet\n  // we can't get the next applied state unless all relevant documents are ready\n  if (ids.some((id) => prev.documentStates[id]?.local === undefined)) return prev\n\n  const working = ids.reduce<DocumentSet>((acc, id) => {\n    acc[id] = prev.documentStates[id]?.local\n    return acc\n  }, {})\n\n  const timestamp = new Date().toISOString()\n\n  const result = processActions({\n    ...queued,\n    working,\n    base: working,\n    timestamp,\n    grants: prev.grants,\n  })\n  const applied: AppliedTransaction = {\n    ...queued,\n    ...result,\n    base: result.previous,\n    timestamp,\n  }\n\n  return {\n    ...prev,\n    applied: [...prev.applied, applied],\n    queued: prev.queued.filter((t) => t.transactionId !== queued.transactionId),\n    documentStates: Object.entries(result.working).reduce(\n      (acc, [id, next]) => {\n        const prevDoc = acc[id]\n        if (!prevDoc) return acc\n        acc[id] = {...prevDoc, local: next}\n        return acc\n      },\n      {...prev.documentStates},\n    ),\n  }\n}\n\nexport function batchAppliedTransactions([curr, ...rest]: AppliedTransaction[]):\n  | OutgoingTransaction\n  | undefined {\n  // No transactions? Nothing to batch.\n  if (!curr) return undefined\n\n  // Skip transactions with no actions.\n  if (!curr.actions.length) return batchAppliedTransactions(rest)\n\n  // If there are multiple actions, we cannot batch further.\n  if (curr.actions.length > 1) {\n    return {\n      ...curr,\n      disableBatching: true,\n      batchedTransactionIds: [curr.transactionId],\n    }\n  }\n\n  const [action] = curr.actions\n\n  // If the single action isn't a document.edit or batching is disabled,\n  // mark this transaction as non-batchable.\n  if (action.type !== 'document.edit' || curr.disableBatching) {\n    return {\n      ...curr,\n      disableBatching: true,\n      batchedTransactionIds: [curr.transactionId],\n    }\n  }\n\n  // Create an outgoing transaction for the single edit action.\n  // At this point, batching is allowed.\n  const editAction: OutgoingTransaction = {\n    ...curr,\n    actions: [action],\n    disableBatching: false,\n    batchedTransactionIds: [curr.transactionId],\n  }\n  if (!rest.length) return editAction\n\n  const next = batchAppliedTransactions(rest)\n  if (!next) return undefined\n  if (next.disableBatching) return editAction\n\n  return {\n    disableBatching: false,\n    // Use the transactionId from the later (next) transaction.\n    transactionId: next.transactionId,\n    // Accumulate actions: current action first, then later ones.\n    actions: [action, ...next.actions],\n    // Merge outgoingActions in order.\n    outgoingActions: [...curr.outgoingActions, ...next.outgoingActions],\n    // Batched transaction IDs: preserve order by placing curr first.\n    batchedTransactionIds: [curr.transactionId, ...next.batchedTransactionIds],\n    // Merge outgoingMutations in order.\n    outgoingMutations: [...curr.outgoingMutations, ...next.outgoingMutations],\n    // Working state reflects the latest optimistic changes: later transactions override earlier.\n    working: {...curr.working, ...next.working},\n    // Base state (base, previous, previousRevs) must reflect the original state.\n    // Use curr values (the earliest transaction) to override later ones.\n    previousRevs: {...next.previousRevs, ...curr.previousRevs},\n    previous: {...next.previous, ...curr.previous},\n    base: {...next.base, ...curr.base},\n    // Use the earliest timestamp from curr.\n    timestamp: curr.timestamp ?? next.timestamp,\n  }\n}\n\nexport function transitionAppliedTransactionsToOutgoing(\n  prev: SyncTransactionState,\n): SyncTransactionState {\n  if (prev.outgoing) return prev\n\n  const transaction = batchAppliedTransactions(prev.applied)\n  if (!transaction) return prev\n\n  const {\n    transactionId,\n    previousRevs,\n    working,\n    batchedTransactionIds: consumedTransactions,\n  } = transaction\n  const timestamp = new Date().toISOString()\n\n  return {\n    ...prev,\n    outgoing: transaction,\n    applied: prev.applied.filter((i) => !consumedTransactions.includes(i.transactionId)),\n    documentStates: Object.entries(previousRevs).reduce(\n      (acc, [documentId, previousRev]) => {\n        if (working[documentId]?._rev === previousRev) return acc\n\n        const documentState = prev.documentStates[documentId]\n        if (!documentState) return acc\n\n        acc[documentId] = {\n          ...documentState,\n          unverifiedRevisions: {\n            ...documentState.unverifiedRevisions,\n            // add unverified revision\n            [transactionId]: {documentId, previousRev, transactionId, timestamp},\n          },\n        }\n\n        return acc\n      },\n      {...prev.documentStates},\n    ),\n  }\n}\n\nexport function cleanupOutgoingTransaction(prev: SyncTransactionState): SyncTransactionState {\n  const {outgoing} = prev\n  if (!outgoing) return prev\n\n  let next = prev\n  const ids = getDocumentIdsFromActions(outgoing.actions)\n  for (const transactionId of outgoing.batchedTransactionIds) {\n    for (const documentId of ids) {\n      next = removeSubscriptionIdFromDocument(next, documentId, transactionId)\n    }\n  }\n\n  return {...next, outgoing: undefined}\n}\n\nexport function revertOutgoingTransaction(prev: SyncTransactionState): SyncTransactionState {\n  if (!prev.grants) return prev\n  let working = Object.fromEntries(\n    Object.entries(prev.documentStates).map(([documentId, documentState]) => [\n      documentId,\n      documentState?.remote,\n    ]),\n  )\n  const nextApplied: AppliedTransaction[] = []\n\n  for (const t of prev.applied) {\n    try {\n      const next = processActions({...t, working, grants: prev.grants})\n      working = next.working\n      nextApplied.push({...t, ...next})\n    } catch (error) {\n      // if we're already reverting a transaction, skip any applied actions if\n      // they throw while we rebuild the state\n      if (error instanceof ActionError) continue\n      throw error\n    }\n  }\n\n  return {\n    ...prev,\n    applied: nextApplied,\n    outgoing: undefined,\n    documentStates: Object.fromEntries(\n      Object.entries(prev.documentStates)\n        .filter((e): e is [string, DocumentState] => !!e[1])\n        .map(([documentId, {unverifiedRevisions = {}, local, ...documentState}]) => {\n          const next: DocumentState = {\n            ...documentState,\n            local: documentId in working ? working[documentId] : local,\n            unverifiedRevisions:\n              prev.outgoing && prev.outgoing.transactionId in unverifiedRevisions\n                ? omit(unverifiedRevisions, prev.outgoing.transactionId)\n                : unverifiedRevisions,\n          }\n          return [documentId, next] as const\n        }),\n    ),\n  }\n}\n\nexport function applyRemoteDocument(\n  prev: SyncTransactionState,\n  {document, documentId, previousRev, revision, timestamp, type}: RemoteDocument,\n  events: DocumentStoreState['events'],\n): SyncTransactionState {\n  if (!prev.grants) return prev\n  const prevDocState = prev.documentStates[documentId]\n\n  // document state is deleted when there are no more subscribers so we can\n  // simply skip if there is no state\n  if (!prevDocState) return prev\n\n  // we send out transactions with IDs generated client-side to identify them\n  // when they are observed through the listener. here we can check if this\n  // incoming remote document is the result of one of our transactions\n  const prevUnverifiedRevisions = prevDocState.unverifiedRevisions\n  const revisionToVerify = revision ? prevUnverifiedRevisions?.[revision] : undefined\n  let unverifiedRevisions = prevUnverifiedRevisions ?? EMPTY_REVISIONS\n  if (revision && revisionToVerify) {\n    unverifiedRevisions = omit(prevUnverifiedRevisions, revision)\n  }\n\n  // if this remote document is from a `'sync'` event (meaning that the whole\n  // thing was just fetched and not re-created from mutations)\n  if (type === 'sync') {\n    // then remove unverified revisions that are older than our sync time. we\n    // don't need to verify them for a rebase any more because we synced and\n    // grabbed the latest document\n    unverifiedRevisions = Object.fromEntries(\n      Object.entries(unverifiedRevisions).filter(([, unverifiedRevision]) => {\n        if (!unverifiedRevision) return false\n        return new Date(timestamp).getTime() <= new Date(unverifiedRevision.timestamp).getTime()\n      }),\n    )\n  }\n\n  // if there is a revision to verify and the previous revision from remote\n  // matches the previous revision we expected, we can \"fast-forward\" and skip\n  // rebasing local changes on top of this new base\n  if (revisionToVerify && revisionToVerify.previousRev === previousRev) {\n    return {\n      ...prev,\n      documentStates: {\n        ...prev.documentStates,\n        [documentId]: {\n          ...prevDocState,\n          remote: document,\n          remoteRev: revision,\n          unverifiedRevisions,\n        },\n      },\n    }\n  }\n\n  // if we got this far, this means that we could not fast-forward this revision\n  // for this document. now we can rebase our local changes (if any) on top of\n  // this new base from remote. in order to do that we grab the set of documents\n  // captured before the earliest local transaction\n  const previous = prev.applied.at(0)?.previous\n  // our initial working set now is the state of the documents before any of our\n  // local transactions plus the newly updated document from remote\n  let working = {...previous, [documentId]: document}\n  const nextApplied: AppliedTransaction[] = []\n\n  // now we can iterate through our applied (but not yet committed) transactions\n  // starting with the updated working set and re-apply each transaction in\n  // order creating a new set of applied transactions as we go.\n  //\n  // NOTE: we don't want to rebase over the outgoing transaction because that\n  // transaction is already on its way to the server. if an outgoing transaction\n  // needs to be rebased, then it eventually will be when we see that\n  // transaction again through the listener and this same flow will run then\n  for (const curr of prev.applied) {\n    try {\n      const next = processActions({...curr, working, grants: prev.grants})\n      working = next.working\n      // next includes an updated `previous` set and `working` set and updates\n      // the `outgoingAction` and `outgoingMutations`. the `base` set from the\n      // original applied transaction gets put back into the updated transaction\n      // as-is to preserve the intended base for a 3-way merge\n      nextApplied.push({...curr, ...next})\n    } catch (error) {\n      // if processing the action ever throws a related error, we can skip this\n      // local transaction and report the error to the user\n      if (error instanceof ActionError) {\n        events.next({\n          type: 'rebase-error',\n          transactionId: error.transactionId,\n          documentId: error.documentId,\n          message: error.message,\n          error,\n        })\n        continue\n      }\n      throw error\n    }\n  }\n\n  return {\n    ...prev,\n    applied: nextApplied,\n    documentStates: {\n      ...prev.documentStates,\n      [documentId]: {\n        ...prevDocState,\n        remote: document,\n        remoteRev: revision,\n        local: working[documentId],\n        unverifiedRevisions,\n      },\n    },\n  }\n}\n\nexport function addSubscriptionIdToDocument(\n  prev: SyncTransactionState,\n  documentId: string,\n  subscriptionId: string,\n): SyncTransactionState {\n  const prevDocState = prev.documentStates?.[documentId]\n  const prevSubscriptions = prevDocState?.subscriptions ?? []\n\n  return {\n    ...prev,\n    documentStates: {\n      ...prev.documentStates,\n      [documentId]: {\n        ...prevDocState,\n        id: documentId,\n        subscriptions: [...prevSubscriptions, subscriptionId],\n      },\n    },\n  }\n}\n\nexport function removeSubscriptionIdFromDocument(\n  prev: SyncTransactionState,\n  documentId: string,\n  subscriptionId: string,\n): SyncTransactionState {\n  const prevDocState = prev.documentStates?.[documentId]\n  const prevSubscriptions = prevDocState?.subscriptions ?? []\n  const subscriptions = prevSubscriptions.filter((id) => id !== subscriptionId)\n\n  if (!prevDocState) return prev\n  if (!subscriptions.length) {\n    return {...prev, documentStates: omit(prev.documentStates, documentId)}\n  }\n  return {\n    ...prev,\n    documentStates: {\n      ...prev.documentStates,\n      [documentId]: {...prevDocState, subscriptions: subscriptions},\n    },\n  }\n}\n\nexport function manageSubscriberIds(\n  {state}: StoreContext<SyncTransactionState>,\n  documentId: string | string[],\n): () => void {\n  const documentIds = Array.from(\n    new Set(\n      (Array.isArray(documentId) ? documentId : [documentId]).flatMap((id) => [\n        getPublishedId(id),\n        getDraftId(id),\n      ]),\n    ),\n  )\n  const subscriptionId = insecureRandomId()\n  state.set('addSubscribers', (prev) =>\n    documentIds.reduce(\n      (acc, id) => addSubscriptionIdToDocument(acc, id, subscriptionId),\n      prev as SyncTransactionState,\n    ),\n  )\n\n  return () => {\n    setTimeout(() => {\n      state.set('removeSubscribers', (prev) =>\n        documentIds.reduce(\n          (acc, id) => removeSubscriptionIdFromDocument(acc, id, subscriptionId),\n          prev as SyncTransactionState,\n        ),\n      )\n    }, DOCUMENT_STATE_CLEAR_DELAY)\n  }\n}\n\nexport function getDocumentIdsFromActions(action: DocumentAction | DocumentAction[]): string[] {\n  const actions = Array.isArray(action) ? action : [action]\n  return Array.from(\n    new Set(\n      actions\n        .map((i) => i.documentId)\n        .filter((i) => typeof i === 'string')\n        .flatMap((documentId) => [getPublishedId(documentId), getDraftId(documentId)]),\n    ),\n  )\n}\n","import {type SanityClient} from '@sanity/client'\n\nimport {type DocumentAction} from './actions'\nimport {type OutgoingTransaction} from './reducers'\n\n/** @beta */\nexport type DocumentEvent =\n  | ActionErrorEvent\n  | TransactionRevertedEvent\n  | TransactionAcceptedEvent\n  | DocumentRebaseErrorEvent\n  | DocumentEditedEvent\n  | DocumentCreatedEvent\n  | DocumentDeletedEvent\n  | DocumentPublishedEvent\n  | DocumentUnpublishedEvent\n  | DocumentDiscardedEvent\n\n/**\n * @beta\n * Event emitted when a precondition to applying an action fails.\n * (For example: when trying to edit a document that no longer exists.)\n */\nexport interface ActionErrorEvent {\n  type: 'error'\n  documentId: string\n  transactionId: string\n  message: string\n  error: unknown\n}\n/**\n * @beta\n * Event emitted when a transaction is accepted.\n */\nexport interface TransactionAcceptedEvent {\n  type: 'accepted'\n  outgoing: OutgoingTransaction\n  result: Awaited<ReturnType<SanityClient['action']>>\n}\n/**\n * @beta\n * Event emitted when a transaction is reverted.\n */\nexport interface TransactionRevertedEvent {\n  type: 'reverted'\n  message: string\n  error: unknown\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when an attempt to apply local changes to a modified remote document fails.\n */\nexport interface DocumentRebaseErrorEvent {\n  type: 'rebase-error'\n  documentId: string\n  transactionId: string\n  message: string\n  error: unknown\n}\n/**\n * @beta\n * Event emitted when a document is edited.\n */\nexport interface DocumentEditedEvent {\n  type: 'edited'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when a document is created.\n */\nexport interface DocumentCreatedEvent {\n  type: 'created'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when a document is deleted.\n */\nexport interface DocumentDeletedEvent {\n  type: 'deleted'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when a document is published.\n */\nexport interface DocumentPublishedEvent {\n  type: 'published'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when a document is unpublished.\n */\nexport interface DocumentUnpublishedEvent {\n  type: 'unpublished'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n/**\n * @beta\n * Event emitted when a document version is discarded.\n */\nexport interface DocumentDiscardedEvent {\n  type: 'discarded'\n  documentId: string\n  outgoing: OutgoingTransaction\n}\n\nexport function getDocumentEvents(outgoing: OutgoingTransaction): DocumentEvent[] {\n  const documentIdsByAction = Object.entries(\n    outgoing.actions.reduce(\n      (acc, {type, documentId}) => {\n        const ids = acc[type] || new Set()\n        if (documentId) ids.add(documentId)\n        acc[type] = ids\n        return acc\n      },\n      {} as Record<DocumentAction['type'], Set<string>>,\n    ),\n  ) as [DocumentAction['type'], Set<string>][]\n\n  const actionMap = {\n    'document.create': 'created',\n    'document.delete': 'deleted',\n    'document.discard': 'discarded',\n    'document.edit': 'edited',\n    'document.publish': 'published',\n    'document.unpublish': 'unpublished',\n  } satisfies Record<DocumentAction['type'], DocumentEvent['type']>\n\n  return documentIdsByAction.flatMap(([actionType, documentIds]) =>\n    Array.from(documentIds).map(\n      (documentId): DocumentEvent => ({type: actionMap[actionType], documentId, outgoing}),\n    ),\n  )\n}\n","import {type ListenEvent, type SanityDocument} from '@sanity/client'\nimport {createDocumentLoaderFromClient} from '@sanity/mutate/_unstable_store'\nimport {\n  first,\n  map,\n  merge,\n  Observable,\n  partition,\n  share,\n  shareReplay,\n  Subject,\n  switchMap,\n  takeUntil,\n} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {type SanityInstance} from '../store/createSanityInstance'\n\nconst API_VERSION = 'vX'\n\nexport interface SharedListener {\n  events: Observable<ListenEvent<SanityDocument>>\n  dispose: () => void\n}\n\nexport function createSharedListener(instance: SanityInstance): SharedListener {\n  const dispose$ = new Subject<void>()\n  const events$ = getClientState(instance, {\n    apiVersion: API_VERSION,\n  }).observable.pipe(\n    switchMap((client) =>\n      // TODO: it seems like the client.listen method is not emitting disconnected\n      // events. this is important to ensure we have an up to date version of the\n      // doc. probably should introduce our own events for when the user goes offline\n      client.listen(\n        '*',\n        {},\n        {\n          events: ['mutation', 'welcome', 'reconnect'],\n          includeResult: false,\n          tag: 'document-listener',\n          // // from manual testing, it seems like mendoza patches may be\n          // // causing some ambiguity/wonkiness\n          // includeMutations: false,\n          // effectFormat: 'mendoza',\n        },\n      ),\n    ),\n    takeUntil(dispose$),\n    share(),\n  )\n\n  const [welcome$, mutation$] = partition(events$, (e) => e.type === 'welcome')\n\n  return {\n    events: merge(\n      // we replay the welcome event because that event kicks off fetching the document\n      welcome$.pipe(shareReplay(1)),\n      mutation$,\n    ),\n    dispose: () => dispose$.next(),\n  }\n}\n\nexport function createFetchDocument(instance: SanityInstance) {\n  return function (documentId: string): Observable<SanityDocument | null> {\n    return getClientState(instance, {apiVersion: API_VERSION}).observable.pipe(\n      switchMap((client) => {\n        const loadDocument = createDocumentLoaderFromClient(client)\n        return loadDocument(documentId)\n      }),\n      map((result) => {\n        if (!result.accessible) {\n          if (result.reason === 'existence') return null\n          throw new Error(`Document with ID \\`${documentId}\\` is inaccessible due to permissions.`)\n        }\n        return result.document as SanityDocument\n      }),\n      first(),\n    )\n  }\n}\n","import {type Action} from '@sanity/client'\nimport {getPublishedId} from '@sanity/client/csm'\nimport {type SanityDocument} from '@sanity/types'\nimport {type ExprNode} from 'groq-js'\nimport {\n  catchError,\n  concatMap,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  first,\n  firstValueFrom,\n  groupBy,\n  map,\n  mergeMap,\n  Observable,\n  of,\n  pairwise,\n  startWith,\n  Subject,\n  switchMap,\n  tap,\n  throttle,\n  timer,\n  withLatestFrom,\n} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {type DocumentHandle} from '../config/sanityConfig'\nimport {bindActionByDataset, type StoreAction} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {createStateSourceAction, type StateSource} from '../store/createStateSourceAction'\nimport {defineStore, type StoreContext} from '../store/defineStore'\nimport {getDraftId} from '../utils/ids'\nimport {type DocumentAction} from './actions'\nimport {API_VERSION, INITIAL_OUTGOING_THROTTLE_TIME} from './documentConstants'\nimport {type DocumentEvent, getDocumentEvents} from './events'\nimport {listen, OutOfSyncError} from './listen'\nimport {type JsonMatch, jsonMatch, type JsonMatchPath} from './patchOperations'\nimport {calculatePermissions, createGrantsLookup, type DatasetAcl, type Grant} from './permissions'\nimport {ActionError} from './processActions'\nimport {\n  type AppliedTransaction,\n  applyFirstQueuedTransaction,\n  applyRemoteDocument,\n  cleanupOutgoingTransaction,\n  getDocumentIdsFromActions,\n  manageSubscriberIds,\n  type OutgoingTransaction,\n  type QueuedTransaction,\n  removeQueuedTransaction,\n  revertOutgoingTransaction,\n  transitionAppliedTransactionsToOutgoing,\n  type UnverifiedDocumentRevision,\n} from './reducers'\nimport {createFetchDocument, createSharedListener, type SharedListener} from './sharedListener'\n\nexport interface DocumentStoreState {\n  documentStates: {[TDocumentId in string]?: DocumentState}\n  queued: QueuedTransaction[]\n  applied: AppliedTransaction[]\n  outgoing?: OutgoingTransaction\n  grants?: Record<Grant, ExprNode>\n  error?: unknown\n  sharedListener: SharedListener\n  fetchDocument: (documentId: string) => Observable<SanityDocument | null>\n  events: Subject<DocumentEvent>\n}\n\nexport interface DocumentState {\n  id: string\n  /**\n   * the \"remote\" local copy that matches the server. represents the last known\n   * server state. this gets updated every time we confirm remote patches\n   */\n  remote?: SanityDocument | null\n  /**\n   * the current ephemeral working copy that includes local optimistic changes\n   * that have not yet been confirmed by the server\n   */\n  local?: SanityDocument | null\n  /**\n   * the revision that our remote document is at\n   */\n  remoteRev?: string | null\n  /**\n   * Array of subscription IDs. This document state will be deleted if there are\n   * no subscribers.\n   */\n  subscriptions: string[]\n  /**\n   * An object keyed by transaction ID of revisions sent out but that have not\n   * yet been verified yet. When an applied transaction is transitioned to an\n   * outgoing transaction, it also adds unverified revisions for each document\n   * that is part of that outgoing transaction. Transactions are submitted to\n   * the server with a locally generated transaction ID. This way we can observe\n   * when our transaction comes back through the shared listener. Each listener\n   * event that comes back contains a `previousRev`. If we see our own\n   * transaction with a different `previousRev` than expected, we can rebase our\n   * local transactions on top of this new remote.\n   */\n  unverifiedRevisions?: {[TTransactionId in string]?: UnverifiedDocumentRevision}\n}\n\nexport const documentStore = defineStore<DocumentStoreState>({\n  name: 'Document',\n  getInitialState: (instance) => ({\n    documentStates: {},\n    // these can be emptied on refetch\n    queued: [],\n    applied: [],\n    sharedListener: createSharedListener(instance),\n    fetchDocument: createFetchDocument(instance),\n    events: new Subject(),\n  }),\n  initialize(context) {\n    const {sharedListener} = context.state.get()\n    const subscriptions = [\n      subscribeToQueuedAndApplyNextTransaction(context),\n      subscribeToSubscriptionsAndListenToDocuments(context),\n      subscribeToAppliedAndSubmitNextTransaction(context),\n      subscribeToClientAndFetchDatasetAcl(context),\n    ]\n\n    return () => {\n      sharedListener.dispose()\n      subscriptions.forEach((subscription) => subscription.unsubscribe())\n    }\n  },\n})\n\n/** @beta */\nexport function getDocumentState<\n  TDocument extends SanityDocument,\n  TPath extends JsonMatchPath<TDocument>,\n>(\n  instance: SanityInstance,\n  doc: string | DocumentHandle<TDocument>,\n  path: TPath,\n): StateSource<JsonMatch<TDocument, TPath> | undefined>\n/** @beta */\nexport function getDocumentState<TDocument extends SanityDocument>(\n  instance: SanityInstance,\n  doc: string | DocumentHandle<TDocument>,\n): StateSource<TDocument | null>\n/** @beta */\nexport function getDocumentState(\n  instance: SanityInstance,\n  doc: string | DocumentHandle,\n  path?: string,\n): StateSource<unknown>\n/** @beta */\nexport function getDocumentState(\n  ...args: Parameters<typeof _getDocumentState>\n): StateSource<unknown> {\n  return _getDocumentState(...args)\n}\nconst _getDocumentState = bindActionByDataset(\n  documentStore,\n  createStateSourceAction({\n    selector: ({state: {error, documentStates}}, doc: string | DocumentHandle, path?: string) => {\n      const documentId = typeof doc === 'string' ? doc : doc.documentId\n      if (error) throw error\n      const draftId = getDraftId(documentId)\n      const publishedId = getPublishedId(documentId)\n      const draft = documentStates[draftId]?.local\n      const published = documentStates[publishedId]?.local\n\n      const document = draft ?? published\n      if (document === undefined) return undefined\n      if (path) return jsonMatch(document, path).at(0)?.value\n      return document\n    },\n    onSubscribe: (context, doc: string | DocumentHandle) =>\n      manageSubscriberIds(context, typeof doc === 'string' ? doc : doc.documentId),\n  }),\n)\n\n/** @beta */\nexport function resolveDocument<TDocument extends SanityDocument>(\n  instance: SanityInstance,\n  doc: string | DocumentHandle<TDocument>,\n): Promise<TDocument | null>\n/** @beta */\nexport function resolveDocument(\n  instance: SanityInstance,\n  doc: string | DocumentHandle,\n): Promise<SanityDocument | null>\n/** @beta */\nexport function resolveDocument(\n  ...args: Parameters<typeof _resolveDocument>\n): Promise<SanityDocument | null> {\n  return _resolveDocument(...args)\n}\nconst _resolveDocument = bindActionByDataset(\n  documentStore,\n  ({instance}, doc: string | DocumentHandle) => {\n    const documentId = typeof doc === 'string' ? doc : doc.documentId\n    return firstValueFrom(\n      getDocumentState(instance, documentId).observable.pipe(filter((i) => i !== undefined)),\n    )\n  },\n)\n\n/** @beta */\nexport const getDocumentSyncStatus = bindActionByDataset(\n  documentStore,\n  createStateSourceAction({\n    selector: (\n      {state: {error, documentStates: documents, outgoing, applied, queued}},\n      doc: DocumentHandle,\n    ) => {\n      const documentId = typeof doc === 'string' ? doc : doc.documentId\n      if (error) throw error\n      const draftId = getDraftId(documentId)\n      const publishedId = getPublishedId(documentId)\n\n      const draft = documents[draftId]\n      const published = documents[publishedId]\n\n      if (draft === undefined || published === undefined) return undefined\n      return !queued.length && !applied.length && !outgoing\n    },\n    onSubscribe: (context, doc: DocumentHandle) => manageSubscriberIds(context, doc.documentId),\n  }),\n)\n\n/** @beta */\nexport const getPermissionsState = bindActionByDataset(\n  documentStore,\n  createStateSourceAction({\n    selector: calculatePermissions,\n    onSubscribe: (context, actions) =>\n      manageSubscriberIds(context, getDocumentIdsFromActions(actions)),\n  }) as StoreAction<\n    DocumentStoreState,\n    [DocumentAction | DocumentAction[]],\n    StateSource<ReturnType<typeof calculatePermissions>>\n  >,\n)\n\n/** @beta */\nexport const resolvePermissions = bindActionByDataset(\n  documentStore,\n  ({instance}, actions: DocumentAction | DocumentAction[]) => {\n    return firstValueFrom(\n      getPermissionsState(instance, actions).observable.pipe(filter((i) => i !== undefined)),\n    )\n  },\n)\n\n/** @beta */\nexport const subscribeDocumentEvents = bindActionByDataset(\n  documentStore,\n  ({state}, eventHandler: (e: DocumentEvent) => void) => {\n    const {events} = state.get()\n    const subscription = events.subscribe(eventHandler)\n    return () => subscription.unsubscribe()\n  },\n)\n\nconst subscribeToQueuedAndApplyNextTransaction = ({state}: StoreContext<DocumentStoreState>) => {\n  const {events} = state.get()\n  return state.observable\n    .pipe(\n      map(applyFirstQueuedTransaction),\n      distinctUntilChanged(),\n      tap((next) => state.set('applyFirstQueuedTransaction', next)),\n      catchError((error, caught) => {\n        if (error instanceof ActionError) {\n          state.set('removeQueuedTransaction', (prev) =>\n            removeQueuedTransaction(prev, error.transactionId),\n          )\n          events.next({\n            type: 'error',\n            message: error.message,\n            documentId: error.documentId,\n            transactionId: error.transactionId,\n            error,\n          })\n          return caught\n        }\n\n        throw error\n      }),\n    )\n    .subscribe({error: (error) => state.set('setError', {error})})\n}\n\nconst subscribeToAppliedAndSubmitNextTransaction = ({\n  state,\n  instance,\n}: StoreContext<DocumentStoreState>) => {\n  const {events} = state.get()\n\n  return state.observable\n    .pipe(\n      throttle(\n        (s) =>\n          // if there is no outgoing transaction, we can throttle by the\n          // initial outgoing throttle time\n          !s.outgoing\n            ? timer(INITIAL_OUTGOING_THROTTLE_TIME)\n            : // otherwise, wait until the outgoing has been cleared\n              state.observable.pipe(first(({outgoing}) => !outgoing)),\n        {leading: false, trailing: true},\n      ),\n      map(transitionAppliedTransactionsToOutgoing),\n      distinctUntilChanged((a, b) => a.outgoing?.transactionId === b.outgoing?.transactionId),\n      tap((next) => state.set('transitionAppliedTransactionsToOutgoing', next)),\n      map((s) => s.outgoing),\n      distinctUntilChanged(),\n      withLatestFrom(getClientState(instance, {apiVersion: API_VERSION}).observable),\n      concatMap(([outgoing, client]) => {\n        if (!outgoing) return EMPTY\n        return client.observable\n          .action(outgoing.outgoingActions as Action[], {\n            transactionId: outgoing.transactionId,\n            skipCrossDatasetReferenceValidation: true,\n          })\n          .pipe(\n            catchError((error) => {\n              state.set('revertOutgoingTransaction', revertOutgoingTransaction)\n              events.next({type: 'reverted', message: error.message, outgoing, error})\n              return EMPTY\n            }),\n            map((result) => ({result, outgoing})),\n          )\n      }),\n      tap(({outgoing, result}) => {\n        state.set('cleanupOutgoingTransaction', cleanupOutgoingTransaction)\n        for (const e of getDocumentEvents(outgoing)) events.next(e)\n        events.next({type: 'accepted', outgoing, result})\n      }),\n    )\n    .subscribe({error: (error) => state.set('setError', {error})})\n}\n\nconst subscribeToSubscriptionsAndListenToDocuments = (\n  context: StoreContext<DocumentStoreState>,\n) => {\n  const {state} = context\n  const {events} = state.get()\n\n  return state.observable\n    .pipe(\n      filter((s) => !!s.grants),\n      map((s) => Object.keys(s.documentStates)),\n      distinctUntilChanged((curr, next) => {\n        if (curr.length !== next.length) return false\n        const currSet = new Set(curr)\n        return next.every((i) => currSet.has(i))\n      }),\n      startWith(new Set<string>()),\n      pairwise(),\n      switchMap((pair) => {\n        const [curr, next] = pair.map((ids) => new Set(ids))\n        const added = Array.from(next).filter((i) => !curr.has(i))\n        const removed = Array.from(curr).filter((i) => !next.has(i))\n\n        // NOTE: the order of which these go out is somewhat important\n        // because that determines the order `applyRemoteDocument` is called\n        // which in turn determines which document version get populated\n        // first. because we prefer drafts, it's better to have those go out\n        // first so that the published document doesn't flash for a frame\n        const changes = [\n          ...added.map((id) => ({id, add: true})),\n          ...removed.map((id) => ({id, add: false})),\n        ].sort((a, b) => {\n          const aIsDraft = a.id === getDraftId(a.id)\n          const bIsDraft = b.id === getDraftId(b.id)\n\n          if (aIsDraft && bIsDraft) return a.id.localeCompare(b.id, 'en-US')\n          if (aIsDraft) return -1\n          if (bIsDraft) return 1\n          return a.id.localeCompare(b.id, 'en-US')\n        })\n\n        return of<{id: string; add: boolean}[]>(...changes)\n      }),\n      groupBy((i) => i.id),\n      mergeMap((group) =>\n        group.pipe(\n          switchMap((e) => {\n            if (!e.add) return EMPTY\n            return listen(context, e.id).pipe(\n              catchError((error) => {\n                // retry on `OutOfSyncError`\n                if (error instanceof OutOfSyncError) listen(context, e.id)\n                throw error\n              }),\n              tap((remote) =>\n                state.set('applyRemoteDocument', (prev) =>\n                  applyRemoteDocument(prev, remote, events),\n                ),\n              ),\n            )\n          }),\n        ),\n      ),\n    )\n    .subscribe({error: (error) => state.set('setError', {error})})\n}\n\nconst subscribeToClientAndFetchDatasetAcl = ({\n  instance,\n  state,\n}: StoreContext<DocumentStoreState>) => {\n  const {projectId, dataset} = instance.config\n  return getClientState(instance, {apiVersion: API_VERSION})\n    .observable.pipe(\n      switchMap((client) =>\n        client.observable.request<DatasetAcl>({\n          uri: `/projects/${projectId}/datasets/${dataset}/acl`,\n          tag: 'acl.get',\n          withCredentials: true,\n        }),\n      ),\n      tap((datasetAcl) => state.set('setGrants', {grants: createGrantsLookup(datasetAcl)})),\n    )\n    .subscribe({\n      error: (error) => state.set('setError', {error}),\n    })\n}\n","import {type SanityClient} from '@sanity/client'\nimport {type SanityDocument} from '@sanity/types'\nimport {distinctUntilChanged, filter, first, firstValueFrom, map, race} from 'rxjs'\n\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {type StoreContext} from '../store/defineStore'\nimport {type DocumentAction} from './actions'\nimport {documentStore, type DocumentStoreState} from './documentStore'\nimport {type DocumentSet} from './processMutations'\nimport {type AppliedTransaction, type QueuedTransaction, queueTransaction} from './reducers'\n\n/** @beta */\nexport interface ActionsResult<TDocument extends SanityDocument = SanityDocument> {\n  transactionId: string\n  documents: DocumentSet<TDocument>\n  previous: DocumentSet<TDocument>\n  previousRevs: {[documentId: string]: string | undefined}\n  appeared: string[]\n  updated: string[]\n  disappeared: string[]\n  submitted: () => ReturnType<SanityClient['action']>\n}\n\n/** @beta */\nexport interface ApplyDocumentActionsOptions {\n  /**\n   * Optionally provide an ID to be used as this transaction ID\n   */\n  transactionId?: string\n  /**\n   * Set this to true to prevent this action from being batched with others.\n   */\n  disableBatching?: boolean\n}\n\n/** @beta */\nexport function applyDocumentActions<TDocument extends SanityDocument>(\n  instance: SanityInstance,\n  action: DocumentAction<TDocument> | DocumentAction<TDocument>[],\n  options?: ApplyDocumentActionsOptions,\n): Promise<ActionsResult<TDocument>>\n/** @beta */\nexport function applyDocumentActions(\n  instance: SanityInstance,\n  action: DocumentAction | DocumentAction[],\n  options?: ApplyDocumentActionsOptions,\n): Promise<ActionsResult>\n/** @beta */\nexport function applyDocumentActions(\n  ...args: Parameters<typeof boundApplyDocumentActions>\n): ReturnType<typeof boundApplyDocumentActions> {\n  return boundApplyDocumentActions(...args)\n}\n\nconst boundApplyDocumentActions = bindActionByDataset(documentStore, _applyDocumentActions)\n\n/** @internal */\nasync function _applyDocumentActions(\n  {instance, state}: StoreContext<DocumentStoreState>,\n  actionOrActions: DocumentAction | DocumentAction[],\n  {transactionId = crypto.randomUUID(), disableBatching}: ApplyDocumentActionsOptions = {},\n): Promise<ActionsResult> {\n  const actions = Array.isArray(actionOrActions) ? actionOrActions : [actionOrActions]\n\n  let projectId\n  let dataset\n  for (const action of actions) {\n    if (action.projectId) {\n      if (!projectId) projectId = action.projectId\n      if (action.projectId !== projectId) {\n        throw new Error(\n          `Mismatched project IDs found in actions. All actions must belong to the same project. Found \"${action.projectId}\" but expected \"${projectId}\".`,\n        )\n      }\n\n      if (action.dataset) {\n        if (!dataset) dataset = action.dataset\n        if (action.dataset !== dataset) {\n          throw new Error(\n            `Mismatched datasets found in actions. All actions must belong to the same dataset. Found \"${action.dataset}\" but expected \"${dataset}\".`,\n          )\n        }\n      }\n    }\n  }\n\n  if (\n    (projectId && projectId !== instance.config.projectId) ||\n    (dataset && dataset !== instance.config.dataset)\n  ) {\n    const matchedInstance = instance.match({projectId, dataset})\n    if (!matchedInstance) {\n      throw new Error(\n        `Could not find a matching instance for projectId: \"${projectId}\" and dataset: \"${dataset}\"`,\n      )\n    }\n    return boundApplyDocumentActions(matchedInstance, actionOrActions, {\n      disableBatching,\n      transactionId,\n    })\n  }\n\n  const {events} = state.get()\n\n  const transaction: QueuedTransaction = {\n    transactionId,\n    actions,\n    ...(disableBatching && {disableBatching}),\n  }\n\n  const fatalError$ = state.observable.pipe(\n    map((s) => s.error),\n    first(Boolean),\n    map((error) => ({type: 'error', error}) as const),\n  )\n\n  const transactionError$ = events.pipe(\n    filter((e) => e.type === 'error'),\n    first((e) => e.transactionId === transactionId),\n  )\n\n  const appliedTransaction$ = state.observable.pipe(\n    map((s) => s.applied),\n    distinctUntilChanged(),\n    map((applied) => applied.find((t) => t.transactionId === transactionId)),\n    first(Boolean),\n  )\n\n  const successfulTransaction$ = events.pipe(\n    filter((e) => e.type === 'accepted'),\n    first((e) => e.outgoing.batchedTransactionIds.includes(transactionId)),\n  )\n\n  const rejectedTransaction$ = events.pipe(\n    filter((e) => e.type === 'reverted'),\n    first((e) => e.outgoing.batchedTransactionIds.includes(transactionId)),\n  )\n\n  const appliedTransactionOrError = firstValueFrom(\n    race([fatalError$, transactionError$, appliedTransaction$]),\n  )\n  const acceptedOrRejectedTransaction = firstValueFrom(\n    race([successfulTransaction$, rejectedTransaction$, transactionError$]),\n  )\n\n  state.set('queueTransaction', (prev) => queueTransaction(prev, transaction))\n\n  const result = await appliedTransactionOrError\n  if ('type' in result && result.type === 'error') throw result.error\n\n  const {working: documents, previous, previousRevs} = result as AppliedTransaction\n  const existingIds = new Set(\n    Object.entries(previous)\n      .filter(([, value]) => !!value)\n      .map(([key]) => key),\n  )\n  const resultingIds = new Set(\n    Object.entries(documents)\n      .filter(([, value]) => !!value)\n      .map(([key]) => key),\n  )\n  const allIds = new Set([...existingIds, ...resultingIds])\n\n  const updated: string[] = []\n  const appeared: string[] = []\n  const disappeared: string[] = []\n\n  for (const id of allIds) {\n    if (existingIds.has(id) && resultingIds.has(id)) {\n      updated.push(id)\n    } else if (!existingIds.has(id) && resultingIds.has(id)) {\n      appeared.push(id)\n    } else if (!resultingIds.has(id) && existingIds.has(id)) {\n      disappeared.push(id)\n    }\n  }\n\n  async function submitted() {\n    const raceResult = await acceptedOrRejectedTransaction\n    if (raceResult.type !== 'accepted') throw raceResult.error\n    return raceResult.result\n  }\n\n  return {\n    transactionId,\n    documents,\n    previous,\n    previousRevs,\n    appeared,\n    updated,\n    disappeared,\n    submitted,\n  }\n}\n","/**\n * When a query has no more subscribers, its state is cleaned up and removed\n * from the store. A delay used to prevent re-creating resources when the last\n * subscriber is removed quickly before another one is added. This is helpful\n * when used in a frontend where components may suspend or transition to\n * different views quickly.\n */\nexport const QUERY_STATE_CLEAR_DELAY = 1000\n// NOTE: Have to use vX for the text::query groq function\nexport const QUERY_STORE_API_VERSION = 'vX'\n","import {omit} from 'lodash-es'\n\ninterface QueryState {\n  syncTags?: string[]\n  result?: unknown\n  error?: unknown\n  lastLiveEventId?: string\n  subscribers: string[]\n}\n\nexport interface QueryStoreState {\n  queries: {[key: string]: QueryState | undefined}\n  error?: unknown\n}\n\nexport const setQueryError =\n  (key: string, error: unknown) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    if (!prevQuery) return prev\n    return {...prev, queries: {...prev.queries, [key]: {...prevQuery, error}}}\n  }\n\nexport const setQueryData =\n  (key: string, result: unknown, syncTags?: string[]) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    if (!prevQuery) return prev\n    return {\n      ...prev,\n      queries: {...prev.queries, [key]: {...prevQuery, result: result ?? null, syncTags}},\n    }\n  }\n\nexport const setLastLiveEventId =\n  (key: string, lastLiveEventId: string) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    if (!prevQuery) return prev\n    return {...prev, queries: {...prev.queries, [key]: {...prevQuery, lastLiveEventId}}}\n  }\n\nexport const addSubscriber =\n  (key: string, subscriptionId: string) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    const subscribers = [...(prevQuery?.subscribers ?? []), subscriptionId]\n    return {...prev, queries: {...prev.queries, [key]: {...prevQuery, subscribers}}}\n  }\n\nexport const removeSubscriber =\n  (key: string, subscriptionId: string) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    if (!prevQuery) return prev\n    const subscribers = prevQuery.subscribers.filter((id) => id !== subscriptionId)\n    if (!subscribers.length) return {...prev, queries: omit(prev.queries, key)}\n    return {...prev, queries: {...prev.queries, [key]: {...prevQuery, subscribers}}}\n  }\n\nexport const cancelQuery =\n  (key: string) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    const prevQuery = prev.queries[key]\n    if (!prevQuery) return prev\n    if (prevQuery.subscribers.length) return prev\n    return {...prev, queries: omit(prev.queries, key)}\n  }\n\nexport const initializeQuery =\n  (key: string) =>\n  (prev: QueryStoreState): QueryStoreState => {\n    if (prev.queries[key]) return prev\n    return {...prev, queries: {...prev.queries, [key]: {subscribers: []}}}\n  }\n","import {type ResponseQueryOptions} from '@sanity/client'\nimport {\n  catchError,\n  combineLatest,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  first,\n  firstValueFrom,\n  groupBy,\n  map,\n  mergeMap,\n  NEVER,\n  Observable,\n  pairwise,\n  race,\n  share,\n  startWith,\n  switchMap,\n  tap,\n} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {type DatasetHandle} from '../config/sanityConfig'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {\n  createStateSourceAction,\n  type SelectorContext,\n  type StateSource,\n} from '../store/createStateSourceAction'\nimport {type StoreState} from '../store/createStoreState'\nimport {defineStore, type StoreContext} from '../store/defineStore'\nimport {insecureRandomId} from '../utils/ids'\nimport {QUERY_STATE_CLEAR_DELAY, QUERY_STORE_API_VERSION} from './queryStoreConstants'\nimport {\n  addSubscriber,\n  cancelQuery,\n  initializeQuery,\n  type QueryStoreState,\n  removeSubscriber,\n  setLastLiveEventId,\n  setQueryData,\n  setQueryError,\n} from './reducers'\n\n/**\n * @beta\n */\nexport interface QueryOptions\n  extends Pick<\n      ResponseQueryOptions,\n      'perspective' | 'useCdn' | 'cache' | 'next' | 'cacheMode' | 'tag'\n    >,\n    DatasetHandle {\n  params?: Record<string, unknown>\n}\n\n/**\n * @beta\n */\nexport interface ResolveQueryOptions extends QueryOptions {\n  signal?: AbortSignal\n}\n\nconst EMPTY_ARRAY: never[] = []\n\n/** @beta */\nexport const getQueryKey = (query: string, options: QueryOptions = {}): string =>\n  JSON.stringify({query, options})\n/** @beta */\nexport const parseQueryKey = (key: string): {query: string; options: QueryOptions} =>\n  JSON.parse(key)\n\nconst queryStore = defineStore<QueryStoreState>({\n  name: 'QueryStore',\n  getInitialState: () => ({queries: {}}),\n  initialize(context) {\n    const subscriptions = [\n      listenForNewSubscribersAndFetch(context),\n      listenToLiveClientAndSetLastLiveEventIds(context),\n    ]\n\n    return () => {\n      for (const subscription of subscriptions) {\n        subscription.unsubscribe()\n      }\n    }\n  },\n})\n\nconst errorHandler = (state: StoreState<{error?: unknown}>) => {\n  return (error: unknown): void => state.set('setError', {error})\n}\n\nconst listenForNewSubscribersAndFetch = ({state, instance}: StoreContext<QueryStoreState>) => {\n  return state.observable\n    .pipe(\n      map((s) => new Set(Object.keys(s.queries))),\n      distinctUntilChanged((curr, next) => {\n        if (curr.size !== next.size) return false\n        return Array.from(next).every((i) => curr.has(i))\n      }),\n      startWith(new Set<string>()),\n      pairwise(),\n      mergeMap(([curr, next]) => {\n        const added = Array.from(next).filter((i) => !curr.has(i))\n        const removed = Array.from(curr).filter((i) => !next.has(i))\n\n        return [\n          ...added.map((key) => ({key, added: true})),\n          ...removed.map((key) => ({key, added: false})),\n        ]\n      }),\n      groupBy((i) => i.key),\n      mergeMap((group$) =>\n        group$.pipe(\n          switchMap((e) => {\n            if (!e.added) return EMPTY\n\n            const lastLiveEventId$ = state.observable.pipe(\n              map((s) => s.queries[group$.key]?.lastLiveEventId),\n              distinctUntilChanged(),\n            )\n            const {query, options: {params, projectId, dataset, tag, ...options} = {}} =\n              parseQueryKey(group$.key)\n            const client$ = getClientState(instance, {\n              apiVersion: QUERY_STORE_API_VERSION,\n              projectId,\n              dataset,\n            }).observable\n\n            return combineLatest([lastLiveEventId$, client$]).pipe(\n              switchMap(([lastLiveEventId, client]) =>\n                client.observable.fetch(query, params, {\n                  ...options,\n                  filterResponse: false,\n                  returnQuery: false,\n                  lastLiveEventId,\n                  tag,\n                }),\n              ),\n            )\n          }),\n          catchError((error) => {\n            state.set('setQueryError', setQueryError(group$.key, error))\n            return EMPTY\n          }),\n          tap(({result, syncTags}) => {\n            state.set('setQueryData', setQueryData(group$.key, result, syncTags))\n          }),\n        ),\n      ),\n    )\n    .subscribe({error: errorHandler(state)})\n}\n\nconst listenToLiveClientAndSetLastLiveEventIds = ({\n  state,\n  instance,\n}: StoreContext<QueryStoreState>) => {\n  const liveMessages$ = getClientState(instance, {\n    apiVersion: QUERY_STORE_API_VERSION,\n  }).observable.pipe(\n    switchMap((client) =>\n      client.live.events({includeDrafts: !!client.config().token, tag: 'query-store'}),\n    ),\n    share(),\n    filter((e) => e.type === 'message'),\n  )\n\n  return state.observable\n    .pipe(\n      mergeMap((s) => Object.entries(s.queries)),\n      groupBy(([key]) => key),\n      mergeMap((group$) => {\n        const syncTags$ = group$.pipe(\n          map(([, queryState]) => queryState),\n          map((i) => i?.syncTags ?? EMPTY_ARRAY),\n          distinctUntilChanged(),\n        )\n\n        return combineLatest([liveMessages$, syncTags$]).pipe(\n          filter(([message, syncTags]) => message.tags.some((tag) => syncTags.includes(tag))),\n          tap(([message]) => {\n            state.set('setLastLiveEventId', setLastLiveEventId(group$.key, message.id))\n          }),\n        )\n      }),\n    )\n    .subscribe({error: errorHandler(state)})\n}\n\n/**\n * Returns the state source for a query.\n *\n * This function returns a state source that represents the current result of a GROQ query.\n * Subscribing to the state source will instruct the SDK to fetch the query (if not already fetched)\n * and will keep the query live using the Live content API (considering sync tags) to provide up-to-date results.\n * When the last subscriber is removed, the query state is automatically cleaned up from the store.\n *\n * Note: This functionality is for advanced users who want to build their own framework integrations.\n * Our SDK also provides a React integration (useQuery hook) for convenient usage.\n *\n * Note: Automatic cleanup can interfere with React Suspense because if a component suspends while being the only subscriber,\n * cleanup might occur unexpectedly. In such cases, consider using `resolveQuery` instead.\n *\n * @beta\n */\nexport function getQueryState<T>(\n  instance: SanityInstance,\n  query: string,\n  options?: QueryOptions,\n): StateSource<T | undefined>\n/** @beta */\nexport function getQueryState(\n  instance: SanityInstance,\n  query: string,\n  options?: QueryOptions,\n): StateSource<unknown>\n/** @beta */\nexport function getQueryState(...args: Parameters<typeof _getQueryState>): StateSource<unknown> {\n  return _getQueryState(...args)\n}\nconst _getQueryState = bindActionByDataset(\n  queryStore,\n  createStateSourceAction({\n    selector: (\n      {state}: SelectorContext<QueryStoreState>,\n      query: string,\n      options?: QueryOptions,\n    ) => {\n      if (state.error) throw state.error\n      const key = getQueryKey(query, options)\n      const queryState = state.queries[key]\n      if (queryState?.error) throw queryState.error\n      return queryState?.result\n    },\n    onSubscribe: ({state}, query, options?: QueryOptions) => {\n      const subscriptionId = insecureRandomId()\n      const key = getQueryKey(query, options)\n\n      state.set('addSubscriber', addSubscriber(key, subscriptionId))\n\n      return () => {\n        // this runs on unsubscribe\n        setTimeout(\n          () => state.set('removeSubscriber', removeSubscriber(key, subscriptionId)),\n          QUERY_STATE_CLEAR_DELAY,\n        )\n      }\n    },\n  }),\n)\n\n/**\n * Resolves the result of a query without registering a lasting subscriber.\n *\n * This function fetches the result of a GROQ query and returns a promise that resolves with the query result.\n * Unlike `getQueryState`, which registers subscribers to keep the query live and performs automatic cleanup,\n * `resolveQuery` does not track subscribers. This makes it ideal for use with React Suspense, where the returned\n * promise is thrown to delay rendering until the query result becomes available.\n * Once the promise resolves, it is expected that a real subscriber will be added via `getQueryState` to manage ongoing updates.\n *\n * Additionally, an optional AbortSignal can be provided to cancel the query and immediately clear the associated state\n * if there are no active subscribers.\n *\n * @beta\n */\nexport function resolveQuery<T>(\n  instance: SanityInstance,\n  query: string,\n  options?: ResolveQueryOptions,\n): Promise<T>\n/** @beta */\nexport function resolveQuery(\n  instance: SanityInstance,\n  query: string,\n  options?: ResolveQueryOptions,\n): Promise<unknown>\n/** @beta */\nexport function resolveQuery(...args: Parameters<typeof _resolveQuery>): Promise<unknown> {\n  return _resolveQuery(...args)\n}\nconst _resolveQuery = bindActionByDataset(\n  queryStore,\n  ({state, instance}, query: string, {signal, ...options}: ResolveQueryOptions = {}) => {\n    const {getCurrent} = getQueryState(instance, query, options)\n    const key = getQueryKey(query, options)\n\n    const aborted$ = signal\n      ? new Observable<void>((observer) => {\n          const cleanup = () => {\n            signal.removeEventListener('abort', listener)\n          }\n\n          const listener = () => {\n            observer.error(new DOMException('The operation was aborted.', 'AbortError'))\n            observer.complete()\n            cleanup()\n          }\n          signal.addEventListener('abort', listener)\n\n          return cleanup\n        }).pipe(\n          catchError((error) => {\n            if (error instanceof Error && error.name === 'AbortError') {\n              state.set('cancelQuery', cancelQuery(key))\n            }\n            throw error\n          }),\n        )\n      : NEVER\n\n    state.set('initializeQuery', initializeQuery(key))\n\n    const resolved$ = state.observable.pipe(\n      map(getCurrent),\n      first((i) => i !== undefined),\n    )\n\n    return firstValueFrom(race([resolved$, aborted$]))\n  },\n)\n","export function hashString(str: string): string {\n  // Using a large prime number for the hash\n  const PRIME = 31\n  // Using a max 32-bit integer to prevent overflow\n  const MOD = 2147483647\n\n  let hash = 0\n\n  // Process chunks of the string to reduce complexity\n  for (let i = 0; i < str.length; i++) {\n    // Rolling hash computation\n    hash = (hash * PRIME + str.charCodeAt(i)) % MOD\n  }\n\n  // Ensure we return a positive hash\n  return Math.abs(hash).toString(16).padStart(8, '0')\n}\n","/**\n * The fields to check for a title.\n * The order of the items in the array defines the priority.\n *\n * @internal\n */\nexport const TITLE_CANDIDATES = ['title', 'name', 'label', 'heading', 'header', 'caption']\n\n/**\n * The fields to check for a subtitle.\n * The order of the items in the array defines the priority.\n *\n * @internal\n */\nexport const SUBTITLE_CANDIDATES = ['description', 'subtitle', ...TITLE_CANDIDATES]\n\n/**\n * Generates a GROQ projection for preview data without requiring a schema.\n * Uses common field names to make educated guesses about which fields to use.\n *\n * @internal\n */\nexport const PREVIEW_PROJECTION = `{\n  // Get all potential title fields\n  \"titleCandidates\": {\n    ${TITLE_CANDIDATES.map((field) => `\"${field}\": ${field}`).join(',\\n      ')}\n  },\n  // Get all potential subtitle fields\n  \"subtitleCandidates\": {\n    ${SUBTITLE_CANDIDATES.map((field) => `\"${field}\": ${field}`).join(',\\n      ')}\n  },\n  \"media\": coalesce(\n    select(\n      defined(asset) => {\"type\": \"image-asset\", \"_ref\": asset._ref},\n      defined(image.asset) => {\"type\": \"image-asset\", \"_ref\": image.asset._ref},\n      defined(mainImage.asset) => {\"type\": \"image-asset\", \"_ref\": mainImage.asset._ref},\n      null\n    )\n  ),\n  _type,\n  _id,\n  _updatedAt\n}`\n","import {getEnv} from '../utils/getEnv'\nimport {type PreviewValue, type ValuePending} from './previewStore'\n\nexport const PREVIEW_TAG = 'preview'\nexport const PREVIEW_PERSPECTIVE = 'drafts'\nexport const STABLE_EMPTY_PREVIEW: ValuePending<PreviewValue> = {data: null, isPending: false}\nexport const STABLE_ERROR_PREVIEW: ValuePending<PreviewValue> = {\n  data: {\n    title: 'Preview Error',\n    ...(!!getEnv('DEV') && {subtitle: 'Check the console for more details'}),\n  },\n  isPending: false,\n}\n","import {isObject} from 'lodash-es'\n\nimport {hashString} from '../utils/hashString'\nimport {getDraftId, getPublishedId} from '../utils/ids'\nimport {PREVIEW_PROJECTION, SUBTITLE_CANDIDATES, TITLE_CANDIDATES} from './previewConstants'\nimport {\n  type PreviewQueryResult,\n  type PreviewStoreState,\n  type PreviewValue,\n  type ValuePending,\n} from './previewStore'\nimport {STABLE_EMPTY_PREVIEW, STABLE_ERROR_PREVIEW} from './util'\n\ninterface ProcessPreviewQueryOptions {\n  projectId: string\n  dataset: string\n  ids: Set<string>\n  results: PreviewQueryResult[]\n}\n\n/**\n * Converts an asset ID to a URL.\n *\n * @internal\n */\nfunction assetIdToUrl(assetId: string, projectId: string, dataset: string) {\n  const pattern = /^image-(?<assetName>[A-Za-z0-9]+)-(?<dimensions>\\d+x\\d+)-(?<format>[a-z]+)$/\n  const match = assetId.match(pattern)\n  if (!match?.groups) {\n    throw new Error(\n      `Invalid asset ID \\`${assetId}\\`. Expected: image-{assetName}-{width}x{height}-{format}`,\n    )\n  }\n\n  const {assetName, dimensions, format} = match.groups\n  return `https://cdn.sanity.io/images/${projectId}/${dataset}/${assetName}-${dimensions}.${format}`\n}\n\n/**\n * Checks if the provided value has `_ref` property that is a string and starts with `image-`\n */\nfunction hasImageRef<T>(value: unknown): value is T & {_ref: string} {\n  return isObject(value) && '_ref' in value && typeof (value as {_ref: unknown})._ref === 'string'\n}\n\n/**\n * Normalizes a media asset to a preview value.\n * Adds a url to a media asset reference.\n *\n * @internal\n */\nexport function normalizeMedia(\n  media: unknown,\n  projectId: string,\n  dataset: string,\n): PreviewValue['media'] {\n  if (!media) return null\n  if (!hasImageRef(media)) return null\n  return {\n    type: 'image-asset',\n    _ref: media._ref,\n    url: assetIdToUrl(media._ref, projectId, dataset),\n  }\n}\n\n/**\n * Finds a single field value from a set of candidates based on a priority list of field names.\n * Returns the first non-empty string value found from the candidates matching the priority list order.\n *\n * @internal\n */\nfunction findFirstDefined(\n  fieldsToSearch: string[],\n  candidates: Record<string, unknown>,\n  exclude?: unknown,\n): string | undefined {\n  if (!candidates) return undefined\n\n  for (const field of fieldsToSearch) {\n    const value = candidates[field]\n    if (typeof value === 'string' && value.trim() !== '' && value !== exclude) {\n      return value\n    }\n  }\n\n  return undefined\n}\n\nexport function processPreviewQuery({\n  projectId,\n  dataset,\n  ids,\n  results,\n}: ProcessPreviewQueryOptions): PreviewStoreState['values'] {\n  const resultMap = results.reduce<{[TDocumentId in string]?: PreviewQueryResult}>((acc, next) => {\n    acc[next._id] = next\n    return acc\n  }, {})\n\n  return Object.fromEntries(\n    Array.from(ids).map((id): [string, ValuePending<PreviewValue>] => {\n      const publishedId = getPublishedId(id)\n      const draftId = getDraftId(id)\n\n      const draftResult = resultMap[draftId]\n      const publishedResult = resultMap[publishedId]\n\n      if (!draftResult && !publishedResult) return [id, STABLE_EMPTY_PREVIEW]\n\n      try {\n        const result = draftResult || publishedResult\n        if (!result) return [id, STABLE_EMPTY_PREVIEW]\n        const title = findFirstDefined(TITLE_CANDIDATES, result.titleCandidates)\n        const subtitle = findFirstDefined(SUBTITLE_CANDIDATES, result.subtitleCandidates, title)\n        const preview: Omit<PreviewValue, 'status'> = {\n          title: String(title || `${result._type}: ${result._id}`),\n          subtitle: subtitle || undefined,\n          media: normalizeMedia(result.media, projectId, dataset),\n        }\n\n        const status: PreviewValue['status'] = {\n          ...(draftResult?._updatedAt && {lastEditedDraftAt: draftResult._updatedAt}),\n          ...(publishedResult?._updatedAt && {lastEditedPublishedAt: publishedResult._updatedAt}),\n        }\n\n        return [id, {data: {...preview, status}, isPending: false}]\n      } catch (e) {\n        // TODO: replace this with bubbling the error\n        // eslint-disable-next-line no-console\n        console.warn(e)\n        return [id, STABLE_ERROR_PREVIEW]\n      }\n    }),\n  )\n}\n\ninterface CreatePreviewQueryResult {\n  query: string\n  params: Record<string, string[]>\n}\n\nexport function createPreviewQuery(documentIds: Set<string>): CreatePreviewQueryResult {\n  // Create arrays of draft and published IDs\n  const allIds = Array.from(documentIds).flatMap((id) => [getPublishedId(id), getDraftId(id)])\n  const queryHash = hashString(PREVIEW_PROJECTION)\n\n  return {\n    query: `*[_id in $__ids_${queryHash}]${PREVIEW_PROJECTION}`,\n    params: {\n      [`__ids_${queryHash}`]: allIds,\n    },\n  }\n}\n","import {\n  debounceTime,\n  defer,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  from,\n  map,\n  Observable,\n  pairwise,\n  startWith,\n  Subscription,\n  switchMap,\n  tap,\n} from 'rxjs'\n\nimport {getQueryState, resolveQuery} from '../query/queryStore'\nimport {type StoreContext} from '../store/defineStore'\nimport {createPreviewQuery, processPreviewQuery} from './previewQuery'\nimport {type PreviewQueryResult, type PreviewStoreState} from './previewStore'\nimport {PREVIEW_PERSPECTIVE, PREVIEW_TAG} from './util'\n\nconst BATCH_DEBOUNCE_TIME = 50\n\nconst isSetEqual = <T>(a: Set<T>, b: Set<T>) =>\n  a.size === b.size && Array.from(a).every((i) => b.has(i))\n\nexport const subscribeToStateAndFetchBatches = ({\n  state,\n  instance,\n}: StoreContext<PreviewStoreState>): Subscription => {\n  const newSubscriberIds$ = state.observable.pipe(\n    map(({subscriptions}) => new Set(Object.keys(subscriptions))),\n    distinctUntilChanged(isSetEqual),\n    debounceTime(BATCH_DEBOUNCE_TIME),\n    startWith(new Set<string>()),\n    pairwise(),\n    tap(([prevIds, currIds]) => {\n      // for all new subscriptions, set their values to pending\n      const newIds = [...currIds].filter((element) => !prevIds.has(element))\n      state.set('updatingPending', (prev) => {\n        const pendingValues = newIds.reduce<PreviewStoreState['values']>((acc, id) => {\n          const prevValue = prev.values[id]\n          const value = prevValue?.data ? prevValue.data : null\n          acc[id] = {data: value, isPending: true}\n          return acc\n        }, {})\n        return {values: {...prev.values, ...pendingValues}}\n      })\n    }),\n    map(([, ids]) => ids),\n    distinctUntilChanged(isSetEqual),\n  )\n\n  return newSubscriberIds$\n    .pipe(\n      switchMap((ids) => {\n        if (!ids.size) return EMPTY\n        const {query, params} = createPreviewQuery(ids)\n        const controller = new AbortController()\n        return new Observable<PreviewQueryResult[]>((observer) => {\n          const {getCurrent, observable} = getQueryState<PreviewQueryResult[]>(instance, query, {\n            params,\n            tag: PREVIEW_TAG,\n            perspective: PREVIEW_PERSPECTIVE,\n          })\n          const source$ = defer(() => {\n            if (getCurrent() === undefined) {\n              return from(\n                resolveQuery<PreviewQueryResult[]>(instance, query, {\n                  params,\n                  tag: PREVIEW_TAG,\n                  perspective: PREVIEW_PERSPECTIVE,\n                  signal: controller.signal,\n                }),\n              ).pipe(switchMap(() => observable))\n            }\n            return observable\n          }).pipe(filter((result) => result !== undefined))\n          const subscription = source$.subscribe(observer)\n          return () => {\n            if (!controller.signal.aborted) {\n              controller.abort()\n            }\n\n            subscription.unsubscribe()\n          }\n        }).pipe(map((data) => ({data, ids})))\n      }),\n      map(({ids, data}) => ({\n        values: processPreviewQuery({\n          projectId: instance.config.projectId!,\n          dataset: instance.config.dataset!,\n          ids,\n          results: data,\n        }),\n      })),\n    )\n    .subscribe({\n      next: ({values}) => {\n        state.set('updateResult', (prev) => ({values: {...prev.values, ...values}}))\n      },\n    })\n}\n","import {defineStore} from '../store/defineStore'\nimport {subscribeToStateAndFetchBatches} from './subscribeToStateAndFetchBatches'\n\nexport interface PreviewQueryResult {\n  _id: string\n  _type: string\n  _updatedAt: string\n  titleCandidates: Record<string, unknown>\n  subtitleCandidates: Record<string, unknown>\n  media?: PreviewMedia | null\n}\n\n/**\n * Represents a media asset in a preview.\n *\n * @public\n */\nexport interface PreviewMedia {\n  type: 'image-asset'\n  _ref: string\n  url: string\n}\n\n/**\n * Represents the set of values displayed as a preview for a given Sanity document.\n * This includes a primary title, a secondary subtitle, an optional piece of media associated\n * with the document, and the document's status.\n *\n * @public\n */\nexport interface PreviewValue {\n  /**\n   * The primary text displayed for the document preview.\n   */\n  title: string\n\n  /**\n   * A secondary line of text providing additional context about the document.\n   */\n  subtitle?: string\n\n  /**\n   * An optional piece of media representing the document within its preview.\n   * Currently, only image assets are available.\n   */\n  media?: PreviewMedia | null\n\n  /**\n   * The status of the document.\n   */\n  status?: {\n    /** The date of the last published edit */\n    lastEditedPublishedAt?: string\n    /** The date of the last draft edit */\n    lastEditedDraftAt?: string\n  }\n}\n\n/**\n * Represents the current state of a preview value along with a flag indicating whether\n * the preview data is still being fetched or is fully resolved.\n *\n * The tuple contains a preview value or null, and a boolean indicating if the data is\n * pending. A `true` value means a fetch is ongoing; `false` indicates that the\n * currently provided preview value is up-to-date.\n *\n * @public\n */\nexport type ValuePending<T> = {\n  data: T | null\n  isPending: boolean\n}\n\n/**\n * @public\n */\nexport interface PreviewStoreState {\n  values: {[TDocumentId in string]?: ValuePending<PreviewValue>}\n  subscriptions: {[TDocumentId in string]?: {[TSubscriptionId in string]?: true}}\n}\n\nexport const previewStore = defineStore<PreviewStoreState>({\n  name: 'Preview',\n  getInitialState() {\n    return {\n      subscriptions: {},\n      values: {},\n    }\n  },\n  initialize: (context) => {\n    const subscription = subscribeToStateAndFetchBatches(context)\n    return () => subscription.unsubscribe\n  },\n})\n","import {omit} from 'lodash-es'\n\nimport {type DocumentHandle} from '../config/sanityConfig'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {\n  createStateSourceAction,\n  type SelectorContext,\n  type StateSource,\n} from '../store/createStateSourceAction'\nimport {getPublishedId, insecureRandomId} from '../utils/ids'\nimport {\n  previewStore,\n  type PreviewStoreState,\n  type PreviewValue,\n  type ValuePending,\n} from './previewStore'\nimport {STABLE_EMPTY_PREVIEW} from './util'\n\n/**\n * @beta\n */\nexport type GetPreviewStateOptions = DocumentHandle\n\n/**\n * @beta\n */\nexport function getPreviewState<TResult extends object>(\n  instance: SanityInstance,\n  options: GetPreviewStateOptions,\n): StateSource<ValuePending<TResult>>\n/**\n * @beta\n */\nexport function getPreviewState(\n  instance: SanityInstance,\n  options: GetPreviewStateOptions,\n): StateSource<ValuePending<PreviewValue>>\n/**\n * @beta\n */\nexport function getPreviewState(\n  ...args: Parameters<typeof _getPreviewState>\n): StateSource<ValuePending<object>> {\n  return _getPreviewState(...args)\n}\n\n/**\n * @beta\n */\nexport const _getPreviewState = bindActionByDataset(\n  previewStore,\n  createStateSourceAction({\n    selector: (\n      {state}: SelectorContext<PreviewStoreState>,\n      docHandle: GetPreviewStateOptions,\n    ): ValuePending<object> => state.values[docHandle.documentId] ?? STABLE_EMPTY_PREVIEW,\n    onSubscribe: ({state}, docHandle: GetPreviewStateOptions) => {\n      const subscriptionId = insecureRandomId()\n      const documentId = getPublishedId(docHandle.documentId)\n\n      state.set('addSubscription', (prev) => ({\n        subscriptions: {\n          ...prev.subscriptions,\n          [documentId]: {\n            ...prev.subscriptions[documentId],\n            [subscriptionId]: true,\n          },\n        },\n      }))\n\n      return () => {\n        state.set('removeSubscription', (prev): Partial<PreviewStoreState> => {\n          const documentSubscriptions = omit(prev.subscriptions[documentId], subscriptionId)\n          const hasSubscribers = !!Object.keys(documentSubscriptions).length\n          const prevValue = prev.values[documentId]\n          const previewValue = prevValue?.data ? prevValue.data : null\n\n          return {\n            subscriptions: hasSubscribers\n              ? {...prev.subscriptions, [documentId]: documentSubscriptions}\n              : omit(prev.subscriptions, documentId),\n            values: hasSubscribers\n              ? prev.values\n              : {...prev.values, [documentId]: {data: previewValue, isPending: false}},\n          }\n        })\n      }\n    },\n  }),\n)\n","import {filter, firstValueFrom} from 'rxjs'\n\nimport {type DocumentHandle} from '../config/sanityConfig'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {getPreviewState} from './getPreviewState'\nimport {previewStore} from './previewStore'\n\n/**\n * @beta\n */\nexport type ResolvePreviewOptions = DocumentHandle\n\n/**\n * @beta\n */\nexport const resolvePreview = bindActionByDataset(\n  previewStore,\n  ({instance}, docHandle: ResolvePreviewOptions) =>\n    firstValueFrom(getPreviewState(instance, docHandle).observable.pipe(filter((i) => !!i.data))),\n)\n","import {switchMap} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {type ProjectHandle} from '../config/sanityConfig'\nimport {createFetcherStore} from '../utils/createFetcherStore'\n\nconst API_VERSION = 'v2025-02-19'\n\nconst project = createFetcherStore({\n  name: 'Project',\n  getKey: (instance, options?: ProjectHandle) => {\n    const projectId = options?.projectId ?? instance.config.projectId\n    if (!projectId) {\n      throw new Error('A projectId is required to use the project API.')\n    }\n    return projectId\n  },\n  fetcher:\n    (instance) =>\n    (options: ProjectHandle = {}) => {\n      const projectId = options.projectId ?? instance.config.projectId\n\n      return getClientState(instance, {\n        apiVersion: API_VERSION,\n        scope: 'global',\n        projectId,\n      }).observable.pipe(\n        switchMap((client) =>\n          client.observable.projects.getById(\n            // non-null assertion is fine with the above throwing\n            (projectId ?? instance.config.projectId)!,\n          ),\n        ),\n      )\n    },\n})\n\n/** @public */\nexport const getProjectState = project.getState\n/** @public */\nexport const resolveProject = project.resolveState\n","import {type ValidProjection} from './projectionStore'\n\nexport const PROJECTION_TAG = 'sdk.projection'\nexport const PROJECTION_PERSPECTIVE = 'drafts'\nexport const PROJECTION_STATE_CLEAR_DELAY = 1000\n\nexport const STABLE_EMPTY_PROJECTION = {\n  data: null,\n  isPending: false,\n}\n\nexport function validateProjection(projection: string): ValidProjection {\n  if (!projection.startsWith('{') || !projection.endsWith('}')) {\n    throw new Error(\n      `Invalid projection format: \"${projection}\". Projections must be enclosed in curly braces, e.g. \"{title, 'author': author.name}\"`,\n    )\n  }\n  return projection as ValidProjection\n}\n","import {hashString} from '../utils/hashString'\nimport {getDraftId, getPublishedId} from '../utils/ids'\nimport {type ProjectionValuePending, type ValidProjection} from './projectionStore'\nimport {validateProjection} from './util'\n\ntype ProjectionQueryResult = {\n  _id: string\n  _type: string\n  _updatedAt: string\n  result: Record<string, unknown>\n}\n\ninterface CreateProjectionQueryResult {\n  query: string\n  params: Record<string, unknown>\n}\n\ntype ProjectionMap = Record<string, {projection: ValidProjection; documentIds: Set<string>}>\n\nexport function createProjectionQuery(\n  documentIds: Set<string>,\n  documentProjections: {[TDocumentId in string]?: string},\n): CreateProjectionQueryResult {\n  const projections = Array.from(documentIds)\n    .filter((id) => documentProjections[id])\n    .map((id) => {\n      const projection = validateProjection(documentProjections[id]!)\n      const projectionHash = hashString(projection)\n      return {documentId: id, projection, projectionHash}\n    })\n    .reduce<ProjectionMap>((acc, {documentId, projection, projectionHash}) => {\n      const obj = acc[projectionHash] ?? {documentIds: new Set(), projection}\n      obj.documentIds.add(documentId)\n\n      acc[projectionHash] = obj\n      return acc\n    }, {})\n\n  const query = `[${Object.entries(projections)\n    .map(([projectionHash, {projection}]) => {\n      return `...*[_id in $__ids_${projectionHash}]{_id,_type,_updatedAt,\"result\":{...${projection}}}`\n    })\n    .join(',')}]`\n\n  const params = Object.fromEntries(\n    Object.entries(projections).map(([projectionHash, value]) => {\n      const idsInProjection = Array.from(value.documentIds).flatMap((id) => [\n        getPublishedId(id),\n        getDraftId(id),\n      ])\n\n      return [`__ids_${projectionHash}`, Array.from(idsInProjection)]\n    }),\n  )\n\n  return {query, params}\n}\n\ninterface ProcessProjectionQueryOptions {\n  projectId: string\n  dataset: string\n  ids: Set<string>\n  results: ProjectionQueryResult[]\n}\n\nexport function processProjectionQuery({ids, results}: ProcessProjectionQueryOptions): {\n  [TDocumentId in string]?: ProjectionValuePending<Record<string, unknown>>\n} {\n  const resultMap = results.reduce<{[TDocumentId in string]?: ProjectionQueryResult}>(\n    (acc, next) => {\n      acc[next._id] = next\n      return acc\n    },\n    {},\n  )\n\n  return Object.fromEntries(\n    Array.from(ids).map((id): [string, ProjectionValuePending<Record<string, unknown>>] => {\n      const publishedId = getPublishedId(id)\n      const draftId = getDraftId(id)\n\n      const draftResult = resultMap[draftId]\n      const publishedResult = resultMap[publishedId]\n\n      const projectionResult = draftResult?.result ?? publishedResult?.result\n      if (!projectionResult) return [id, {data: null, isPending: false}]\n\n      const status = {\n        ...(draftResult?._updatedAt && {lastEditedDraftAt: draftResult._updatedAt}),\n        ...(publishedResult?._updatedAt && {lastEditedPublishedAt: publishedResult._updatedAt}),\n      }\n\n      return [id, {data: {...projectionResult, status}, isPending: false}]\n    }),\n  )\n}\n","import {isEqual} from 'lodash-es'\nimport {\n  combineLatest,\n  debounceTime,\n  defer,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  from,\n  map,\n  Observable,\n  pairwise,\n  startWith,\n  Subscription,\n  switchMap,\n  tap,\n} from 'rxjs'\n\nimport {getQueryState, resolveQuery} from '../query/queryStore'\nimport {type StoreContext} from '../store/defineStore'\nimport {createProjectionQuery, processProjectionQuery} from './projectionQuery'\nimport {type ProjectionQueryResult, type ProjectionStoreState} from './projectionStore'\nimport {PROJECTION_PERSPECTIVE, PROJECTION_TAG} from './util'\n\nconst BATCH_DEBOUNCE_TIME = 50\n\nconst isSetEqual = <T>(a: Set<T>, b: Set<T>) =>\n  a.size === b.size && Array.from(a).every((i) => b.has(i))\n\nexport const subscribeToStateAndFetchBatches = ({\n  state,\n  instance,\n}: StoreContext<ProjectionStoreState>): Subscription => {\n  const documentProjections$ = state.observable.pipe(\n    map((i) => i.documentProjections),\n    distinctUntilChanged(),\n  )\n\n  const newSubscriberIds$ = state.observable.pipe(\n    map(({subscriptions}) => new Set(Object.keys(subscriptions))),\n    distinctUntilChanged(isSetEqual),\n    debounceTime(BATCH_DEBOUNCE_TIME),\n    startWith(new Set<string>()),\n    pairwise(),\n    tap(([prevIds, currIds]) => {\n      // for all new subscriptions, set their values to pending\n      const newIds = [...currIds].filter((element) => !prevIds.has(element))\n      state.set('updatingPending', (prev) => {\n        const pendingValues = newIds.reduce<ProjectionStoreState['values']>((acc, id) => {\n          const prevValue = prev.values[id]\n          const value = prevValue?.data ? prevValue.data : null\n          acc[id] = {data: value, isPending: true}\n          return acc\n        }, {})\n        return {values: {...prev.values, ...pendingValues}}\n      })\n    }),\n    map(([, ids]) => ids),\n    distinctUntilChanged(isSetEqual),\n  )\n\n  return combineLatest([newSubscriberIds$, documentProjections$])\n    .pipe(\n      distinctUntilChanged(isEqual),\n      switchMap(([ids, documentProjections]) => {\n        if (!ids.size) return EMPTY\n        const {query, params} = createProjectionQuery(ids, documentProjections)\n        const controller = new AbortController()\n\n        return new Observable<ProjectionQueryResult[]>((observer) => {\n          const {getCurrent, observable} = getQueryState<ProjectionQueryResult[]>(instance, query, {\n            params,\n            tag: PROJECTION_TAG,\n            perspective: PROJECTION_PERSPECTIVE,\n          })\n\n          const source$ = defer(() => {\n            if (getCurrent() === undefined) {\n              return from(\n                resolveQuery<ProjectionQueryResult[]>(instance, query, {\n                  params,\n                  tag: PROJECTION_TAG,\n                  perspective: PROJECTION_PERSPECTIVE,\n                  signal: controller.signal,\n                }),\n              ).pipe(switchMap(() => observable))\n            }\n            return observable\n          }).pipe(filter((result) => result !== undefined))\n\n          const subscription = source$.subscribe(observer)\n\n          return () => {\n            if (!controller.signal.aborted) {\n              controller.abort()\n            }\n            subscription.unsubscribe()\n          }\n        }).pipe(map((data) => ({data, ids})))\n      }),\n      map(({ids, data}) => ({\n        values: processProjectionQuery({\n          projectId: instance.config.projectId!,\n          dataset: instance.config.dataset!,\n          ids,\n          results: data,\n        }),\n      })),\n    )\n    .subscribe({\n      next: ({values}) => {\n        state.set('updateResult', (prev) => ({\n          values: {...prev.values, ...values},\n        }))\n      },\n    })\n}\n","import {defineStore} from '../store/defineStore'\nimport {subscribeToStateAndFetchBatches} from './subscribeToStateAndFetchBatches'\n\n/**\n * @beta\n */\nexport type ValidProjection = `{${string}}`\n\nexport interface ProjectionQueryResult<TValue = Record<string, unknown>> {\n  _id: string\n  _type: string\n  _updatedAt: string\n  result: TValue\n}\n\n/**\n * @beta\n */\nexport interface ProjectionValuePending<TValue extends object> {\n  data: TValue | null\n  isPending: boolean\n}\n\nexport interface ProjectionStoreState<TValue extends object = object> {\n  values: {[TDocumentId in string]?: ProjectionValuePending<TValue>}\n  documentProjections: {[TDocumentId in string]?: ValidProjection}\n  subscriptions: {[TDocumentId in string]?: {[TSubscriptionId in string]?: true}}\n}\n\nexport const projectionStore = defineStore<ProjectionStoreState>({\n  name: 'Projection',\n  getInitialState() {\n    return {\n      values: {},\n      documentProjections: {},\n      subscriptions: {},\n    }\n  },\n  initialize(context) {\n    const batchSubscription = subscribeToStateAndFetchBatches(context)\n    return () => batchSubscription.unsubscribe()\n  },\n})\n","import {omit} from 'lodash-es'\n\nimport {type DocumentHandle} from '../config/sanityConfig'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {\n  createStateSourceAction,\n  type SelectorContext,\n  type StateSource,\n} from '../store/createStateSourceAction'\nimport {getPublishedId, insecureRandomId} from '../utils/ids'\nimport {\n  projectionStore,\n  type ProjectionStoreState,\n  type ProjectionValuePending,\n  type ValidProjection,\n} from './projectionStore'\nimport {PROJECTION_STATE_CLEAR_DELAY, STABLE_EMPTY_PROJECTION, validateProjection} from './util'\n\ninterface GetProjectionStateOptions extends DocumentHandle {\n  projection: ValidProjection\n}\n\n/**\n * @beta\n */\nexport function getProjectionState<TResult extends object>(\n  instance: SanityInstance,\n  options: GetProjectionStateOptions,\n): StateSource<ProjectionValuePending<TResult>>\n/**\n * @beta\n */\nexport function getProjectionState(\n  instance: SanityInstance,\n  options: GetProjectionStateOptions,\n): StateSource<ProjectionValuePending<Record<string, unknown>>>\n/**\n * @beta\n */\nexport function getProjectionState(\n  ...args: Parameters<typeof _getProjectionState>\n): StateSource<ProjectionValuePending<object>> {\n  return _getProjectionState(...args)\n}\n\n/**\n * @beta\n */\nexport const _getProjectionState = bindActionByDataset(\n  projectionStore,\n  createStateSourceAction({\n    selector: (\n      {state}: SelectorContext<ProjectionStoreState>,\n      options: GetProjectionStateOptions,\n    ): ProjectionValuePending<object> =>\n      state.values[options.documentId] ?? STABLE_EMPTY_PROJECTION,\n    onSubscribe: ({state}, {projection, ...docHandle}: GetProjectionStateOptions) => {\n      const subscriptionId = insecureRandomId()\n      const documentId = getPublishedId(docHandle.documentId)\n\n      state.set('addSubscription', (prev) => ({\n        documentProjections: {\n          ...prev.documentProjections,\n          [documentId]: validateProjection(projection),\n        },\n        subscriptions: {\n          ...prev.subscriptions,\n          [documentId]: {\n            ...prev.subscriptions[documentId],\n            [subscriptionId]: true,\n          },\n        },\n      }))\n\n      return () => {\n        setTimeout(() => {\n          state.set('removeSubscription', (prev): Partial<ProjectionStoreState> => {\n            const documentSubscriptions = omit(prev.subscriptions[documentId], subscriptionId)\n            const hasSubscribers = !!Object.keys(documentSubscriptions).length\n            const prevValue = prev.values[documentId]\n            const projectionValue = prevValue?.data ? prevValue.data : null\n\n            return {\n              subscriptions: hasSubscribers\n                ? {...prev.subscriptions, [documentId]: documentSubscriptions}\n                : omit(prev.subscriptions, documentId),\n              values: hasSubscribers\n                ? prev.values\n                : {...prev.values, [documentId]: {data: projectionValue, isPending: false}},\n            }\n          })\n        }, PROJECTION_STATE_CLEAR_DELAY)\n      }\n    },\n  }),\n)\n","import {filter, firstValueFrom} from 'rxjs'\n\nimport {type DocumentHandle} from '../config/sanityConfig'\nimport {bindActionByDataset} from '../store/createActionBinder'\nimport {getProjectionState} from './getProjectionState'\nimport {projectionStore, type ValidProjection} from './projectionStore'\n\ninterface ResolveProjectionOptions extends DocumentHandle {\n  projection: ValidProjection\n}\n\n/**\n * @beta\n */\nexport const resolveProjection = bindActionByDataset(\n  projectionStore,\n  ({instance}, {projection, ...docHandle}: ResolveProjectionOptions) =>\n    firstValueFrom(\n      getProjectionState(instance, {...docHandle, projection}).observable.pipe(\n        filter((i) => !!i.data),\n      ),\n    ),\n)\n","import {switchMap} from 'rxjs'\n\nimport {getClientState} from '../client/clientStore'\nimport {createFetcherStore} from '../utils/createFetcherStore'\n\nconst API_VERSION = 'v2025-02-19'\n\nconst projects = createFetcherStore({\n  name: 'Projects',\n  getKey: () => 'projects',\n  fetcher: (instance) => () =>\n    getClientState(instance, {\n      apiVersion: API_VERSION,\n      scope: 'global',\n    }).observable.pipe(\n      switchMap((client) => client.observable.projects.list({includeMembers: false})),\n    ),\n})\n\n/** @public */\nexport const getProjectsState = projects.getState\n/** @public */\nexport const resolveProjects = projects.resolveState\n","// NOTE: currently this API is only available on vX\nexport const API_VERSION = 'vX'\nexport const USERS_STATE_CLEAR_DELAY = 5000\nexport const DEFAULT_USERS_BATCH_SIZE = 100\n","import {omit} from 'lodash-es'\n\nimport {type SanityInstance} from '../store/createSanityInstance'\nimport {type GetUsersOptions, type SanityUserResponse, type UsersStoreState} from './types'\nimport {DEFAULT_USERS_BATCH_SIZE} from './usersConstants'\n\n/** @internal */\nexport const getUsersKey = (\n  instance: SanityInstance,\n  {\n    resourceType,\n    organizationId,\n    batchSize = DEFAULT_USERS_BATCH_SIZE,\n    projectId = instance.config.projectId,\n  }: GetUsersOptions = {},\n): string =>\n  JSON.stringify({resourceType, organizationId, batchSize, projectId} satisfies ReturnType<\n    typeof parseUsersKey\n  >)\n\n/** @internal */\nexport const parseUsersKey = (\n  key: string,\n): {\n  batchSize: number\n  resourceType?: 'organization' | 'project'\n  projectId?: string\n  organizationId?: string\n} => JSON.parse(key)\n\nexport const addSubscription =\n  (subscriptionId: string, key: string) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    const subscriptions = [...(group?.subscriptions ?? []), subscriptionId]\n    return {...prev, users: {...prev.users, [key]: {...group, subscriptions}}}\n  }\n\nexport const removeSubscription =\n  (subscriptionId: string, key: string) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    if (!group) return prev\n    const subscriptions = group.subscriptions.filter((id) => id !== subscriptionId)\n    if (!subscriptions.length) return {...prev, users: omit(prev.users, key)}\n    return {...prev, users: {...prev.users, [key]: {...group, subscriptions}}}\n  }\n\nexport const setUsersData =\n  (key: string, {data, nextCursor, totalCount}: SanityUserResponse) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    if (!group) return prev\n    const users = [...(group.users ?? []), ...data]\n    return {...prev, users: {...prev.users, [key]: {...group, users, totalCount, nextCursor}}}\n  }\n\nexport const updateLastLoadMoreRequest =\n  (timestamp: string, key: string) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    if (!group) return prev\n    return {...prev, users: {...prev.users, [key]: {...group, lastLoadMoreRequest: timestamp}}}\n  }\n\nexport const setUsersError =\n  (key: string, error: unknown) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    if (!group) return prev\n    return {...prev, users: {...prev.users, [key]: {...group, error}}}\n  }\n\nexport const cancelRequest =\n  (key: string) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    const group = prev.users[key]\n    if (!group) return prev\n    if (group.subscriptions.length) return prev\n    return {...prev, users: omit(prev.users, key)}\n  }\n\nexport const initializeRequest =\n  (key: string) =>\n  (prev: UsersStoreState): UsersStoreState => {\n    if (prev.users[key]) return prev\n    return {...prev, users: {...prev.users, [key]: {subscriptions: []}}}\n  }\n","import {createSelector} from 'reselect'\nimport {\n  catchError,\n  combineLatest,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  first,\n  firstValueFrom,\n  groupBy,\n  map,\n  mergeMap,\n  NEVER,\n  Observable,\n  of,\n  pairwise,\n  race,\n  skip,\n  startWith,\n  switchMap,\n  tap,\n  throwError,\n  withLatestFrom,\n} from 'rxjs'\n\nimport {getDashboardOrganizationId} from '../auth/authStore'\nimport {getClientState} from '../client/clientStore'\nimport {bindActionGlobally} from '../store/createActionBinder'\nimport {createStateSourceAction, type SelectorContext} from '../store/createStateSourceAction'\nimport {type StoreState} from '../store/createStoreState'\nimport {defineStore, type StoreContext} from '../store/defineStore'\nimport {insecureRandomId} from '../utils/ids'\nimport {\n  addSubscription,\n  cancelRequest,\n  getUsersKey,\n  initializeRequest,\n  parseUsersKey,\n  removeSubscription,\n  setUsersData,\n  setUsersError,\n  updateLastLoadMoreRequest,\n} from './reducers'\nimport {\n  type GetUsersOptions,\n  type ResolveUsersOptions,\n  type SanityUserResponse,\n  type UsersStoreState,\n} from './types'\nimport {API_VERSION, USERS_STATE_CLEAR_DELAY} from './usersConstants'\n\n/**\n * The users store resource that manages user data fetching and state.\n *\n * This store handles fetching, caching, and managing user data. It provides functionality for\n * retrieving users associated with specific resources and supports pagination through the\n * `loadMoreUsers` action.\n *\n * @internal\n */\nconst usersStore = defineStore<UsersStoreState>({\n  name: 'UsersStore',\n  getInitialState: () => ({users: {}}),\n  initialize: (context) => {\n    const subscription = listenForLoadMoreAndFetch(context)\n    return () => subscription.unsubscribe()\n  },\n})\n\nconst errorHandler =\n  (state: StoreState<{error?: unknown}>) =>\n  (error: unknown): void =>\n    state.set('setError', {error})\n\n/**\n * Internal action that listens for new user subscriptions and load more requests.\n * Fetches user data when new subscriptions are added or when loadMoreUsers is called.\n */\nconst listenForLoadMoreAndFetch = ({state, instance}: StoreContext<UsersStoreState>) => {\n  return state.observable\n    .pipe(\n      map((s) => new Set(Object.keys(s.users))),\n      distinctUntilChanged((curr, next) => {\n        if (curr.size !== next.size) return false\n        return Array.from(next).every((i) => curr.has(i))\n      }),\n      startWith(new Set<string>()),\n      pairwise(),\n      mergeMap(([curr, next]) => {\n        const added = Array.from(next).filter((i) => !curr.has(i))\n        const removed = Array.from(curr).filter((i) => !next.has(i))\n\n        return [\n          ...added.map((key) => ({key, added: true})),\n          ...removed.map((key) => ({key, added: false})),\n        ]\n      }),\n      groupBy((i) => i.key),\n      mergeMap((group$) =>\n        group$.pipe(\n          switchMap((e) => {\n            if (!e.added) return EMPTY\n            const {batchSize, ...options} = parseUsersKey(group$.key)\n\n            const projectId = options.projectId ?? instance.config.projectId\n\n            // the resource type this request will use\n            // If resourceType is explicitly provided, use it\n            // Otherwise, infer from context: organization if organizationId exists,\n            // project if projectId exists, or default to organization\n            const resourceType =\n              options.resourceType ??\n              (options.organizationId ? 'organization' : projectId ? 'project' : 'organization')\n\n            const organizationId$ = options.organizationId\n              ? of(options.organizationId)\n              : getDashboardOrganizationId(instance).observable.pipe(\n                  filter((i) => typeof i === 'string'),\n                )\n\n            const resource$: Observable<{\n              type: 'project' | 'organization'\n              id: string\n            }> =\n              resourceType === 'project'\n                ? projectId\n                  ? of({type: 'project', id: projectId})\n                  : throwError(() => new Error('Project ID required for this API.'))\n                : organizationId$.pipe(map((id) => ({type: 'organization', id})))\n\n            const client$ = getClientState(instance, {\n              scope: 'global',\n              apiVersion: API_VERSION,\n            }).observable\n\n            const loadMore$ = state.observable.pipe(\n              map((s) => s.users[group$.key]?.lastLoadMoreRequest),\n              distinctUntilChanged(),\n            )\n\n            const cursor$ = state.observable.pipe(\n              map((s) => s.users[group$.key]?.nextCursor),\n              distinctUntilChanged(),\n              filter((cursor) => cursor !== null),\n            )\n\n            return combineLatest([resource$, client$, loadMore$]).pipe(\n              withLatestFrom(cursor$),\n              switchMap(([[resource, client], cursor]) =>\n                client.observable.request<SanityUserResponse>({\n                  method: 'GET',\n                  uri: `access/${resource.type}/${resource.id}/users`,\n                  query: cursor\n                    ? {nextCursor: cursor, limit: batchSize.toString()}\n                    : {limit: batchSize.toString()},\n                }),\n              ),\n              catchError((error) => {\n                state.set('setUsersError', setUsersError(group$.key, error))\n                return EMPTY\n              }),\n              tap((response) => state.set('setUsersData', setUsersData(group$.key, response))),\n            )\n          }),\n        ),\n      ),\n    )\n    .subscribe({error: errorHandler(state)})\n}\n\n/**\n * Returns the state source for users associated with a specific resource.\n *\n * This function returns a state source that represents the current list of users for a given\n * resource. Subscribing to the state source will instruct the SDK to fetch the users (if not\n * already fetched) and will load more from this state source as well. When the last subscriber is\n * removed, the users state is automatically cleaned up from the store after a delay.\n *\n * Note: This functionality is for advanced users who want to build their own framework\n * integrations. Our SDK also provides a React integration for convenient usage.\n *\n * @beta\n */\nexport const getUsersState = bindActionGlobally(\n  usersStore,\n  createStateSourceAction({\n    selector: createSelector(\n      [\n        ({instance, state}: SelectorContext<UsersStoreState>, options?: GetUsersOptions) =>\n          state.error ?? state.users[getUsersKey(instance, options)]?.error,\n        ({instance, state}: SelectorContext<UsersStoreState>, options: GetUsersOptions) =>\n          state.users[getUsersKey(instance, options)]?.users,\n        ({instance, state}: SelectorContext<UsersStoreState>, options: GetUsersOptions) =>\n          state.users[getUsersKey(instance, options)]?.totalCount,\n        ({instance, state}: SelectorContext<UsersStoreState>, options: GetUsersOptions) =>\n          state.users[getUsersKey(instance, options)]?.nextCursor,\n      ],\n      (error, data, totalCount, nextCursor) => {\n        if (error) throw error\n        if (data === undefined || totalCount === undefined || nextCursor === undefined) {\n          return undefined\n        }\n\n        return {data, totalCount, hasMore: nextCursor !== null}\n      },\n    ),\n    onSubscribe: ({instance, state}, options?: GetUsersOptions) => {\n      const subscriptionId = insecureRandomId()\n      const key = getUsersKey(instance, options)\n      state.set('addSubscription', addSubscription(subscriptionId, key))\n      return () => {\n        setTimeout(\n          () => state.set('removeSubscription', removeSubscription(subscriptionId, key)),\n          USERS_STATE_CLEAR_DELAY,\n        )\n      }\n    },\n  }),\n)\n\n/**\n * Resolves the users for a specific resource without registering a lasting subscriber.\n *\n * This function fetches the users for a given resource and returns a promise that resolves with\n * the users result. Unlike `getUsersState`, which registers subscribers to keep the data live and\n * performs automatic cleanup, `resolveUsers` does not track subscribers. This makes it ideal for\n * use with React Suspense, where the returned promise is thrown to delay rendering until the users\n * result becomes available. Once the promise resolves, it is expected that a real subscriber will\n * be added via `getUsersState` to manage ongoing updates.\n *\n * Additionally, an optional AbortSignal can be provided to cancel the request and immediately\n * clear the associated state if there are no active subscribers.\n *\n * @beta\n */\nexport const resolveUsers = bindActionGlobally(\n  usersStore,\n  async ({state, instance}, {signal, ...options}: ResolveUsersOptions) => {\n    const key = getUsersKey(instance, options)\n    const {getCurrent} = getUsersState(instance, options)\n\n    const aborted$ = signal\n      ? new Observable<never>((observer) => {\n          const cleanup = () => {\n            signal.removeEventListener('abort', listener)\n          }\n\n          const listener = () => {\n            observer.error(new DOMException('The operation was aborted.', 'AbortError'))\n            observer.complete()\n            cleanup()\n          }\n          signal.addEventListener('abort', listener)\n\n          return cleanup\n        }).pipe(\n          catchError((error) => {\n            if (error instanceof Error && error.name === 'AbortError') {\n              state.set('cancelRequest', cancelRequest(key))\n            }\n            throw error\n          }),\n        )\n      : NEVER\n\n    state.set('initializeRequest', initializeRequest(key))\n\n    const resolved$ = state.observable.pipe(\n      map(getCurrent),\n      first((i) => i !== undefined),\n    )\n\n    return firstValueFrom(race([resolved$, aborted$]))\n  },\n)\n\n/**\n * Loads more users for a specific resource.\n *\n * This function triggers a request to fetch the next page of users for a given resource. It\n * requires that users have already been loaded for the resource (via `resolveUsers` or\n * `getUsersState`), and that there are more users available to load (as indicated by the `hasMore`\n * property).\n *\n * The function returns a promise that resolves when the next page of users has been loaded.\n *\n * @beta\n */\nexport const loadMoreUsers = bindActionGlobally(\n  usersStore,\n  async ({state, instance}, options?: GetUsersOptions) => {\n    const key = getUsersKey(instance, options)\n    const users = getUsersState(instance, options)\n    const usersState = users.getCurrent()\n    if (!usersState) {\n      throw new Error('Users not loaded for specified resource. Please call resolveUsers first.')\n    }\n\n    if (!usersState.hasMore) {\n      throw new Error('No more users available to load for this resource.')\n    }\n\n    const promise = firstValueFrom(\n      users.observable.pipe(\n        filter((i) => i !== undefined),\n        skip(1),\n      ),\n    )\n\n    const timestamp = new Date().toISOString()\n    state.set('updateLastLoadMoreRequest', updateLastLoadMoreRequest(timestamp, key))\n\n    return await promise\n  },\n)\n","const WILDCARD_TOKEN = '*'\nconst NEGATION_TOKEN = '-'\n// This regex handles simple cases including quoted phrases.\n// More complex query syntaxes might need a more robust parser.\nconst TOKEN_REGEX = /(?:[^\\s\"]+|\"[^\"]*\")+/g\n\n/**\n * @internal\n * Checks if a token starts with the negation character.\n */\nfunction isNegationToken(token: string | undefined): boolean {\n  return typeof token !== 'undefined' && token.trim().startsWith(NEGATION_TOKEN)\n}\n\n/**\n * @internal\n * Checks if a token ends with the wildcard character.\n */\nfunction isPrefixToken(token: string | undefined): boolean {\n  return typeof token !== 'undefined' && token.trim().endsWith(WILDCARD_TOKEN)\n}\n\n/**\n * @internal\n * Checks if a token is enclosed in double quotes.\n */\nfunction isExactMatchToken(token: string | undefined): boolean {\n  // Ensure the token exists, has at least 2 characters, and starts/ends with \"\n  return !!token && token.length >= 2 && token.startsWith('\"') && token.endsWith('\"')\n}\n\n/**\n * Creates a GROQ search filter string (`[@] match text::query(\"...\")`)\n * from a raw search query string.\n *\n * It applies wildcard ('*') logic to the last eligible token and escapes\n * double quotes within the search term.\n *\n * If the input query is empty or only whitespace, it returns an empty string.\n *\n * @param query - The raw input search string.\n * @returns The GROQ search filter string, or an empty string.\n * @internal\n */\nexport function createGroqSearchFilter(query: string): string {\n  // Trim leading/trailing whitespace from the overall query first\n  const trimmedQuery = query.trim()\n  if (!trimmedQuery) {\n    return '' // Return empty if query is empty or just whitespace\n  }\n\n  // Extract tokens using the regex\n  const tokens = trimmedQuery.match(TOKEN_REGEX) ?? []\n\n  // Find the index of the last token eligible for wildcard appending\n  const reversedTokens = [...tokens].reverse()\n  const reversedIndex = reversedTokens.findIndex(\n    (token: string) => !isNegationToken(token) && !isExactMatchToken(token),\n  )\n  const finalIncrementalTokenIndex = reversedIndex === -1 ? -1 : tokens.length - 1 - reversedIndex\n\n  // Get the actual token based on the found index\n  const finalIncrementalToken = tokens[finalIncrementalTokenIndex]\n\n  const processedTokens = [...tokens]\n  // If a suitable token was found and it doesn't already end with a wildcard,\n  // apply the wildcard.\n  if (finalIncrementalToken !== undefined && !isPrefixToken(finalIncrementalToken)) {\n    // Replace the identified token with its wildcarded version\n    processedTokens.splice(\n      finalIncrementalTokenIndex,\n      1,\n      `${finalIncrementalToken}${WILDCARD_TOKEN}`,\n    )\n  }\n\n  // Join the tokens back into a space-separated string\n  const wildcardSearch = processedTokens.join(' ')\n\n  // Escape double quotes within the final search term for the GROQ query\n  const escapedSearch = wildcardSearch.replace(/\"/g, '\\\\\"')\n\n  // Construct the final GROQ filter clause\n  return `[@] match text::query(\"${escapedSearch}\")`\n}\n","import {version} from '../package.json'\nimport {getEnv} from './utils/getEnv'\n\n/**\n * This version is provided by pkg-utils at build time\n * @internal\n */\nexport const CORE_SDK_VERSION = getEnv('PKG_VERSION') || `${version}-development`\n"],"names":["AuthStateType","isEqual","DEFAULT_API_VERSION","e","key","destroyController","getOrCreateChannel","getOrCreateController","releaseChannel","unboundDestroyController","unboundGetOrCreateChannel","unboundGetOrCreateController","unboundReleaseChannel","getOrCreateNode","releaseNode","unboundReleaseNode","unboundGetOrCreateNode","switchMap","s","filter","map","i","API_VERSION","a","b","_","m","t","r","n","o","c","u","p","l","f","y","k","j","set","parse","checkGrant","evaluateSync","v","getPublishedId","first","tap","catchError","startWith","pairwise","groupBy","mergeMap","errorHandler","BATCH_DEBOUNCE_TIME","isSetEqual","subscribeToStateAndFetchBatches"],"mappings":"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"}