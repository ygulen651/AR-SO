import { setTimeout } from 'node:timers/promises';
import chalk from 'chalk';
import inquirer from 'inquirer';
import ora from 'ora';
import { destroyStack, getStack } from '../../actions/blueprints/stacks.js';
import { setupLogStreaming } from '../../utils/display/blueprints-logs-streaming.js';
import { niceId } from '../../utils/display/presenters.js';
export async function blueprintDestroyCore(options) {
    const { bin = 'sanity', log, token, blueprint, flags } = options;
    const { force = false, 'project-id': flagProjectId, 'stack-id': flagStackId, 'no-wait': noWait = false, } = flags;
    // 3-flag combo: just destroy it
    if (flagProjectId && flagStackId && force) {
        const { ok, error, stack } = await destroyStack({
            stackId: flagStackId,
            auth: { token, projectId: flagProjectId },
        });
        if (!ok)
            return { success: false, error: error || 'Failed to destroy deployment' };
        log(`Deployment "${stack.name}" ${niceId(stack.id)} destroyed`);
        return { success: true };
    }
    const { projectId, stackId } = blueprint;
    if (!projectId)
        return { success: false, error: 'Project ID is required' };
    const auth = { token, projectId };
    let stack;
    try {
        if (flagStackId) {
            const flagStack = await getStack({ stackId: flagStackId, auth });
            if (!flagStack.ok)
                return { success: false, error: flagStack.error || 'Failed to get stack' };
            stack = flagStack.stack;
        }
        else if (stackId) {
            const blueprintStack = await getStack({ stackId, auth });
            if (!blueprintStack.ok)
                return { success: false, error: blueprintStack.error || 'Failed to get stack' };
            stack = blueprintStack.stack;
        }
        if (!stack)
            return { success: false, error: 'Deployment not found' };
        const destroySpinner = ora({
            text: `Destroying ${chalk.bold(stack.name)} ${niceId(stack.id)}...`,
            color: 'red',
        });
        if (!force) {
            const { confirm } = await inquirer.prompt([
                {
                    type: 'confirm',
                    name: 'confirm',
                    message: `Are you sure you want to destroy stack "${stack.name}" ${niceId(stack.id)}?`,
                    default: false,
                },
            ]);
            if (!confirm) {
                log('Deployment destruction cancelled');
                return { success: true };
            }
            destroySpinner.start();
            // 5 second countdown
            let i = 5;
            while (i >= 0) {
                destroySpinner.text = `Destroying deployment in ${chalk.bold((i--).toString())} seconds...`;
                await setTimeout(1000);
            }
            destroySpinner.text = 'Destroying deployment ðŸ’¥';
            await setTimeout(500);
        }
        else {
            destroySpinner.start();
        }
        const isoNow = new Date().toISOString();
        const { ok, error } = await destroyStack({ stackId: stack.id, auth });
        if (!ok) {
            destroySpinner.fail('Failed to destroy deployment');
            return { success: false, error: error || 'Failed to destroy deployment' };
        }
        destroySpinner.stop().clear();
        if (noWait) {
            log(chalk.bold.magenta('Destruction started!'));
            log(`Use \`${bin} blueprints info\` to check status`);
            return { success: true };
        }
        log(chalk.dim('Destruction progress:'));
        let logStreamCleanup = null;
        try {
            logStreamCleanup = await setupLogStreaming({
                stackId: stack.id,
                after: isoNow,
                auth,
                log,
            });
            while (true) {
                const { ok, stack: currentStack } = await getStack({ stackId: stack.id, auth });
                const operation = currentStack?.recentOperation;
                if (!ok || !operation || operation?.status === 'COMPLETED') {
                    // Operation is also marked destroyed when stack is deleted;
                    // it's possible that the operation is "gone" or available and "COMPLETED"
                    if (logStreamCleanup)
                        logStreamCleanup();
                    log(chalk.bold.magenta('Destruction completed!'));
                    return { success: true };
                }
                if (operation.status === 'FAILED') {
                    if (logStreamCleanup)
                        logStreamCleanup();
                    return { success: false, error: 'Destruction failed' };
                }
                await setTimeout(1500);
            }
        }
        catch (error) {
            if (logStreamCleanup)
                logStreamCleanup();
            throw error;
        }
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { success: false, error: errorMessage };
    }
}
