import { setTimeout } from 'node:timers/promises';
import chalk from 'chalk';
import ora from 'ora';
import { stashAsset } from '../../actions/blueprints/assets.js';
import { getStack, updateStack } from '../../actions/blueprints/stacks.js';
import { setupLogStreaming } from '../../utils/display/blueprints-logs-streaming.js';
import { niceId } from '../../utils/display/presenters.js';
import { isLocalFunctionResource } from '../../utils/types.js';
export async function blueprintDeployCore(options) {
    const { bin = 'sanity', log, auth, stackId, projectId, deployedStack, blueprint, flags } = options;
    const noWait = flags['no-wait'] || false;
    log(`Deploying "${deployedStack.name}" ${niceId(deployedStack.id)}...`);
    try {
        const { resources } = blueprint.parsedBlueprint;
        const validResources = resources?.filter((r) => r.type);
        const functionResources = validResources?.filter(isLocalFunctionResource);
        // First stash all function assets
        if (functionResources?.length) {
            log('Processing function assets...');
            for (const resource of functionResources) {
                const fnSpinner = ora({ text: `Processing ${resource.name}...`, prefixText: ' ' }).start();
                const result = await stashAsset({ resource, auth });
                if (result.success && result.assetId) {
                    const src = resource.src;
                    resource.src = result.assetId; // TODO: properly reference asset - for now, the API expects the assetId
                    fnSpinner.succeed(`${resource.name} ${niceId(result.assetId)}`);
                    log(`   Source: ${src}`);
                }
                else {
                    fnSpinner.fail(`Failed to process ${resource.name}`);
                    log(`   Error: ${result.error}`);
                    return { success: false, error: result.error || 'Failed to process function resource' };
                }
            }
        }
        const stackMutation = {
            projectId,
            name: deployedStack.name,
            document: { resources: validResources },
        };
        const spinner = ora('Deploying...').start();
        const isoNow = new Date().toISOString();
        const { ok: deployOk, stack, error: deployError, } = await updateStack({ stackId, stackMutation, auth });
        if (!deployOk) {
            spinner.fail(`${chalk.red('Failed')} to update deployment`);
            return { success: false, error: deployError || 'Failed to update deployment' };
        }
        spinner.stop().clear();
        if (noWait) {
            log(chalk.bold.green('Deployment started!'));
            log(`Use \`${bin} blueprints info\` to check status`);
            return { success: true };
        }
        log(chalk.dim('Deployment progress:'));
        let logStreamCleanup = null;
        try {
            logStreamCleanup = await setupLogStreaming({
                stackId: stack.id,
                after: isoNow,
                auth,
                log,
            });
            while (true) {
                const { ok, stack: currentStack } = await getStack({ stackId: stack.id, auth });
                if (!ok) {
                    if (logStreamCleanup)
                        logStreamCleanup();
                    return { success: false, error: 'Failed to check deployment status' };
                }
                const operation = currentStack.recentOperation;
                if (!operation) {
                    if (logStreamCleanup)
                        logStreamCleanup();
                    return { success: false, error: 'No deployment operation found' };
                }
                if (operation.status === 'FAILED') {
                    if (logStreamCleanup)
                        logStreamCleanup();
                    return { success: false, error: 'Deployment failed' };
                }
                if (operation.status === 'COMPLETED') {
                    if (logStreamCleanup)
                        logStreamCleanup();
                    log(chalk.bold.green('Deployment completed!'));
                    return { success: true };
                }
                await setTimeout(1500);
            }
        }
        catch (error) {
            if (logStreamCleanup)
                logStreamCleanup();
            throw error;
        }
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { success: false, error: errorMessage };
    }
}
