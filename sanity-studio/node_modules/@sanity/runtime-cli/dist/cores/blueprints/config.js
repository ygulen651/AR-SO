import { highlight } from 'cardinal';
import chalk from 'chalk';
import inquirer from 'inquirer';
import ora from 'ora';
import { BLUEPRINT_CONFIG_FILE, BLUEPRINT_DIR, writeConfigFile, } from '../../actions/blueprints/blueprint.js';
import { createStack, getStack } from '../../actions/blueprints/stacks.js';
import { getProject } from '../../actions/sanity/projects.js';
import { niceId, warn } from '../../utils/display/presenters.js';
import { promptForProject } from '../../utils/display/prompt.js';
export async function blueprintConfigCore(options) {
    const { bin = 'sanity', log, token, flags } = options;
    const { edit: editConfig = false, 'test-config': testConfig = false, 'project-id': flagProjectId, 'stack-id': flagStackId, } = flags;
    const { blueprint } = options;
    const { stackId: configStackId, projectId: configProjectId } = blueprint;
    try {
        if (!configStackId && !configProjectId) {
            log(warn('Missing local configuration.'));
            if (!editConfig) {
                // blueprint.json exists but no config JSON
                log(`Use \`${bin} blueprints config --edit\` to set a configuration.`);
                return { success: true }; // not necessarily fatal
            }
        }
        log(chalk.bold('Current configuration:'));
        log(`  Sanity Project: ${niceId(configProjectId)}`);
        log(`  Deployment ID:  ${niceId(configStackId)}`);
        // passing new config without --edit flag is not allowed
        if ((flagProjectId || flagStackId) && !editConfig) {
            log('To update the configuration, use the --edit flag.');
            return { success: true };
        }
        // no edit or test: return success
        if (!editConfig && !testConfig)
            return { success: true };
        // testing without editing
        if (testConfig && !editConfig) {
            if (configStackId && configProjectId) {
                const testResult = await testConfigAndReport({
                    token,
                    stackId: configStackId,
                    projectId: configProjectId,
                });
                if (!testResult.ok) {
                    // command should exit with error code 1
                    return { success: false, error: 'Existing Blueprint deployment not found.' };
                }
                return { success: testResult.ok };
            }
            return {
                success: false,
                error: 'Unable to test the configuration. Both Project and Stack IDs must be set.',
            };
        }
        // editing...
        if (editConfig) {
            const updatedProjectId = flagProjectId ||
                (await promptForProject({
                    token,
                    knownProjectId: configProjectId,
                })).projectId;
            if (!updatedProjectId) {
                return {
                    success: false,
                    error: 'Project ID is required.',
                };
            }
            // LAUNCH LIMIT: 1 Stack per Project - configStackId is always inferred from projectId if not set in config JSON
            let updatedStackId = flagStackId ?? // flag first
                configStackId ?? // existing config second
                `ST-${updatedProjectId}`; //?? LAUNCH LIMIT: 1 Stack per Project - project-based third
            // (await promptForStackId({projectId: updatedProjectId, knownStackId: configStackId})) // prompt for stackId
            const isProjectBasedId = updatedStackId === `ST-${updatedProjectId}`;
            log(`\n${chalk.bold('New configuration:')}`);
            log(`  Sanity Project: ${niceId(updatedProjectId)}`);
            log(`  Deployment ID:  ${niceId(updatedStackId)}`);
            if (testConfig) {
                if (updatedProjectId && updatedStackId) {
                    const { ok: newConfigOk, error: configError } = await testConfigAndReport({
                        token,
                        stackId: updatedStackId,
                        projectId: updatedProjectId,
                    });
                    if (!newConfigOk) {
                        // is this a projectBasedId stack?
                        if (isProjectBasedId) {
                            log(warn('Existing Blueprint deployment not found.'));
                            const reinitResult = await startReinitializeStack({
                                token,
                                projectId: updatedProjectId,
                                stackId: updatedStackId,
                            });
                            if (!reinitResult.ok) {
                                return { success: false, error: reinitResult.error || 'Failed to reinitialize stack' };
                            }
                            log(`New Blueprint deployment created for "${reinitResult.projectDisplayName}"`);
                            // continuing to save the config
                        }
                        else {
                            return {
                                success: false,
                                error: configError || 'Updated configuration has not been saved.',
                            };
                        }
                    }
                }
                else {
                    return {
                        success: false,
                        error: 'Unable to test the configuration. Both Project and Stack IDs must be set.',
                    };
                }
            }
            // LAUNCH LIMIT: 1 Stack per Project - do not set Stack ID if it's project-based
            if (isProjectBasedId)
                updatedStackId = undefined;
            try {
                // update or create config JSON
                writeConfigFile({ projectId: updatedProjectId, stackId: updatedStackId });
                log('Configuration updated successfully.');
                return { success: true };
            }
            catch (error) {
                log(`Unable to update config. These values should be set in ${BLUEPRINT_DIR}/${BLUEPRINT_CONFIG_FILE}`);
                log(highlight(JSON.stringify({ metadata: { projectId: updatedProjectId, stackId: updatedStackId } }, null, 2)));
                return {
                    success: false,
                    error: `Be sure to update your ${BLUEPRINT_DIR}/${BLUEPRINT_CONFIG_FILE}`,
                };
            }
        }
        // Default return (shouldn't reach here with proper flow control)
        return { success: true };
    }
    catch (error) {
        return { success: false, error: 'Unknown error' };
    }
}
async function testConfigAndReport({ token, stackId, projectId, }) {
    const spinner = ora('Testing the configuration...').start();
    const { ok, error } = await getStack({
        stackId,
        auth: { token, projectId },
    });
    if (!ok) {
        spinner.fail('Configuration test failed.');
    }
    else {
        spinner.succeed('Configuration is valid.');
    }
    return { ok, error };
}
async function startReinitializeStack({ token, projectId, }) {
    const auth = { token, projectId };
    // stack id IS ST-${projectId} â€“ it has already been checked and doesn't exist
    const { confirm } = await inquirer.prompt([
        {
            type: 'confirm',
            name: 'confirm',
            message: `Do you want to create a ${chalk.blue('new')}, empty Blueprint deployment with the ${chalk.blue('existing')} configuration?`,
        },
    ]);
    if (!confirm)
        return { ok: false, error: 'Reinitialization cancelled.' };
    const { ok: projectOk, project, error: projectError } = await getProject(auth);
    if (!projectOk) {
        return {
            ok: false,
            error: projectError || 'Failed to find Project while creating Stack',
        };
    }
    const projectDisplayName = project.displayName;
    const stackMutation = { name: projectDisplayName, projectId, document: { resources: [] } };
    const response = await createStack({ stackMutation, auth });
    if (!response.ok)
        return { ok: false, error: response.error || 'Failed to create new Stack' };
    return {
        ok: true,
        stackId: response.stack.id,
        projectDisplayName,
    };
}
