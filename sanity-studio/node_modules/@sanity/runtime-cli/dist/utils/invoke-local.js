import { spawn } from 'node:child_process';
import { performance } from 'node:perf_hooks';
import { cwd } from 'node:process';
import { setTimeout } from 'node:timers';
import { fileURLToPath } from 'node:url';
import * as groq from 'groq-js';
import config from '../config.js';
import { findFunctionEntryPoint } from './functions/find-entry-point.js';
import { cleanupTempPackageJson, createTempPackageJson, doesPackageJsonExists, } from './functions/packageJsonUtils.js';
import { resolveResourceDependencies } from './functions/resolve-dependencies.js';
import { shouldAutoResolveDependencies } from './functions/should-auto-resolve-deps.js';
import { shouldTranspileFunction } from './functions/should-transpile.js';
import { transpileFunction } from './transpile/transpile-function.js';
function getChildProcessWrapperPath() {
    return fileURLToPath(new URL('./child-process-wrapper.js', import.meta.url));
}
export function sanitizeLogs(logs) {
    return logs.replace(/([a-zA-Z0-9]{10})[a-zA-Z0-9]{65,}/g, '$1**********');
}
export const DEFAULT_GROQ_RULE = { on: ['publish'], filter: '', projection: '' };
export function isDefaultGROQRule(rule) {
    if (!rule)
        return true;
    return (Array.isArray(rule.on) &&
        rule.on.length === DEFAULT_GROQ_RULE.on.length &&
        rule.on.every((v) => DEFAULT_GROQ_RULE.on.includes(v)) &&
        rule.filter === DEFAULT_GROQ_RULE.filter &&
        rule.projection === DEFAULT_GROQ_RULE.projection);
}
function getEvent(rule) {
    return {
        on: rule.on || DEFAULT_GROQ_RULE.on,
        filter: rule.filter || DEFAULT_GROQ_RULE.filter,
        projection: rule.projection || DEFAULT_GROQ_RULE.projection,
    };
}
export async function applyGroqRule(resource, data) {
    // If there is no rule set return everything
    if (!resource.event)
        return data;
    // default groq rule is: gimme full doc content. otherwise, parse + eval custom rule
    // applying the GROQ filter may result in a slimmer set of documents
    const event = getEvent(resource.event);
    if (!isDefaultGROQRule(event)) {
        const hasProjection = event.projection?.length;
        const projection = hasProjection ? `{${event?.projection}}` : '';
        const query = `*[${event?.filter}]${projection}`;
        try {
            const rule = groq.parse(query);
            const queryResults = await groq.evaluate(rule, { dataset: [data] });
            const currentFunctionDocumentSet = await queryResults.get();
            // TODO can this be multiple documents?
            return currentFunctionDocumentSet[0] || {};
        }
        catch (e) {
            // parsing/validating the groq rule we do up front as part of functions HTTP API
            // so this likely would be triggered by evaluating the query, if anything
            throw Error('⚠️ failed parsing/evaluating GROQ rule! Skipping invoke.');
        }
    }
    // default groq rule so just return the data
    return data;
}
export default async function invoke(resource, data, context, options) {
    if (!resource.src) {
        throw new Error(`Function resource "${resource.name}" is missing the 'src' property.`);
    }
    const { forceColor = true, timeout = 10 } = options;
    const filteredData = await applyGroqRule(resource, data);
    let cleanupBundle = async () => { };
    let functionPath = '';
    let bundleTimings = undefined;
    // If no package.json exists we will create a temporary one to avoid the
    // Module Type warning from node
    const existingPackageJson = doesPackageJsonExists(resource);
    const shouldTranspile = await shouldTranspileFunction(resource);
    if (shouldTranspile) {
        const transpileResult = await transpileFunction(resource);
        functionPath = await findFunctionEntryPoint(transpileResult.outputDir);
        bundleTimings = transpileResult.timings;
        cleanupBundle = transpileResult.cleanup;
    }
    else {
        functionPath = await findFunctionEntryPoint(resource.src, resource.displayName ?? resource.name);
    }
    const shouldResolveDependencies = await shouldAutoResolveDependencies(resource);
    if (shouldResolveDependencies && existingPackageJson) {
        await resolveResourceDependencies(resource, shouldTranspile);
    }
    if (!existingPackageJson) {
        createTempPackageJson(functionPath);
    }
    return new Promise((resolve, reject) => {
        let child;
        let timer;
        let executionStart;
        function start() {
            executionStart = performance.now();
            child = spawn('node', ['--enable-source-maps', getChildProcessWrapperPath()], {
                cwd: cwd(),
                stdio: ['inherit', 'inherit', 'inherit', 'ipc'],
                env: { ...process.env, ...resource.env, FORCE_COLOR: forceColor ? '1' : '0' },
            });
            child.on('message', (data) => {
                const executionTimeMs = performance.now() - executionStart;
                const { json, logs } = JSON.parse(data.toString());
                shutdown();
                resolve({
                    json,
                    logs: sanitizeLogs(logs),
                    error: undefined,
                    timings: {
                        ...bundleTimings,
                        execute: executionTimeMs,
                    },
                });
            });
            child.on('error', (error) => {
                shutdown();
                reject(new Error(`encountered error ${error.message}`));
            });
            child.on('exit', (code) => {
                const executionTimeMs = performance.now() - executionStart;
                shutdown();
                if (code !== 0) {
                    reject(new Error(`exited with code ${code}`));
                }
                else {
                    resolve({
                        json: undefined,
                        logs: '',
                        error: undefined,
                        timings: {
                            ...bundleTimings,
                            execute: executionTimeMs,
                        },
                    });
                }
            });
            timer = setTimeout(() => {
                shutdown();
                reject(new Error(`Timeout: The process exceeded your current timeout limit of ${timeout} seconds. Learn to adjust your Blueprint's timeout settings here: https://www.sanity.io/docs/help/functions-timeout`));
            }, timeout * 1000);
            const payload = {
                data: { ...filteredData },
                context: {
                    ...context,
                    local: true,
                    clientOptions: {
                        ...context.clientOptions,
                        apiHost: config.apiUrl,
                    },
                },
            };
            child.send(JSON.stringify({ srcPath: functionPath, payload }, null, 2));
        }
        function shutdown() {
            clearTimeout(timer);
            if (child && !child.killed) {
                child.kill();
            }
            // If we previously created a temporary package.json, let's clean it up
            if (!existingPackageJson) {
                cleanupTempPackageJson(functionPath);
            }
            cleanupBundle().catch((err) => console.warn('Bundle cleanup failed:', err));
        }
        start();
    });
}
