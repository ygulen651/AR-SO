{"version":3,"file":"index.cjs","sources":["../src/createSessionId.ts","../src/createTraceId.ts","../src/utils/trimErrorMessage.ts","../src/createStore.ts","../src/createBatchedStore.ts","../src/defineEvent.ts","../src/defineTrace.ts"],"sourcesContent":["import {typeid} from 'typeid-js'\n\n/**\n * @public\n */\nexport type SessionId = string & {__type: 'SessionId'}\n\nexport function createSessionId(): SessionId {\n  return typeid('session').toString() as SessionId\n}\n","import {typeid} from 'typeid-js'\n\n/**\n * @public\n */\nexport type TraceId = string & {__type: 'TraceId'}\n\nexport function createTraceId(): TraceId {\n  return typeid('trace').toString() as TraceId\n}\n","function splitAt(str: string, index: number) {\n  return index < 1 ? [str, ''] : [str.substring(0, index), str.substring(index)]\n}\n\nconst MAX_LENGTH = 1024\n\nexport function trimErrorMessage(errorMessage: string) {\n  const newLineIndex = errorMessage.indexOf('\\n')\n  const splitIndex =\n    newLineIndex === -1 ? MAX_LENGTH : Math.min(newLineIndex, MAX_LENGTH)\n  const [first, rest] = splitAt(errorMessage, splitIndex)\n\n  return first + (rest ? `â€¦ (+${rest.length})` : '')\n}\n","import {\n  DefinedTelemetryLog,\n  DefinedTelemetryTrace,\n  TelemetryEvent,\n  TelemetryLogEvent,\n  TelemetryLogger,\n  TelemetryTrace,\n  TelemetryTraceEvent,\n} from './types'\nimport {Observable, Subject} from 'rxjs'\nimport {SessionId} from './createSessionId'\nimport {createTraceId} from './createTraceId'\nimport {trimErrorMessage} from './utils/trimErrorMessage'\n\n/**\n * Bare-bones store for logging and reacting to telemetry events\n * @internal\n * @param sessionId\n */\nexport function createStore<UserProperties>(sessionId: SessionId): {\n  events$: Observable<TelemetryEvent>\n  logger: TelemetryLogger<UserProperties>\n} {\n  const logEntries$ = new Subject<TelemetryEvent>()\n  const eventSampleTimes = new WeakMap<DefinedTelemetryLog<unknown>, Date>()\n\n  function pushTraceError<Data, Err extends {message: string}>(\n    traceId: string,\n    telemetryTrace: DefinedTelemetryTrace<Data>,\n    error: {message: string},\n    context: unknown,\n  ) {\n    logEntries$.next({\n      sessionId,\n      type: 'trace.error',\n      traceId,\n      name: telemetryTrace.name,\n      version: telemetryTrace.version,\n      data: {message: trimErrorMessage(error.message)},\n      context,\n      createdAt: new Date().toISOString(),\n    })\n  }\n\n  function pushTraceEntry<Data>(\n    type: 'trace.start',\n    traceId: string,\n    telemetryTrace: DefinedTelemetryTrace<Data>,\n    data: undefined,\n    context: unknown,\n  ): void\n  function pushTraceEntry<Data>(\n    type: 'trace.log',\n    traceId: string,\n    telemetryTrace: DefinedTelemetryTrace<Data>,\n    data: Data,\n    context: unknown,\n  ): void\n  function pushTraceEntry<Data>(\n    type: 'trace.complete',\n    traceId: string,\n    telemetryTrace: DefinedTelemetryTrace<Data>,\n    data: Data,\n    context: unknown,\n  ): void\n\n  function pushTraceEntry<Data>(\n    type: TelemetryTraceEvent['type'],\n    traceId: string,\n    telemetryTrace: DefinedTelemetryTrace<Data>,\n    data: Data,\n    context: unknown,\n  ) {\n    logEntries$.next({\n      sessionId,\n      type,\n      traceId,\n      name: telemetryTrace.name,\n      version: telemetryTrace.version,\n      data,\n      context,\n      createdAt: new Date().toISOString(),\n    })\n  }\n\n  function pushLogEntry<Data>(\n    type: TelemetryLogEvent['type'],\n    event: DefinedTelemetryLog<Data>,\n    data?: unknown,\n  ) {\n    logEntries$.next({\n      sessionId,\n      type,\n      version: event.version,\n      name: event.name,\n      data,\n      createdAt: new Date().toISOString(),\n    })\n  }\n\n  function pushUserPropertiesEntry(properties: UserProperties) {\n    logEntries$.next({\n      sessionId,\n      type: 'userProperties',\n      properties: properties,\n      createdAt: new Date().toISOString(),\n    })\n  }\n\n  function createTrace<Data = void>(\n    traceId: string,\n    traceDef: DefinedTelemetryTrace<Data>,\n    context: unknown,\n  ): TelemetryTrace<UserProperties, Data> {\n    return {\n      start() {\n        pushTraceEntry('trace.start', traceId, traceDef, undefined, context)\n      },\n      newContext(name: string): TelemetryLogger<UserProperties> {\n        return {\n          trace<InnerData>(innerTraceDef: DefinedTelemetryTrace<InnerData>) {\n            return createTrace<InnerData>(\n              `${traceId}.${name}`,\n              innerTraceDef,\n              context,\n            )\n          },\n          updateUserProperties() {},\n          log,\n        }\n      },\n      log(data?: unknown) {\n        pushTraceEntry('trace.log', traceId, traceDef, data, context)\n      },\n      complete() {\n        pushTraceEntry('trace.complete', traceId, traceDef, undefined, context)\n      },\n      error(error: {message: string}) {\n        pushTraceError(traceId, traceDef, error, context)\n      },\n      await<P extends Promise<Data>>(promise: P, data?: Data): P {\n        this.start()\n        promise.then(\n          (result) => {\n            this.log(data ? data : result)\n            this.complete()\n            return result\n          },\n          (error) => {\n            this.error(error)\n            throw error\n          },\n        )\n        return promise\n      },\n    }\n  }\n\n  function log<Data>(event: DefinedTelemetryLog<Data>, data?: Data) {\n    if (typeof event.maxSampleRate === 'number' && event.maxSampleRate > 0) {\n      const lastSampledAt = eventSampleTimes.get(event)\n      const now = new Date()\n      if (\n        !lastSampledAt ||\n        now.getTime() - lastSampledAt.getTime() > event.maxSampleRate\n      ) {\n        eventSampleTimes.set(event, now)\n        pushLogEntry('log', event, data)\n      }\n    } else {\n      pushLogEntry('log', event, data)\n    }\n  }\n\n  return {\n    events$: logEntries$.asObservable(),\n    logger: {\n      updateUserProperties(properties: UserProperties) {\n        pushUserPropertiesEntry(properties)\n      },\n      trace: <Data>(\n        traceDef: DefinedTelemetryTrace<Data>,\n        context: unknown,\n      ) => {\n        const traceId = createTraceId()\n        return createTrace(traceId, traceDef, context)\n      },\n      log,\n    },\n  }\n}\n","import {TelemetryEvent, TelemetryStore} from './types'\nimport {\n  catchError,\n  combineLatest,\n  combineLatestAll,\n  concatMap,\n  EMPTY,\n  from,\n  lastValueFrom,\n  map,\n  mergeMap,\n  Observable,\n  of,\n  tap,\n  throttle,\n} from 'rxjs'\nimport {SessionId} from './createSessionId'\nimport {createStore} from './createStore'\n\n/**\n * This is like rxjs.timer() except for that it's calling timeout.unref()\n * This prevents the timer from keeping the event loop active https://nodejs.org/api/timers.html#timeoutunref\n * We don't want any of our timers to hold up the process from completing\n * @param ms\n */\nconst unrefTimer = (ms: number) =>\n  new Observable((subscriber) => {\n    const timeout = setTimeout(() => {\n      subscriber.next()\n      subscriber.complete()\n    }, ms)\n    if (typeof timeout.unref === 'function') {\n      // unref the timeout to avoid holding the process open in node.js\n      timeout.unref()\n    }\n    return () => clearTimeout(timeout)\n  })\n\n/**\n * 'unknown' - we don't know if the user has consented or not (e.g. something went wrong)\n * 'unset' - the user has not yet been asked for consent\n * 'granted' - the user has consented\n * 'denied' - the user has denied consent\n */\nexport type ConsentStatus = 'undetermined' | 'unset' | 'granted' | 'denied'\n\nexport interface CreateBatchedStoreOptions {\n  /**\n   * Optionally provide a flush interval\n   */\n  flushInterval?: number\n\n  /**\n   *  Provide a strategy for resolving consent depending on context (e.g. studio/cli)\n   *  @public\n   */\n  resolveConsent: () => Promise<{status: ConsentStatus}>\n  /**\n   * Provide a strategy for submitting events (e.g. using fetch in browser, or node server side)\n   * @public\n   */\n  sendEvents: (events: TelemetryEvent[]) => Promise<unknown>\n\n  /**\n   * Optionally provide a strategy for submitting final events (e.g. events that's queued when the browser exits)\n   * @public\n   */\n  sendBeacon?: (events: TelemetryEvent[]) => boolean\n}\n\nexport function createBatchedStore<UserProperties>(\n  sessionId: SessionId,\n  options: CreateBatchedStoreOptions,\n): TelemetryStore<UserProperties> {\n  const store = createStore<UserProperties>(sessionId)\n\n  function resolveConsent(): Promise<{status: ConsentStatus}> {\n    return options.resolveConsent().catch((err) =>\n      // if we for some reason can't fetch consent we treat it as \"undetermined\", and try again at next flush\n      ({status: 'undetermined' as const}),\n    )\n  }\n\n  const _buffer: TelemetryEvent[] = []\n\n  function consume() {\n    const buf = _buffer.slice()\n    _buffer.length = 0\n    return buf\n  }\n\n  function submit() {\n    const pending = consume()\n    if (pending.length === 0) {\n      return EMPTY\n    }\n    return combineLatest([of(pending), resolveConsent()]).pipe(\n      mergeMap(([events, consent]) => {\n        if (events.length === 0 || consent.status !== 'granted') {\n          // consent is not granted, we just consumed (cleared) the buffer so we can return empty\n          return EMPTY\n        }\n        return from(options.sendEvents(events)).pipe(\n          catchError((err) => {\n            // In case of error, put events back on the buffer\n            _buffer.unshift(...events)\n            // and ignore the error\n            return EMPTY\n          }),\n        )\n      }),\n    )\n  }\n\n  const flushInterval = options.flushInterval ?? 30000\n\n  const flush$ = store.events$.pipe(\n    tap((ev) => _buffer.push(ev)),\n    map(() => {}), // void to avoid accidental use of events further down the pipe\n    throttle(() => unrefTimer(flushInterval), {\n      leading: false,\n      trailing: true,\n    }),\n    concatMap(() => submit()),\n  )\n\n  function flush() {\n    return lastValueFrom(submit(), {\n      defaultValue: undefined,\n    }).then(() => {})\n  }\n\n  // start subscribing to events\n  const subscription = flush$.subscribe()\n\n  function endWithBeacon() {\n    if (!options.sendBeacon) {\n      // we don't have a beacon strategy, so we just flush - this may make us lose events, but it's the best we can do\n      end()\n      return true\n    }\n    const events = consume()\n    subscription.unsubscribe()\n    return events.length > 0 ? options.sendBeacon(events) : true\n  }\n\n  function end() {\n    // flush before destroying\n    return flush()\n      .then(\n        () => {}, // void promise\n        () => {}, // ignore errors\n      )\n      .finally(() => {\n        // Note: we might end up with an error here\n        subscription.unsubscribe()\n      })\n  }\n\n  return {\n    end,\n    endWithBeacon,\n    // Note: flush may fail\n    flush,\n    logger: store.logger,\n  }\n}\n","import {DefinedTelemetryLog, TelemetryLogOptions} from './types'\n\n/**\n * @param options\n */\nexport function defineEvent<Data = void>(\n  options: TelemetryLogOptions,\n): DefinedTelemetryLog<Data> {\n  return {\n    type: 'log',\n    name: options.name,\n    version: options.version,\n    description: options.description,\n    maxSampleRate: options.maxSampleRate,\n    schema: undefined as unknown as Data,\n  }\n}\n","import {DefinedTelemetryTrace, TelemetryTraceOptions} from './types'\n\n/**\n * @param options\n * */\nexport function defineTrace<Data = void, Context = void>(\n  options: TelemetryTraceOptions,\n): DefinedTelemetryTrace<Data, Context> {\n  return {\n    type: 'trace',\n    name: options.name,\n    version: options.version,\n    description: options.description,\n    schema: undefined as unknown as Data,\n    context: undefined as unknown as Context,\n  }\n}\n"],"names":["createSessionId","typeid","toString","createTraceId","splitAt","str","index","substring","MAX_LENGTH","trimErrorMessage","errorMessage","newLineIndex","indexOf","splitIndex","Math","min","first","rest","concat","length","createStore","sessionId","logEntries$","Subject","eventSampleTimes","WeakMap","pushTraceError","traceId","telemetryTrace","error","context","next","type","name","version","data","message","createdAt","Date","toISOString","pushTraceEntry","pushLogEntry","event","pushUserPropertiesEntry","properties","createTrace","traceDef","start","newContext","trace","innerTraceDef","updateUserProperties","log","complete","await","promise","then","result","maxSampleRate","lastSampledAt","get","now","getTime","set","events$","asObservable","logger","unrefTimer","ms","Observable","subscriber","timeout","setTimeout","unref","clearTimeout","createBatchedStore","options","_a","store","resolveConsent","catch","err","status","_buffer","consume","buf","slice","submit","pending","EMPTY","combineLatest","of","pipe","mergeMap","_ref","events","consent","from","sendEvents","catchError","unshift","flushInterval","flush$","tap","ev","push","map","throttle","leading","trailing","concatMap","flush","lastValueFrom","defaultValue","subscription","subscribe","endWithBeacon","sendBeacon","end","unsubscribe","finally","defineEvent","description","schema","defineTrace"],"mappings":"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"}