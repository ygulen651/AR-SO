{"version":3,"file":"router.js","sources":["../src/router/useRouter.ts","../src/router/useLink.ts","../src/router/useIntentLink.ts","../src/router/IntentLink.tsx","../src/router/Link.tsx","../src/router/_parseRoute.ts","../src/router/utils/arrayify.ts","../src/router/_findMatchingRoutes.ts","../src/router/encodeURIComponentExcept.ts","../src/router/utils/debug.ts","../src/router/_resolvePathFromState.ts","../src/router/utils/parseScopedParams.ts","../src/router/_resolveStateFromPath.ts","../src/router/utils/base64url.ts","../src/router/utils/jsonParamsEncoding.ts","../src/router/utils/paramsEncoding.ts","../src/router/route.ts","../src/router/stickyParams.ts","../src/router/types.ts","../src/router/RouterProvider.tsx","../src/router/RouteScope.tsx","../src/router/useStateLink.ts","../src/router/StateLink.tsx","../src/router/useRouterState.ts","../src/router/withRouter.tsx"],"sourcesContent":["import {useContext} from 'react'\nimport {RouterContext} from 'sanity/_singletons'\n\nimport {type RouterContextValue} from './types'\n\n/**\n * Returns the router context value.\n * @public\n *\n * @returns The router context value.\n *  {@link RouterContextValue}\n * @throws An error if the router context value is missing.\n *\n * @example\n * ```tsx\n * const router = useRouter()\n * ```\n */\nexport function useRouter(): RouterContextValue {\n  const router = useContext(RouterContext)\n\n  if (!router) {\n    throw new Error('Router: missing context value')\n  }\n\n  return router\n}\n","import {useCallback} from 'react'\n\nimport {useRouter} from './useRouter'\n\nfunction isLeftClickEvent(event: React.MouseEvent) {\n  return event.button === 0\n}\n\nfunction isModifiedEvent(event: React.MouseEvent) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)\n}\n\n/**\n * @public\n */\nexport interface UseLinkOptions {\n  /**\n   * The URL that the link should navigate to.\n   */\n  href?: string\n\n  /**\n   * The event handler function that should be called when the link is clicked.\n   */\n  onClick?: React.MouseEventHandler<HTMLElement>\n\n  /**\n   * Whether the link should replace the current URL in the browser history.\n   */\n  replace?: boolean\n\n  /**\n   * The target window or frame that the linked document will open in.\n   */\n  target?: string\n}\n\n/**\n * Returns an object with an `onClick` function that can be used as a click handler for a link.\n *\n * @public\n *\n * @param options - An object containing the properties for the link.\n *  See {@link UseLinkOptions}\n *\n * @returns An object with an `onClick` function.\n *\n * @example\n * ```tsx\n * const linkProps = useLink({\n *  href: 'https://www.sanity.io',\n *  target: '_blank'\n * })\n *\n * <a {...linkProps}>Link</a>\n * ```\n */\nexport function useLink(options: UseLinkOptions): {onClick: React.MouseEventHandler<HTMLElement>} {\n  const {onClick: onClickProp, href, target, replace = false} = options\n  const {navigateUrl} = useRouter()\n\n  const onClick = useCallback(\n    (event: React.MouseEvent<HTMLElement>): void => {\n      if (event.isDefaultPrevented()) {\n        return\n      }\n\n      if (!href) return\n\n      if (onClickProp) {\n        onClickProp(event)\n      }\n\n      if (isModifiedEvent(event) || !isLeftClickEvent(event)) {\n        return\n      }\n\n      // If target prop is set (e.g. to \"_blank\") let browser handle link.\n      if (target) {\n        return\n      }\n\n      event.preventDefault()\n\n      navigateUrl({path: href, replace})\n    },\n    [href, navigateUrl, onClickProp, replace, target],\n  )\n\n  return {onClick: onClick}\n}\n","import {useMemo} from 'react'\n\nimport {type IntentParameters, type SearchParam} from './types'\nimport {useLink} from './useLink'\nimport {useRouter} from './useRouter'\n\n/**\n * @public\n */\nexport interface UseIntentLinkOptions {\n  /**\n   * The name of the intent to trigger.\n   */\n  intent: string\n\n  /**\n   * An optional click event handler.\n   */\n  onClick?: React.MouseEventHandler<HTMLElement>\n\n  /**\n   * Optional parameters to pass to the intent. See {@link IntentParameters}\n   */\n  params?: IntentParameters\n\n  /**\n   * Whether to replace the current URL in the browser history.\n   */\n  replace?: boolean\n\n  /**\n   * The target window or frame to open the link in.\n   */\n  target?: string\n  searchParams?: SearchParam[]\n}\n\n/**\n *\n * Returns props for an anchor element that will trigger an intent when clicked.\n *\n * @example\n * ```tsx\n * const {onClick, href} = useIntentLink({\n *   intent: 'edit',\n *   params: {id: 'foo'}\n * })\n *\n * <a href={href} onClick={onClick}>Link to \"foo\" editor</a>\n * ```\n *\n * @public\n *\n * @param options - Options to use for the link\n *  {@link UseIntentLinkOptions}\n *\n * @returns - An object with `onClick` and `href` props to use for the link\n */\nexport function useIntentLink(options: UseIntentLinkOptions): {\n  onClick: React.MouseEventHandler<HTMLElement>\n  href: string\n} {\n  const {intent, onClick: onClickProp, params, replace, target, searchParams} = options\n  const {resolveIntentLink} = useRouter()\n  const href = useMemo(\n    () => resolveIntentLink(intent, params, searchParams),\n    [intent, params, searchParams, resolveIntentLink],\n  )\n  const {onClick} = useLink({href, onClick: onClickProp, replace, target})\n\n  return {onClick, href}\n}\n","import {type ForwardedRef, forwardRef, type HTMLProps} from 'react'\n\nimport {type IntentParameters, type SearchParam} from './types'\nimport {useIntentLink} from './useIntentLink'\n\n/**\n * Props for the {@link IntentLink} component.\n *\n * @public\n */\nexport interface IntentLinkProps {\n  /**\n   * The name of the intent.\n   */\n  intent: string\n\n  /**\n   * The parameters to include in the intent.\n   * {@link IntentParameters}\n   */\n  params?: IntentParameters\n\n  /**\n   * Whether to replace the current URL in the browser history instead of adding a new entry.\n   */\n  replace?: boolean\n\n  /**\n   * search params to include in the intent.\n   */\n  searchParams?: SearchParam[]\n}\n\n/**\n * @public\n *\n * @param props - Props to pass to `IntentLink` component.\n *  See {@link IntentLinkProps}\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *  return <IntentLink intent=\"edit\" params={{id: 'abc123'}}>Edit</IntentLink>\n * }\n * ```\n */\nexport const IntentLink = forwardRef(function IntentLink(\n  props: IntentLinkProps & HTMLProps<HTMLAnchorElement>,\n  ref: ForwardedRef<HTMLAnchorElement>,\n) {\n  const {intent, params, target, searchParams, ...restProps} = props\n  const {onClick, href} = useIntentLink({\n    intent,\n    params,\n    target,\n    onClick: props.onClick,\n    searchParams,\n  })\n\n  return <a {...restProps} href={href} onClick={onClick} ref={ref} target={target} />\n})\n","import {type ForwardedRef, forwardRef, type HTMLProps} from 'react'\n\nimport {useLink} from './useLink'\n\n/**\n * Props for the {@link Link} component.\n *\n * @public\n */\nexport interface LinkProps {\n  /**\n   * Whether to replace the current URL in the browser history instead of adding a new entry.\n   */\n  replace?: boolean\n}\n\n/**\n * A component that creates an HTML anchor element.\n *\n * @public\n *\n * @param props - Props to pass to the `Link` component.\n *  See {@link LinkProps}\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   return (\n *    <Link href=\"https://www.sanity.io\" target=\"_blank\" replace>\n *      Go to Sanity\n *    </Link>\n *   )\n * }\n * ```\n */\nexport const Link = forwardRef(function Link(\n  props: LinkProps & HTMLProps<HTMLAnchorElement>,\n  ref: ForwardedRef<HTMLAnchorElement>,\n) {\n  const {onClick: onClickProp, href, target, replace, ...restProps} = props\n  const {onClick} = useLink({onClick: onClickProp, href, target, replace})\n\n  return <a {...restProps} onClick={onClick} href={href} target={target} ref={ref} />\n})\n","import {type Route, type RouteSegment} from './types'\n\nconst VALID_PARAM_SEGMENT = /^[a-zA-Z0-9_-]+$/\n\nfunction createSegment(segment: string): RouteSegment | null {\n  if (!segment) {\n    return null\n  }\n\n  if (segment.startsWith(':')) {\n    const paramName = segment.slice(1)\n\n    if (!VALID_PARAM_SEGMENT.test(paramName)) {\n      const addendum = segment.includes('*')\n        ? ' Splats are not supported. Consider using child routes instead'\n        : ''\n      // eslint-disable-next-line no-console\n      console.error(\n        new Error(`Warning: Param segments \"${segment}\" includes invalid characters.${addendum}`),\n      )\n    }\n\n    return {type: 'param', name: paramName}\n  }\n\n  return {type: 'dir', name: segment}\n}\n\n/** @internal */\nexport function _parseRoute(route: string): Route {\n  const [pathname] = route.split('?')\n\n  const segments = pathname.split('/').map(createSegment).filter(Boolean) as RouteSegment[]\n\n  return {\n    raw: route,\n    segments: segments,\n  }\n}\n","export function arrayify<T>(val: Array<T> | T): Array<T> {\n  if (Array.isArray(val)) {\n    return val\n  }\n\n  return val ? [val] : []\n}\n","import {difference, intersection, isPlainObject, pick} from 'lodash'\n\nimport {\n  type InternalSearchParam,\n  type MatchError,\n  type MatchOk,\n  type MatchResult,\n  type RouterNode,\n  type RouterState,\n} from './types'\nimport {arrayify} from './utils/arrayify'\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return isPlainObject(value)\n}\n\nfunction createMatchError(\n  node: RouterNode,\n  missingKeys: string[],\n  unmappableStateKeys: string[],\n): MatchError {\n  return {type: 'error', node, missingKeys, unmappableStateKeys}\n}\n\nfunction createMatchOk(\n  node: RouterNode,\n  matchedState: Record<string, string>,\n  searchParams: InternalSearchParam[],\n  child?: MatchOk | undefined,\n): MatchOk {\n  return {type: 'ok', node, matchedState, searchParams, child}\n}\n\n/** @internal */\nexport function _findMatchingRoutes(node: RouterNode, _state?: RouterState): MatchResult {\n  if (!_state) {\n    return createMatchOk(node, {}, [])\n  }\n\n  const scopedState = node.scope ? (_state[node.scope] as RouterState) : _state\n\n  const {_searchParams: searchParams = [], ...state} = scopedState || {}\n\n  const requiredParams = node.route.segments\n    .filter((seg) => seg.type === 'param')\n    .map((seg) => seg.name)\n\n  const stateKeys = isRecord(state) ? Object.keys(state) : []\n\n  // These are params found in both the state and the route definition\n  const consumedParams = intersection(stateKeys, requiredParams)\n\n  // these are params found in the route definition but not in the state, can't map them to a route\n  const missingParams = difference(requiredParams, consumedParams)\n\n  // these are params found in the state but not in the route definition\n  const remainingParams = difference(stateKeys, consumedParams)\n\n  if (missingParams.length > 0) {\n    return createMatchError(node, missingParams, [])\n  }\n\n  const scopedParams = searchParams.map(([key, value]): InternalSearchParam => [[key], value])\n\n  const consumedState = pick(state, consumedParams) as Record<string, string>\n\n  if (remainingParams.length === 0) {\n    return createMatchOk(node, consumedState, scopedParams)\n  }\n\n  const children = arrayify(\n    (typeof node.children === 'function'\n      ? node.children(isRecord(state) ? state : {})\n      : node.children) || [],\n  )\n\n  if (remainingParams.length > 0 && children.length === 0) {\n    // our state includes extra keys that's not consumed by child routes\n    return createMatchError(node, [], remainingParams)\n  }\n\n  const remainingState = pick(state, remainingParams)\n\n  const childResult = children.map((childNode) => _findMatchingRoutes(childNode, remainingState))\n\n  // Look for a matching route\n  const found = childResult.find((res): res is MatchOk => res.type === 'ok')\n  return found\n    ? createMatchOk(node, consumedState, scopedParams, found)\n    : createMatchError(node, [], remainingParams)\n}\n","/**\n * Like encodeURIComponent, but supports a custom set of unescaped characters.\n * @param uriComponent - A value representing an unencoded URI component.\n * @param unescaped - a string containing characters to not escape\n */\nexport function encodeURIComponentExcept(\n  uriComponent: string | number | boolean,\n  unescaped: string,\n): string {\n  const chars = [...String(uriComponent)]\n  let res = ''\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    if (unescaped.includes(char)) {\n      res += char\n    } else {\n      res += encodeURIComponent(char)\n    }\n  }\n  return res\n}\n","import Debug from 'debug'\n\nexport const debug = Debug('state-router')\n","import {_findMatchingRoutes} from './_findMatchingRoutes'\nimport {encodeURIComponentExcept} from './encodeURIComponentExcept'\nimport {type InternalSearchParam, type MatchOk, type RouterNode, type RouterState} from './types'\nimport {debug} from './utils/debug'\n\n/** @internal */\nexport function _resolvePathFromState(node: RouterNode, _state: RouterState): string {\n  debug('Resolving path from state %o', _state)\n\n  const match = _findMatchingRoutes(node, _state)\n  if (match.type === 'error') {\n    const unmappable = match.unmappableStateKeys\n    if (unmappable.length > 0) {\n      throw new Error(\n        `Unable to find matching route for state. Could not map the following state key${\n          unmappable.length == 1 ? '' : 's'\n        } to a valid url: ${unmappable.map(quote).join(', ')}`,\n      )\n    }\n    const missingKeys = match.missingKeys\n    throw new Error(\n      `Unable to find matching route for state. State object is missing the following key${\n        missingKeys.length == 1 ? '' : 's'\n      } defined in route: ${missingKeys.map(quote).join(', ')}`,\n    )\n  }\n\n  const {path, searchParams} = pathFromMatchResult(match)\n\n  const search = searchParams.length > 0 ? encodeParams(searchParams) : ''\n\n  return `/${path.join('/')}${search ? `?${search}` : ''}`\n}\n\nfunction bracketify(value: string): string {\n  return `[${value}]`\n}\n\nfunction encodeParams(params: InternalSearchParam[]): string {\n  return params\n    .flatMap(([key, value]) => {\n      if (value === undefined) {\n        return []\n      }\n      return [encodeSearchParamKey(serializeScopedPath(key)), encodeSearchParamValue(value)].join(\n        '=',\n      )\n    })\n    .join('&')\n}\n\nfunction serializeScopedPath(scopedPath: string[]): string {\n  const [head, ...tail] = scopedPath\n\n  return tail.length > 0 ? [head, ...tail.map(bracketify)].join('') : head\n}\n\nfunction encodeSearchParamValue(value: string): string {\n  return encodeURIComponentExcept(value, '/')\n}\n\nfunction encodeSearchParamKey(value: string): string {\n  return encodeURIComponentExcept(value, '[]')\n}\n\nfunction pathFromMatchResult(match: MatchOk): {\n  path: string[]\n  searchParams: InternalSearchParam[]\n} {\n  const matchedState = match.matchedState\n\n  const base = match.node.route.segments.map((segment) => {\n    if (segment.type === 'dir') {\n      return segment.name\n    }\n\n    const transform = match.node.transform && match.node.transform[segment.name]\n\n    return transform\n      ? transform.toPath(matchedState[segment.name] as any)\n      : matchedState[segment.name]\n  })\n\n  const childMatch = match.child ? pathFromMatchResult(match.child) : undefined\n\n  const searchParams = childMatch?.searchParams\n    ? [...match.searchParams, ...childMatch.searchParams]\n    : match.searchParams\n\n  return {\n    searchParams: addNodeScope(match.node, searchParams),\n    path: [...(base || []), ...(childMatch?.path || [])],\n  }\n}\n\nfunction addNodeScope(\n  node: RouterNode,\n  searchParams: InternalSearchParam[],\n): InternalSearchParam[] {\n  const scope = node.scope\n  return scope && !node.__unsafe_disableScopedSearchParams\n    ? searchParams.map(([namespaces, value]) => [[scope, ...namespaces], value])\n    : searchParams\n}\n\nfunction quote(value: string): string {\n  return `\"${value}\"`\n}\n","import {type InternalSearchParam} from '../types'\n\nexport function parseScopedParams(params: [key: string, value: string][]): InternalSearchParam[] {\n  return params.map(([key, value]) => [parse(key), value])\n}\n\nconst OPEN = 1\nconst CLOSED = 0\n\nfunction parse(str: string) {\n  const result = []\n  let i = 0\n  let state = CLOSED\n  while (i < str.length) {\n    const nextBracketIdx = str.indexOf('[', i)\n    if (nextBracketIdx === -1) {\n      result.push(str.slice(i, str.length))\n      break\n    }\n    if (state === OPEN) {\n      throw new Error('Nested brackets not supported')\n    }\n    state = OPEN\n    if (nextBracketIdx > i) {\n      result.push(str.slice(i, nextBracketIdx))\n      i = nextBracketIdx\n    }\n\n    const nextClosing = str.indexOf(']', nextBracketIdx)\n    if (nextClosing === -1) {\n      if (state === OPEN) {\n        throw new Error('Unclosed bracket')\n      }\n      break\n    }\n    state = CLOSED\n    result.push(str.slice(i + 1, nextClosing))\n    i = nextClosing + 1\n  }\n  return result\n}\n","import {\n  type InternalSearchParam,\n  type RouterNode,\n  type RouterState,\n  type SearchParam,\n} from './types'\nimport {arrayify} from './utils/arrayify'\nimport {debug} from './utils/debug'\nimport {parseScopedParams} from './utils/parseScopedParams'\n\nfunction matchPath(\n  node: RouterNode,\n  path: string,\n  searchParams: InternalSearchParam[],\n): RouterState | null {\n  const parts = path.split('/').filter(Boolean)\n  const segmentsLength = node.route.segments.length\n\n  if (parts.length < segmentsLength) {\n    return null\n  }\n\n  const state: RouterState = {}\n  const isMatching = node.route.segments.every((segment, i) => {\n    if (segment.type === 'dir') {\n      return segment.name === parts[i]\n    }\n\n    const transform = node.transform && node.transform[segment.name]\n\n    state[segment.name] = transform ? transform.toState(parts[i]) : parts[i]\n\n    return true\n  })\n\n  if (!isMatching) {\n    return null\n  }\n\n  const rest = parts.slice(segmentsLength)\n\n  let childState: RouterState | null = null\n\n  const children =\n    typeof node.children === 'function' ? arrayify(node.children(state)) : node.children\n\n  const unscopedParams = removeScope(node.scope, searchParams)\n\n  children.some((childNode) => {\n    if (childNode) {\n      const childParams = childNode.scope\n        ? unscopedParams.filter(([namespaces]) => childNode.scope === namespaces[0])\n        : unscopedParams\n\n      childState = matchPath(childNode, rest.join('/'), childParams)\n      return childState\n    }\n    return undefined\n  })\n\n  if (rest.length > 0 && !childState) {\n    return null\n  }\n\n  const selfParams = unscopedParams.flatMap(([namespace, value]): SearchParam[] => {\n    return namespace.length === 1 ? [[namespace[0], value]] : []\n  })\n\n  const mergedState: RouterState = {\n    ...state,\n    ...(childState === null ? {} : childState),\n    ...(selfParams.length > 0 ? {_searchParams: selfParams} : {}),\n  }\n\n  return node.scope ? {[node.scope]: mergedState} : mergedState\n}\n\n/**\n * @internal\n */\nexport function _resolveStateFromPath(node: RouterNode, path: string): Record<string, any> | null {\n  debug('resolving state from path %s', path)\n\n  const [pathname, search] = path.split('?')\n  const urlSearchParams = Array.from(new URLSearchParams(search).entries())\n\n  const pathMatch = matchPath(node, pathname, parseScopedParams(urlSearchParams))\n\n  debug('resolved: %o', pathMatch || null)\n\n  return pathMatch || null\n}\n\nfunction removeScope(\n  scope: string | undefined,\n  searchParams: InternalSearchParam[],\n): InternalSearchParam[] {\n  return scope\n    ? searchParams.map(([namespaces, value]) => [\n        namespaces[0] === scope ? namespaces.slice(1) : namespaces,\n        value,\n      ])\n    : searchParams\n}\n","/**\n * `atob()` and `btoa()` do not support Unicode characters outside of the Latin1 range,\n * but we obviously want to support the full range of Unicode characters in our router.\n *\n * Additionally, we would prefer not to use characters like `+` and `=` in URLs, as they\n * have specific meanings there and may be misinterpreted. Thus, this uses base64url instead\n * of the more common base64.\n */\n\n/**\n * Encodes a string as base64url\n *\n * @param str - String to encode\n * @returns Encoded string\n * @internal\n */\nexport function encodeBase64Url(str: string): string {\n  return encodeBase64(str).replace(/\\//g, '_').replace(/\\+/g, '-').replace(/[=]+$/, '')\n}\n\n/**\n * Decodes a base64url-encoded string\n *\n * @param str - String to decode\n * @returns Decoded string\n * @internal\n */\nexport function decodeBase64Url(str: string): string {\n  return decodeBase64(str.replace(/-/g, '+').replace(/_/g, '/'))\n}\n\nfunction percentToByte(p: string) {\n  return String.fromCharCode(parseInt(p.slice(1), 16))\n}\n\nfunction encodeBase64(str: string): string {\n  return btoa(encodeURIComponent(str).replace(/%[0-9A-F]{2}/g, percentToByte))\n}\n\nfunction byteToPercent(b: string) {\n  return `%${`00${b.charCodeAt(0).toString(16)}`.slice(-2)}`\n}\n\nfunction decodeBase64(str: string): string {\n  return decodeURIComponent(Array.from(atob(str), byteToPercent).join(''))\n}\n","import {decodeBase64Url, encodeBase64Url} from './base64url'\n\n/**\n * Decode a path segment containing JSON parameters\n *\n * @param pathSegment - The path segment to decode\n * @returns The decoded parameters\n * @internal\n * @hidden\n */\nexport function decodeJsonParams(pathSegment = ''): Record<string, unknown> {\n  const segment = decodeURIComponent(pathSegment)\n\n  if (!segment) {\n    return {}\n  }\n\n  // Because of high-unicode characters (eg outside of the latin1 range), we prefer base64url\n  // since it also removes characters we'd rather not put in our URLs (eg '=' and '/')\n  try {\n    return JSON.parse(decodeBase64Url(segment))\n  } catch (err) {\n    // Fall-through: previously we used plain base64 encoding instead of base64url\n  }\n\n  try {\n    return JSON.parse(atob(segment))\n  } catch (err) {\n    // Fall-through: before _that_, we used plain URI encoding\n  }\n\n  try {\n    return JSON.parse(segment)\n  } catch (err) {\n    console.warn('Failed to parse JSON parameters')\n  }\n\n  return {}\n}\n\n/**\n * Encodes a set of parameters as a path segment, using base64url\n *\n * @param params - Paramters to encode\n * @returns The encoded parameters as a path segment\n * @internal\n * @hidden\n */\nexport function encodeJsonParams(params?: Record<string, unknown>): string {\n  return params ? encodeBase64Url(JSON.stringify(params)) : ''\n}\n","export function decodeParams(pathSegment: string): Record<string, string> {\n  return pathSegment.split(';').reduce<Record<string, string>>((params, pair) => {\n    const [key, value] = pair.split('=')\n\n    params[decodeURIComponent(key)] = decodeURIComponent(value)\n\n    return params\n  }, {})\n}\n\nexport function encodeParams(params: Record<string, string | undefined | null>): string {\n  return Object.entries(params)\n    .filter(([, value]) => value !== undefined && value !== null)\n    .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value as string)}`)\n    .join(';')\n}\n","import {_parseRoute} from './_parseRoute'\nimport {_resolvePathFromState} from './_resolvePathFromState'\nimport {_resolveStateFromPath} from './_resolveStateFromPath'\nimport {type RouteChildren, type Router, type RouteTransform} from './types'\nimport {decodeJsonParams, encodeJsonParams} from './utils/jsonParamsEncoding'\nimport {decodeParams, encodeParams} from './utils/paramsEncoding'\n\n/**\n * @public\n */\nexport interface RouteNodeOptions {\n  /**\n   * The path of the route node.\n   */\n  path?: string\n  /**\n   * The children of the route node. See {@link RouteChildren}\n   */\n  children?: RouteChildren\n  /**\n   * The transforms to apply to the route node. See {@link RouteTransform}\n   */\n  transform?: {\n    [key: string]: RouteTransform<any>\n  }\n  /**\n   * The scope of the route node.\n   */\n  scope?: string\n\n  /**\n   * Optionally disable scoping of search params\n   * Scoped search params will be represented as scope[param]=value in the url\n   * Disabling this will still scope search params based on any parent scope unless the parent scope also has disabled search params scoping\n   * Caution: enabling this can cause conflicts with multiple plugins defining search params with the same name\n   */\n  __unsafe_disableScopedSearchParams?: boolean\n}\n\n/**\n * Interface for the {@link route} object.\n *\n * @public\n */\nexport interface RouteObject {\n  /**\n   * Creates a new router.\n   * Returns {@link Router}\n   * See {@link RouteNodeOptions} and {@link RouteChildren}\n   */\n  create: (\n    routeOrOpts: RouteNodeOptions | string,\n    childrenOrOpts?: RouteNodeOptions | RouteChildren | null,\n    children?: Router | RouteChildren,\n  ) => Router\n\n  /**\n   * Creates a new router for handling intents.\n   * Returns {@link Router}\n   */\n  intents: (base: string) => Router\n\n  /**\n   * Creates a new router scope.\n   * Returns {@link Router}\n   */\n  scope(\n    scopeName: string,\n    routeOrOpts: RouteNodeOptions | string,\n    childrenOrOpts?: RouteNodeOptions | RouteChildren | null,\n    children?: Router | RouteChildren,\n  ): Router\n}\n\n/**\n * An object containing functions for creating routers and router scopes.\n * See {@link RouteObject}\n *\n * @public\n *\n * @example\n * ```ts\n * const router = route.create({\n *   path: \"/foo\",\n *   children: [\n *     route.create({\n *       path: \"/bar\",\n *       children: [\n *         route.create({\n *           path: \"/:baz\",\n *           transform: {\n *             baz: {\n *               toState: (id) => ({ id }),\n *               toPath: (state) => state.id,\n *             },\n *           },\n *         }),\n *       ],\n *     }),\n *   ],\n * });\n * ```\n */\nexport const route: RouteObject = {\n  create: (routeOrOpts, childrenOrOpts, children) =>\n    _createNode(normalizeArgs(routeOrOpts, childrenOrOpts, children)),\n  intents: (base: string) => {\n    const basePath = normalize(base).join('/')\n\n    return route.create(`${basePath}/:intent`, [\n      route.create(\n        ':params',\n        {\n          transform: {\n            params: {\n              toState: decodeParams,\n              toPath: encodeParams,\n            },\n          },\n        },\n        [\n          route.create(':payload', {\n            transform: {\n              payload: {\n                toState: decodeJsonParams,\n                toPath: encodeJsonParams,\n              },\n            },\n          }),\n        ],\n      ),\n    ])\n  },\n  scope(\n    scopeName: string,\n    routeOrOpts: RouteNodeOptions | string,\n    childrenOrOpts?: RouteNodeOptions | RouteChildren | null,\n    children?: Router | RouteChildren,\n  ) {\n    const options = normalizeArgs(routeOrOpts, childrenOrOpts, children)\n\n    return _createNode({\n      ...options,\n      scope: scopeName,\n    })\n  },\n}\n\nfunction normalizeChildren(children: any): RouteChildren {\n  if (Array.isArray(children) || typeof children === 'function') {\n    return children\n  }\n  return children ? [children] : []\n}\n\nfunction isRoute(val?: RouteNodeOptions | Router | RouteChildren) {\n  return val && '_isRoute' in val\n}\n\nfunction normalizeArgs(...args: any[]): RouteNodeOptions\nfunction normalizeArgs(\n  path: string | RouteNodeOptions,\n  childrenOrOpts?: RouteNodeOptions | Router | RouteChildren,\n  children?: Router | RouteChildren,\n): RouteNodeOptions {\n  if (typeof path === 'object') {\n    return path\n  }\n\n  if (\n    Array.isArray(childrenOrOpts) ||\n    typeof childrenOrOpts === 'function' ||\n    isRoute(childrenOrOpts)\n  ) {\n    return {path, children: normalizeChildren(childrenOrOpts)}\n  }\n\n  if (children) {\n    return {path, ...childrenOrOpts, children: normalizeChildren(children)}\n  }\n\n  return {path, ...childrenOrOpts}\n}\n\nfunction normalize(...paths: string[]) {\n  return paths.reduce<string[]>((acc, path) => acc.concat(path.split('/')), []).filter(Boolean)\n}\n\nconst EMPTY_STATE = {}\n\nfunction isRoot(pathname: string): boolean {\n  // it is the root if every segment is an empty string\n  return pathname.split('/').every((segment) => !segment)\n}\n\n/**\n * @internal\n * @param options - Route node options\n */\nexport function _createNode(options: RouteNodeOptions): Router {\n  // eslint-disable-next-line camelcase\n  const {path, scope, transform, children, __unsafe_disableScopedSearchParams} = options\n\n  if (!path) {\n    throw new TypeError('Missing path')\n  }\n\n  const parsedRoute = _parseRoute(path)\n\n  return {\n    _isRoute: true, // todo: make a Router class instead\n    scope,\n    // eslint-disable-next-line camelcase\n    __unsafe_disableScopedSearchParams,\n    route: parsedRoute,\n    children: children || [],\n    transform,\n    encode(state) {\n      return _resolvePathFromState(this, state)\n    },\n    decode(_path) {\n      return _resolveStateFromPath(this, _path)\n    },\n    isRoot: isRoot,\n    isNotFound(pathname: string): boolean {\n      return this.decode(pathname) === null\n    },\n    getBasePath(): string {\n      return this.encode(EMPTY_STATE)\n    },\n    getRedirectBase(pathname: string): string | null {\n      if (isRoot(pathname)) {\n        const basePath = this.getBasePath()\n        // Check if basepath is something different than given\n        if (pathname !== basePath) {\n          return basePath\n        }\n      }\n      return null\n    },\n  }\n}\n","/**\n * @internal\n */\nexport const STICKY_PARAMS: string[] = ['perspective', 'excludedPerspectives']\n","/**\n * @public\n */\nexport interface RouteSegment {\n  /**\n   * The name of the segment.\n   */\n  name: string\n  /**\n   * The type of the segment.\n   * Can be either \"dir\" or \"param\".\n   */\n  type: 'dir' | 'param'\n}\n\n/**\n * @public\n */\nexport interface RouteTransform<T> {\n  /**\n   * Converts a path string to a state object.\n   */\n  toState: (value: string) => T\n\n  /**\n   * Converts a state object to a path string.\n   */\n  toPath: (value: T) => string\n}\n\n/**\n * @public\n */\nexport interface Route {\n  /**\n   * The raw string representation of the route.\n   */\n  raw: string\n  /**\n   * An array of route segments that make up the route.\n   * See {@link RouteSegment}\n   */\n  segments: RouteSegment[]\n  /**\n   * An optional object containing route transforms.\n   * See {@link RouteTransform} and {@link RouterState}\n   */\n  transform?: {\n    [key: string]: RouteTransform<RouterState>\n  }\n}\n\n/**\n * @public\n */\nexport type RouteChildren =\n  | RouterNode[]\n  | ((state: RouterState) => Router | RouterNode | RouterNode[] | undefined | false)\n\n/**\n * @public\n */\nexport interface RouterNode {\n  /**\n   * The route information for this node. See {@link Route}\n   */\n  route: Route\n  /**\n   * An optional scope for this node.\n   */\n  scope?: string\n\n  /**\n   * Optionally disable scoping of search params\n   * Scoped search params will be represented as scope[param]=value in the url\n   * Disabling this will still scope search params based on any parent scope unless the parent scope also has disabled search params scoping\n   * Caution: enabling this can cause conflicts with multiple plugins defining search params with the same name\n   */\n  __unsafe_disableScopedSearchParams?: boolean\n\n  /**\n   * An optional object containing transforms to apply to this node.\n   * See {@link RouteTransform} and {@link RouterState}\n   */\n  transform?: {\n    [key: string]: RouteTransform<RouterState>\n  }\n  /**\n   * The child nodes of this node. See {@link RouteChildren}\n   */\n  children: RouteChildren\n}\n\n/**\n * @public\n */\nexport interface Router extends RouterNode {\n  /**\n   * Indicates whether this router is a route.\n   * @internal\n   */\n  _isRoute: boolean\n  /**\n   * Encodes the specified router state into a path string.\n   * See {@link RouterState}\n   *\n   */\n  encode: (state: RouterState) => string\n\n  /**\n   * Decodes the specified path string into a router state.\n   * See {@link RouterState}\n   */\n  decode: (path: string) => RouterState | null\n\n  /**\n   * Determines whether the specified path is not found.\n   */\n  isNotFound: (path: string) => boolean\n\n  /**\n   * Gets the base path of this router.\n   */\n  getBasePath: () => string\n\n  /**\n   * Gets the redirect base of this router.\n   */\n  getRedirectBase: (pathname: string) => string | null\n\n  /**\n   * Determines whether the specified path is the root path.\n   */\n  isRoot: (path: string) => boolean\n}\n\n/** @internal */\nexport type InternalSearchParam = [scopedPath: string[], value: string]\n\n/** @internal */\nexport interface MatchOk {\n  type: 'ok'\n  node: RouterNode\n  matchedState: Record<string, string>\n  searchParams: InternalSearchParam[]\n  child: MatchOk | undefined\n}\n\n/** @internal */\nexport interface MatchError {\n  type: 'error'\n  node: RouterNode\n  /**\n   * Parameters found in the route string but not provided as a key in the state object\n   */\n  missingKeys: string[]\n  /**\n   * These are keys found in the state object but not in the route definition (and can't be mapped to a child route)\n   */\n  unmappableStateKeys: string[]\n}\n/** @internal */\nexport type MatchResult = MatchError | MatchOk\n\n/**\n * @public\n */\nexport interface NavigateBaseOptions {\n  replace?: boolean\n}\n\n/**\n * @public\n */\nexport interface NavigateOptions extends NavigateBaseOptions {\n  stickyParams?: Record<string, string | undefined | null>\n}\n\n/**\n * @public\n */\nexport interface NavigateOptionsWithState extends NavigateOptions {\n  state?: RouterState | null\n}\n\n/**\n * @public\n */\nexport interface RouterContextValue {\n  /**\n   * Resolves the path from the given router state. See {@link RouterState}\n   *\n   * When state is null, it will resolve the path from the current state\n   * and navigate to the root path.\n   */\n  resolvePathFromState: (state: RouterState | null) => string\n\n  /**\n   * Resolves the intent link for the given intent name and parameters.\n   * See {@link IntentParameters}\n   */\n  resolveIntentLink: (\n    intentName: string,\n    params?: IntentParameters,\n    searchParams?: SearchParam[],\n  ) => string\n\n  /**\n   * Navigates to the given URL.\n   * The function requires an object that has a path and an optional replace property.\n   */\n  navigateUrl: (opts: {path: string; replace?: boolean}) => void\n\n  /**\n   * @deprecated Use `navigate({stickyParams: params, ...options})` instead\n   */\n  navigateStickyParams: (\n    params: NavigateOptions['stickyParams'],\n    options?: NavigateBaseOptions,\n  ) => void\n\n  /**\n   * Updates the router state and navigates to a new path.\n   * Allows specifying new state values and optionally merging sticky parameters.\n   *\n   * See {@link RouterState} and {@link NavigateOptions}\n   *\n   * @public\n   *\n   * @example Navigate with sticky params only, staying on the current path\n   * ```tsx\n   * router.navigate({stickyParams: {baz: 'qux'}})\n   * ```\n   * @remarks `null` sticky parameter value will remove the sticky parameter from the url\n   *\n   * @example Navigate with state and sticky params\n   * ```tsx\n   * router.navigate({stickyParams: {baz: 'qux'}, state: {foo: 'bar'}})\n   * ```\n   *\n   * @example Navigate to root path\n   * ```tsx\n   * router.navigate({stickyParams: {baz: 'qux'}, state: null})\n   * ```\n   */\n  navigate: {\n    // legacy, state-first version - for when you want to navigate to a new state\n    (nextState: RouterState, options?: NavigateOptions): void\n    // Options version - for staying where you are (omit state) or going to root (state: null)\n    (options: NavigateOptions & {state?: RouterState | null}): void\n  }\n\n  /**\n   * Navigates to the given intent.\n   * See {@link RouterState} and {@link NavigateBaseOptions}\n   */\n  navigateIntent: (\n    intentName: string,\n    params?: IntentParameters,\n    options?: NavigateBaseOptions,\n  ) => void\n\n  /**\n   * The current router state. See {@link RouterState}\n   */\n  state: RouterState\n\n  /**\n   * The current router state. See {@link RouterState}\n   */\n  stickyParams: Record<string, string | undefined | null>\n}\n\n/**\n * Base intent parameters\n *\n * @public\n * @todo dedupe with core/structure\n */\nexport interface BaseIntentParams {\n  /**\n   * Document schema type name to create/edit.\n   * Required for `create` intents, optional for `edit` (but encouraged, safer and faster)\n   */\n  type?: string\n\n  /**\n   * ID of the document to create/edit.\n   * Required for `edit` intents, optional for `create`.\n   */\n  id?: string\n\n  /* Name (ID) of initial value template to use for `create` intent. Optional.  */\n  template?: string\n\n  /**\n   * Experimental field path\n   *\n   * @beta\n   * @experimental\n   * @hidden\n   */\n  path?: string\n\n  /**\n   * Optional \"mode\" to use for edit intent.\n   * Known modes are `structure` and `presentation`.\n   */\n  mode?: string\n\n  /**\n   * Arbitrary/custom parameters are generally discouraged - try to keep them to a minimum,\n   * or use `payload` (arbitrary JSON-serializable object) instead.\n   */\n  [key: string]: string | undefined\n}\n\n/**\n * Intent parameters (json)\n *\n * @public\n */\nexport type IntentJsonParams = {[key: string]: any}\n\n/**\n * @public\n * @todo dedupe with intent types in core\n */\nexport type IntentParameters = BaseIntentParams | [BaseIntentParams, IntentJsonParams]\n\n/**\n * @public\n */\nexport type SearchParam = [key: string, value: string]\n\n/**\n * @public\n */\nexport type RouterState = Record<string, unknown> & {_searchParams?: SearchParam[]}\n\nexport const isNavigateOptions = (\n  maybeNavigateOptions: unknown,\n): maybeNavigateOptions is NavigateOptions & {state?: RouterState | null} => {\n  if (\n    typeof maybeNavigateOptions !== 'object' ||\n    maybeNavigateOptions === null ||\n    Array.isArray(maybeNavigateOptions)\n  ) {\n    return false\n  }\n\n  const hasNavigationProps =\n    'replace' in maybeNavigateOptions ||\n    'stickyParams' in maybeNavigateOptions ||\n    'state' in maybeNavigateOptions\n\n  if (!hasNavigationProps) {\n    return false\n  }\n\n  // if state exists then it should be of RouterState type\n  if ('state' in maybeNavigateOptions) {\n    const {state} = maybeNavigateOptions as {state: unknown}\n    // allow null or undefined or RouterState (including empty object)\n    return state === null || state === undefined || typeof state === 'object'\n  }\n\n  return true\n}\n\n/**\n * Type representing either a new router state or navigation options with an optional state.\n * @internal\n */\nexport type NextStateOrOptions = RouterState | (NavigateOptions & {state?: RouterState | null})\n","import {fromPairs, partition, toPairs} from 'lodash'\nimport {type ReactNode, useCallback, useMemo} from 'react'\nimport {RouterContext} from 'sanity/_singletons'\n\nimport {STICKY_PARAMS} from './stickyParams'\nimport {\n  type IntentParameters,\n  isNavigateOptions,\n  type NavigateBaseOptions,\n  type NavigateOptions,\n  type NextStateOrOptions,\n  type Router,\n  type RouterContextValue,\n  type RouterState,\n  type SearchParam,\n} from './types'\n\n/**\n * The props for the {@link RouterProvider} component.\n *\n * @public\n */\nexport interface RouterProviderProps {\n  /**\n   * A function that is called when the user navigates to a new path.\n   * Takes an object containing the path to navigate to and an optional `replace` flag.\n   */\n  onNavigate: (opts: {path: string; replace?: boolean}) => void\n  /**\n   * The router object that is used to handle navigation. See {@link Router}\n   */\n  router: Router\n  /**\n   * The current state of the router. See {@link RouterState}\n   */\n  state: RouterState\n  /**\n   * The child elements to render.\n   */\n  children: ReactNode\n}\n\n/**\n * @example\n * ```tsx\n * import {\n *   NavigateOptions,\n *   route,\n *   RouterProvider,\n *   RouterState\n * } from 'sanity'\n * import {useCallback, useMemo} from 'react'\n *\n * function Root() {\n *   const [router] = useState(() => route.create('/'))\n *\n *   const [state, setState] = useState<RouterState>({})\n *\n *   const handleNavigate = useCallback((\n *     path: string,\n *     options?: NavigateOptions\n *   ) => {\n *     console.log('navigate', path, options)\n *\n *     setState(router.decode(path))\n *   }, [router])\n *\n *   return (\n *     <RouterProvider\n *       onNavigate={handleNavigate}\n *       router={router}\n *       state={state}\n *     >\n *       <div>This is a routed application</div>\n *     </RouterProvider>\n *   )\n * }\n * ```\n *\n * @param props - The component props.\n *  {@link RouterProviderProps}\n *\n * @public\n */\nexport function RouterProvider(props: RouterProviderProps): React.JSX.Element {\n  const {onNavigate, router: routerProp, state} = props\n\n  const resolveIntentLink = useCallback(\n    (intentName: string, parameters?: IntentParameters, _searchParams?: SearchParam[]): string => {\n      const [params, payload] = Array.isArray(parameters) ? parameters : [parameters]\n      return routerProp.encode({\n        intent: intentName,\n        params,\n        payload,\n        _searchParams: toPairs({\n          ...fromPairs((state._searchParams ?? []).filter(([key]) => STICKY_PARAMS.includes(key))),\n          ...fromPairs(_searchParams ?? []),\n        }),\n      })\n    },\n    [routerProp, state._searchParams],\n  )\n\n  const resolvePathFromState = useCallback(\n    (nextState: RouterState | null): string => {\n      const currentStateParams = state._searchParams || []\n      const nextStateParams = nextState?._searchParams || []\n      const nextParams = STICKY_PARAMS.reduce((acc, param) => {\n        return replaceStickyParam(\n          acc,\n          param,\n          findParam(nextStateParams, param) ?? findParam(currentStateParams, param),\n        )\n      }, nextStateParams || [])\n\n      return routerProp.encode({\n        ...nextState,\n        _searchParams: nextParams,\n      })\n    },\n    [routerProp, state],\n  )\n\n  const navigate: RouterContextValue['navigate'] = useCallback(\n    (nextStateOrOptions: NextStateOrOptions, maybeOptions?: NavigateOptions) => {\n      // Determine options and state based on input pattern\n      const isOptionsOnlyPattern = isNavigateOptions(nextStateOrOptions) && !maybeOptions\n      const options = isOptionsOnlyPattern ? nextStateOrOptions : maybeOptions || {}\n\n      const baseState = isNavigateOptions(nextStateOrOptions)\n        ? (getStateFromOptions(nextStateOrOptions, state) ?? state)\n        : nextStateOrOptions\n\n      const currentParams = state._searchParams || []\n      const nextStickyParams =\n        options.stickyParams ??\n        Object.fromEntries(currentParams.filter(([key]) => STICKY_PARAMS.includes(key)))\n\n      validateStickyParams(nextStickyParams)\n\n      const nextParams = baseState._searchParams || []\n      const mergedParams = mergeStickyParams(nextParams, nextStickyParams)\n\n      onNavigate({\n        path: resolvePathFromState({...baseState, _searchParams: mergedParams}),\n        replace: options.replace,\n      })\n    },\n    [onNavigate, resolvePathFromState, state],\n  )\n\n  const handleNavigateStickyParams = useCallback(\n    (params: NavigateOptions['stickyParams'], options: NavigateBaseOptions = {}) =>\n      navigate({stickyParams: params, ...options, state: undefined}),\n    [navigate],\n  )\n\n  const navigateIntent = useCallback(\n    (intentName: string, params?: IntentParameters, options: NavigateBaseOptions = {}) => {\n      onNavigate({path: resolveIntentLink(intentName, params), replace: options.replace})\n    },\n    [onNavigate, resolveIntentLink],\n  )\n\n  const [routerState, stickyParams] = useMemo(() => {\n    if (!state._searchParams) {\n      return [state, null]\n    }\n    const {_searchParams, ...rest} = state\n    const [sticky, restParams] = partition(_searchParams, ([key]) => STICKY_PARAMS.includes(key))\n    if (sticky.length === 0) {\n      return [state, null]\n    }\n    return [{...rest, _searchParams: restParams}, sticky]\n  }, [state])\n\n  const stickyParamsByName = useMemo(() => Object.fromEntries(stickyParams || []), [stickyParams])\n\n  const router: RouterContextValue = useMemo(\n    () => ({\n      navigate,\n      navigateIntent,\n      navigateStickyParams: handleNavigateStickyParams,\n      navigateUrl: onNavigate,\n      resolveIntentLink,\n      resolvePathFromState,\n      state: routerState,\n      stickyParams: stickyParamsByName,\n    }),\n    [\n      handleNavigateStickyParams,\n      navigate,\n      navigateIntent,\n      onNavigate,\n      resolveIntentLink,\n      resolvePathFromState,\n      routerState,\n      stickyParamsByName,\n    ],\n  )\n\n  return <RouterContext.Provider value={router}>{props.children}</RouterContext.Provider>\n}\n\nfunction replaceStickyParam(\n  current: SearchParam[],\n  param: string,\n  value: string | undefined,\n): SearchParam[] {\n  const filtered = current.filter(([key]) => key !== param)\n  return value === undefined || value == '' ? filtered : [...filtered, [param, value]]\n}\n\nfunction mergeStickyParams(\n  currentParams: SearchParam[],\n  newParams?: Record<string, string | undefined | null>,\n): SearchParam[] {\n  if (!newParams) return currentParams\n\n  // Remove old sticky params before merging new ones\n  const filteredParams = currentParams.filter(([key]) => !Object.hasOwn(newParams, key))\n\n  // Type guard function to filter out undefined values\n  const isValidSearchParam = (\n    entry: [string, string | undefined | null],\n  ): entry is [string, string] => entry[1] !== undefined\n\n  const convertNullSearchParam = (entry: [string, string | null]): [string, string] => [\n    entry[0],\n    entry[1] === null ? '' : entry[1],\n  ]\n\n  // Convert newParams into the correct SearchParam format\n  const newEntries = Object.entries(newParams)\n    .filter(isValidSearchParam)\n    .map(convertNullSearchParam)\n\n  return [...filteredParams, ...newEntries]\n}\n\nfunction findParam(searchParams: SearchParam[], key: string): string | undefined {\n  const entry = searchParams.find(([k]) => k === key)\n  return entry ? entry[1] : undefined\n}\n\nfunction getStateFromOptions(\n  nextStateOrOptions: NextStateOrOptions,\n  state: RouterState,\n): RouterState | null {\n  const isOptionsOnly = isNavigateOptions(nextStateOrOptions)\n\n  if (isOptionsOnly) {\n    if (nextStateOrOptions.state === null) {\n      return {}\n    }\n    return nextStateOrOptions.state ?? state\n  }\n  return null\n}\n\nfunction validateStickyParams(nextStickyParams: Record<string, string | undefined | null>) {\n  const hasInvalidParam = Object.keys(nextStickyParams).some(\n    (param) => !STICKY_PARAMS.includes(param),\n  )\n  if (hasInvalidParam) throw new Error('One or more parameters are not sticky')\n}\n","/* eslint-disable camelcase */\nimport {type ReactNode, useCallback, useEffect, useMemo, useRef} from 'react'\nimport {RouterContext} from 'sanity/_singletons'\n\nimport {\n  isNavigateOptions,\n  type NavigateOptions,\n  type NextStateOrOptions,\n  type RouterContextValue,\n  type RouterState,\n} from './types'\nimport {useRouter} from './useRouter'\n\nfunction addScope(\n  routerState: Record<string, any>,\n  scope: string,\n  scopedState: Record<string, any>,\n) {\n  return (\n    scopedState && {\n      ...routerState,\n      [scope]: scopedState,\n    }\n  )\n}\n\n/**\n * Props for the {@link RouteScope} component.\n *\n * @public\n */\nexport interface RouteScopeProps {\n  /**\n   * The scope for the nested routes.\n   */\n  scope: string\n\n  /**\n   * Optionally disable scoping of search params\n   * Scoped search params will be represented as scope[param]=value in the url\n   * Disabling this will still scope search params based on any parent scope unless the parent scope also has disabled search params scoping\n   * Caution: enabling this can cause conflicts with multiple plugins defining search params with the same name\n   */\n  __unsafe_disableScopedSearchParams?: boolean\n  /**\n   * The content to display inside the route scope.\n   */\n  children: ReactNode\n}\n\n/**\n * A component that wraps a scoped router context, so that calls to\n * `useRouter()`, `useRouterState()`, and usage of `<StateLink />`\n * will be prefixed with the scope segment.\n *\n * @public\n *\n * @param props - Props to pass `RouteScope` component.\n *  See {@link RouteScopeProps}\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *  return (\n *    <RouteScope scope=\"foo\">\n *      <StateLink state={{bar: 'baz'}}>Link</StateLink>\n *    </RouteScope>\n *  )\n * }\n * ```\n */\nexport const RouteScope = function RouteScope(props: RouteScopeProps): React.JSX.Element {\n  const {children, scope, __unsafe_disableScopedSearchParams} = props\n  const parentRouter = useRouter()\n  const {resolvePathFromState: parent_resolvePathFromState, navigate: parent_navigate} =\n    parentRouter\n\n  const parentStateRef = useRef(parentRouter.state)\n  useEffect(() => {\n    parentStateRef.current = parentRouter.state\n  }, [parentRouter.state])\n\n  const resolveNextParentState = useCallback(\n    (_nextState: RouterState | null) => {\n      if (_nextState === null) return null\n\n      const {_searchParams, ...nextState} = _nextState || {}\n      const nextParentState = addScope(parentStateRef.current, scope, nextState)\n      if (__unsafe_disableScopedSearchParams) {\n        // Move search params to parent scope\n        nextParentState._searchParams = _searchParams\n      } else {\n        nextParentState[scope]._searchParams = _searchParams\n      }\n      return nextParentState\n    },\n    [scope, __unsafe_disableScopedSearchParams],\n  )\n\n  const resolvePathFromState = useCallback(\n    (nextState: RouterState | null) =>\n      parent_resolvePathFromState(resolveNextParentState(nextState)),\n    [parent_resolvePathFromState, resolveNextParentState],\n  )\n\n  const navigate: RouterContextValue['navigate'] = useCallback(\n    (nextStateOrOptions: NextStateOrOptions, maybeOptions?: NavigateOptions) => {\n      // Check if it's the options-only pattern\n      if (isNavigateOptions(nextStateOrOptions) && !maybeOptions) {\n        const options = nextStateOrOptions\n        const {state} = options\n\n        //keep the current state but apply other options\n        if (state) {\n          const nextState = resolveNextParentState(state)\n          const resolvedState = nextState === null ? {} : nextState\n\n          return parent_navigate(resolvedState, options)\n        }\n\n        //keep the current state\n        return parent_navigate(options)\n      }\n\n      const nextState = isNavigateOptions(nextStateOrOptions)\n        ? resolveNextParentState(null)\n        : resolveNextParentState(nextStateOrOptions)\n\n      return parent_navigate(nextState === null ? {} : nextState, maybeOptions || {})\n    },\n    [parent_navigate, resolveNextParentState],\n  )\n\n  const childRouter: RouterContextValue = useMemo(() => {\n    const parentState = parentRouter.state\n    const childState =\n      typeof parentState[scope] === 'object' ? ({...parentState[scope]} as RouterState) : {}\n    if (__unsafe_disableScopedSearchParams) {\n      childState._searchParams = parentState._searchParams\n    }\n    return {\n      ...parentRouter,\n      navigate,\n      resolvePathFromState,\n      state: childState,\n    }\n  }, [scope, parentRouter, navigate, resolvePathFromState, __unsafe_disableScopedSearchParams])\n\n  return <RouterContext.Provider value={childRouter}>{children}</RouterContext.Provider>\n}\nRouteScope.displayName = 'RouteScope'\n","import {type MouseEventHandler, useMemo} from 'react'\n\nimport {useLink} from './useLink'\nimport {useRouter} from './useRouter'\n\nconst EMPTY_STATE = {}\n\n/**\n * @public\n */\nexport interface UseStateLinkOptions {\n  /**\n   * The click event handler for the link.\n   */\n  onClick?: MouseEventHandler<HTMLElement>\n  /**\n   * Whether to replace the current history entry instead of adding a new one.\n   */\n  replace?: boolean\n  /**\n   * The state object to update when the link is clicked.\n   */\n  state?: Record<string, unknown>\n  /**\n   * The target window or frame to open the linked document in.\n   */\n  target?: string\n  /**\n   * Whether to navigate to the index page of the linked document.\n   */\n  toIndex?: boolean\n}\n\n/**\n * @public\n *\n * @param options - Options to use for the link\n *  {@link UseStateLinkOptions}\n *\n * @returns - An object with `onClick` and `href` props to use for the link\n *\n * @example\n * ```tsx\n * const {onClick, href} = useStateLink({state: {foo: 'bar'}})\n * ```\n */\nexport function useStateLink(options: UseStateLinkOptions): {\n  onClick: MouseEventHandler<HTMLElement>\n  href: string\n} {\n  const {onClick: onClickProp, replace, state, target, toIndex = false} = options\n\n  if (state && toIndex) {\n    throw new Error('Passing both `state` and `toIndex={true}` as props to StateLink is invalid')\n  }\n\n  if (!state && !toIndex) {\n    // eslint-disable-next-line no-console\n    console.error(\n      new Error(\n        'No state passed to StateLink. If you want to link to an empty state, its better to use the the `toIndex` property',\n      ),\n    )\n  }\n\n  const {resolvePathFromState} = useRouter()\n\n  const href = useMemo(\n    () => resolvePathFromState(toIndex ? EMPTY_STATE : state || EMPTY_STATE),\n    [resolvePathFromState, state, toIndex],\n  )\n\n  const {onClick} = useLink({href, onClick: onClickProp, replace, target})\n\n  return {onClick, href}\n}\n","import {type ForwardedRef, forwardRef, type HTMLProps} from 'react'\n\nimport {useStateLink} from './useStateLink'\n\n/**\n * Props for the {@link StateLink} component.\n *\n * @public\n */\nexport interface StateLinkProps {\n  /**\n   * Whether to replace the current history entry instead of adding a new one.\n   */\n  replace?: boolean\n  /**\n   * The state to associate with the link.\n   */\n  state?: Record<string, unknown>\n  /**\n   * Whether to navigate to the index page of the app.\n   */\n  toIndex?: boolean\n}\n\n/**\n * A component that creates a link that updates the URL state.\n *\n * @remarks\n * This component uses the {@link useStateLink} hook\n * to create a link that updates the URL state.\n *\n * @param props - Props to pass to the `StateLink` component.\n *  See {@link StateLinkProps}.\n *\n * @public\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *  return <StateLink state={{foo: 'bar'}}>Link</StateLink>\n * }\n * ```\n */\nexport const StateLink = forwardRef(function StateLink(\n  props: StateLinkProps & Omit<HTMLProps<HTMLAnchorElement>, 'href'>,\n  ref: ForwardedRef<HTMLAnchorElement>,\n) {\n  const {onClick: onClickProp, replace, state, target, toIndex = false, ...restProps} = props\n  const {onClick, href} = useStateLink({\n    onClick: onClickProp,\n    replace,\n    state,\n    target,\n    toIndex,\n  })\n\n  return <a {...restProps} href={href} onClick={onClick} ref={ref} />\n})\n","import {identity} from 'lodash'\nimport {useMemo} from 'react'\n\nimport {type RouterState} from './types'\nimport {useRouter} from './useRouter'\n\n/**\n * @public\n *\n * @param selector - A selector function that receives the router state and returns a value. See {@link RouterState}\n *\n * @returns The value returned by the selector function or RouterState. See {@link RouterState}\n *\n * @example\n * ```tsx\n * const {activeTool} = useRouterState(state => state.tool)\n * ```\n */\nexport function useRouterState<R = RouterState>(selector: (routerState: RouterState) => R): R\n\n/**\n * @public\n *\n * @returns The router state. See {@link RouterState}\n *\n * @example\n * ```tsx\n * const routerState = useRouterState()\n * ```\n */\nexport function useRouterState(): RouterState\n\n/**\n * @public\n */\nexport function useRouterState(\n  selector: (routerState: RouterState) => unknown = identity,\n): unknown {\n  const {state} = useRouter()\n  return useMemo(() => selector(state), [selector, state])\n}\n","import {type ComponentType, type FunctionComponent} from 'react'\n\nimport {type RouterContextValue} from './types'\nimport {useRouter} from './useRouter'\n\n/**\n * A higher-order component that injects the `router` object from the `useRouter` hook\n * into the props of the wrapped component.\n *\n * @internal\n * @deprecated - Use the `useRouter` hook instead.\n *\n * @param Component - The component to wrap.\n *\n * @returns The wrapped component.\n *\n * @example\n * ```tsx\n * function MyComponent(props) {\n *  return <div>{props.router.state.myParam}</div>\n * }\n *\n * export default withRouter(MyComponent)\n * ```\n */\nexport function withRouter<Props extends {router: RouterContextValue}>(\n  Component: ComponentType<Props>,\n): FunctionComponent<Omit<Props, 'router'>> {\n  function WithRouter(props: Omit<Props, 'router'>) {\n    const router = useRouter()\n\n    return <Component {...(props as Props)} router={router} />\n  }\n\n  WithRouter.displayName = `withRouter(${Component.displayName || Component.name})`\n\n  return WithRouter\n}\n\n/**\n * @internal\n * @deprecated - Use the `useRouter` hook instead.\n */\nexport interface WithRouterProps {\n  /**\n   * The `router` object from the `useRouter` hook.\n   *  {@link RouterContextValue}\n   */\n  router: RouterContextValue\n  /**\n   * A function that renders the wrapped component with the `router` object as a parameter.\n   */\n  children: (router: RouterContextValue) => React.JSX.Element\n}\n\n/**\n * A higher-order component that injects the router object into its child component.\n *\n * @internal\n * @deprecated - Use the `useRouter` hook instead.\n *\n * @returns The rendered component.\n *\n * @example\n * ```tsx\n * function MyComponent(props: {router: Router}) {\n *   const {location} = props.router\n *   const {pathname} = location\n *   return <p>The current path is: {pathname}</p>\n * }\n *\n * function App() {\n *   return (\n *     <Router>\n *       <WithRouter>\n *         {router => <MyComponent router={router} />}\n *       </WithRouter>\n *     </Router>\n *   )\n * }\n * ```\n */\nexport const WithRouter = withRouter((props: WithRouterProps) => props.children(props.router))\n"],"names":["useRouter","router","useContext","RouterContext","Error","isLeftClickEvent","event","button","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","useLink","options","$","_c","onClick","onClickProp","href","target","replace","t0","undefined","navigateUrl","t1","isDefaultPrevented","preventDefault","path","t2","useIntentLink","intent","params","searchParams","resolveIntentLink","t3","IntentLink","forwardRef","props","ref","restProps","jsx","Link","VALID_PARAM_SEGMENT","createSegment","segment","startsWith","paramName","slice","test","addendum","includes","error","type","name","_parseRoute","route","pathname","split","segments","map","filter","Boolean","raw","arrayify","val","Array","isArray","isRecord","value","isPlainObject","createMatchError","node","missingKeys","unmappableStateKeys","createMatchOk","matchedState","child","_findMatchingRoutes","_state","scopedState","scope","_searchParams","state","requiredParams","seg","stateKeys","Object","keys","consumedParams","intersection","missingParams","difference","remainingParams","length","scopedParams","key","consumedState","pick","children","remainingState","found","childNode","find","res","encodeURIComponentExcept","uriComponent","unescaped","chars","String","i","char","encodeURIComponent","debug","Debug","_resolvePathFromState","match","unmappable","quote","join","pathFromMatchResult","search","encodeParams","bracketify","flatMap","encodeSearchParamKey","serializeScopedPath","encodeSearchParamValue","scopedPath","head","tail","base","transform","toPath","childMatch","addNodeScope","__unsafe_disableScopedSearchParams","namespaces","parseScopedParams","parse","OPEN","CLOSED","str","result","nextBracketIdx","indexOf","push","nextClosing","matchPath","parts","segmentsLength","every","toState","rest","childState","unscopedParams","removeScope","some","childParams","selfParams","namespace","mergedState","_resolveStateFromPath","urlSearchParams","from","URLSearchParams","entries","pathMatch","encodeBase64Url","encodeBase64","decodeBase64Url","decodeBase64","percentToByte","p","fromCharCode","parseInt","btoa","byteToPercent","b","charCodeAt","toString","decodeURIComponent","atob","decodeJsonParams","pathSegment","JSON","console","warn","encodeJsonParams","stringify","decodeParams","reduce","pair","create","routeOrOpts","childrenOrOpts","_createNode","normalizeArgs","intents","basePath","normalize","payload","scopeName","normalizeChildren","isRoute","paths","acc","concat","EMPTY_STATE","isRoot","TypeError","parsedRoute","_isRoute","encode","decode","_path","isNotFound","getBasePath","getRedirectBase","STICKY_PARAMS","isNavigateOptions","maybeNavigateOptions","RouterProvider","onNavigate","routerProp","useCallback","intentName","parameters","toPairs","fromPairs","resolvePathFromState","nextState","currentStateParams","nextStateParams","nextParams","param","replaceStickyParam","findParam","navigate","nextStateOrOptions","maybeOptions","baseState","getStateFromOptions","currentParams","nextStickyParams","stickyParams","fromEntries","validateStickyParams","mergedParams","mergeStickyParams","handleNavigateStickyParams","navigateIntent","routerState","useMemo","sticky","restParams","partition","stickyParamsByName","navigateStickyParams","current","filtered","newParams","filteredParams","hasOwn","isValidSearchParam","entry","convertNullSearchParam","newEntries","k","addScope","RouteScope","parentRouter","parent_resolvePathFromState","parent_navigate","parentStateRef","useRef","useEffect","_nextState","nextParentState","resolveNextParentState","nextState_0","t4","nextState_1","nextState_2","t5","parentState","t6","childRouter","t7","displayName","useStateLink","toIndex","StateLink","useRouterState","selector","identity","withRouter","Component","WithRouter"],"mappings":"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"}