import { structureLocaleNamespace, getExtendedProjection, structureUsEnglishLocaleBundle } from "./StructureToolProvider.mjs";
import { Tooltip, TooltipDelayGroupProvider, Button, Dialog, ErrorBoundary, MenuItem, MenuButton, Tab, Popover } from "./generate-help-url.esm.mjs";
import "../_singletons.mjs";
import { jsx, Fragment, jsxs } from "react/jsx-runtime";
import { c } from "react-compiler-runtime";
import { Box, rem, Flex, Inline, Text, useToast, Stack, Card, Layer, BoundaryElementProvider, MenuDivider, Menu, TextSkeleton, useElementRect, LayerProvider, Button as Button$1, MenuItem as MenuItem$1, Container as Container$1, DialogProvider, PortalProvider, _raf2, TextInput, Code, TabList, TabPanel, useClickOutsideEvent, Heading, Spinner, focusFirstDescendant, usePortal, Popover as Popover$1, useLayer, useGlobalKeyDown, Grid as Grid$2, Dialog as Dialog$1, Badge, AvatarStack, Skeleton, Checkbox, Select } from "@sanity/ui";
import { forwardRef, useContext, useId, useState, useEffect, useRef, useImperativeHandle, useLayoutEffect, memo, useCallback, useMemo, startTransition, useDeferredValue, useReducer, createElement, Fragment as Fragment$1, lazy } from "react";
import { PaneRouterContext, PaneLayoutContext, PaneContext, ReviewChangesContext, CommentsEnabledContext, ReferenceInputOptionsContext, DocumentPaneContext, StructureToolContext, DocumentSheetListContext, DocumentChangeContext } from "sanity/_singletons";
import { InfoOutlineIcon, DocumentsIcon, ChevronDownIcon, CopyIcon, UnknownIcon, WarningOutlineIcon, CheckmarkIcon, AddIcon, ChevronRightIcon, DocumentIcon, FolderIcon, TransferIcon, CloseIcon, LockIcon, SearchIcon, DocumentRemoveIcon, ReadOnlyIcon, ErrorOutlineIcon, SyncIcon, ComposeSparklesIcon, LaunchIcon, UnpublishIcon, StarFilledIcon, StarIcon, ArrowLeftIcon, TrashIcon, ResetIcon, RevertIcon, PublishIcon, SplitVerticalIcon, EditIcon, ChevronLeftIcon, RestoreIcon, LinkIcon, EarthAmericasIcon, JsonIcon, SpinnerIcon, EllipsisHorizontalIcon, DoubleChevronLeftIcon, DoubleChevronRightIcon, CheckmarkCircleIcon, MasterDetailIcon } from "@sanity/icons";
import { useSchema, useTranslation, unstable_useValuePreview, useDocumentVersionInfo, usePerspective, getPreviewStateObservable, getPreviewValueWithFallback, SanityDefaultPreview, DocumentPreviewPresence, DocumentStatusIndicator, DocumentStatus, useUnique, getPublishedId, useDocumentPresence, useDocumentPreviewStore, PreviewCard, Translate, createHookFromObservableFactory, getDraftId, useClient, DEFAULT_STUDIO_CLIENT_OPTIONS, useDocumentStore, LoadingBlock, LegacyLayerProvider, IsLastPaneProvider, useGetI18nText, useI18nText, TooltipOfDisabled, ContextMenuButton, StatusButton, useCurrentUser, InsufficientPermissionsMessage, useTemplates, useTemplatePermissions, EMPTY_OBJECT, EMPTY_ARRAY as EMPTY_ARRAY$2, useEditState, GetHookCollectionState, useCanvasCompanionDoc, useDocumentVersions, useActiveReleases, getVersionFromId, getReleaseIdFromReleaseDocumentId, useWorkspace, isPublishedId, isDraftId, getVersionId, ReleaseAvatar, getReleaseTone, formatRelativeLocalePublishDate, isReleaseScheduledOrScheduling, isReleaseDocument, useMiddlewareComponents, ChangeIndicatorsTracker, VirtualizerScrollInstanceProvider, useDocumentForm, FormBuilder, isVersionId, createPatchChannel, isDev, CommentsEnabledProvider, useCommentsEnabled, useStudioUrl, CommentsProvider, COMMENTS_INSPECTOR_NAME, useArchivedReleases, useDocumentOperationEvent, isNewDocument, Resizable, useKeyValueStore, isRecord, isString, isPublishedPerspective, isDraftPerspective, useDocumentOperation, isDeprecatedSchemaType, useProjectId, useZIndex, useListFormat, getVersionInlineBadge, useNavigateToCanvasDoc, getDocumentVariantType, isPerspectiveWriteable, ReleasesNav, useSanityCreateConfig, getSanityCreateLinkMetadata, LATEST, useVersionOperations, useConditionalToast, useOnlyHasVersions, useSetPerspective, VersionInlineBadge, isGoingToUnpublish, PresenceOverlay, fromMutationPatches, useManageFavorite, useActiveWorkspace, CapabilityGate, ScrollContainer, isSanityCreateLinked, isSystemBundle, useDocumentPairPermissions, useValidationStatus, useSyncState, useRelativeTime, useSource, Hotkeys, isSanityDefinedAction, useDateTimeFormat, VersionChip, useFieldActions, UserAvatar, useUser, AvatarSkeleton, CommandList, TextWithTone, useTimelineSelector, useEvents, TIMELINE_ITEM_I18N_KEY_MAPPING as TIMELINE_ITEM_I18N_KEY_MAPPING$1, resizeObserver, ChangeConnectorRoot, useGlobalCopyPasteElementHandler, GetFormValueProvider, FieldActionsResolver, FieldActionsProvider, useInitialValue, useCopyPaste, useEventsStore, EventsProvider, isDeleteDocumentGroupEvent, isDeleteDocumentVersionEvent, PerspectiveProvider, useTimelineStore, SourceProvider, CopyPasteProvider, useDocumentType, ReferenceInputOptionsProvider, ErrorActions, collate, createSWR, getSearchableTypes, createSearch, useSearchMaxFieldDepth, catchWithCount, useReconnectingToast, useSearchState, SearchHeader, Filters, SearchProvider, ChangeFieldWrapper, NoChanges, ChangeList, isUnpublishDocumentEvent, isScheduleDocumentVersionEvent, isUnscheduleDocumentVersionEvent, Event, RELEASES_INTENT, isCreateDocumentVersionEvent, isEditDocumentVersionEvent, isPublishDocumentVersionEvent, ChangesError, isArray, isValidationError, isValidationWarning, definePlugin } from "sanity";
import { uuid } from "@sanity/uuid";
import { styled, css, keyframes } from "styled-components";
import { diffInput, wrap } from "@sanity/diff";
import { motion, AnimatePresence } from "framer-motion";
import { useObservable, useObservableEvent } from "react-rx";
import { StateLink, useIntentLink, IntentLink, useRouter, route, encodeJsonParams, decodeJsonParams } from "sanity/router";
import omit from "lodash/omit.js";
import * as PathUtils from "@sanity/util/paths";
import { toString, fromString, get, resolveKeyedPath } from "@sanity/util/paths";
import { fromEvent, timer, EMPTY, of, Subject, distinctUntilChanged as distinctUntilChanged$1, filter, map as map$1, merge, startWith as startWith$1, catchError as catchError$1, concat, firstValueFrom, BehaviorSubject, from, defer, mergeMap, throwError, share, partition, throttleTime, asyncScheduler, NEVER, tap as tap$1, debounce } from "rxjs";
import fromPairs from "lodash/fromPairs.js";
import toPairs from "lodash/toPairs.js";
import ScrollMirror from "scrollmirror";
import noop from "lodash/noop.js";
import deepEquals from "react-fast-compare";
import { switchMap, startWith, map, distinctUntilChanged, shareReplay, catchError, mapTo, delay, debounceTime, tap, scan, withLatestFrom, filter as filter$1, take, mergeMap as mergeMap$1, share as share$1, takeUntil } from "rxjs/operators";
import { isHotkey } from "is-hotkey-esm";
import { JsonInspector } from "@rexxars/react-json-inspector";
import QuickLRU from "quick-lru";
import { useTelemetry } from "@sanity/telemetry/react";
import { defineEvent } from "@sanity/telemetry";
import { isAfter, addWeeks, isBefore, format } from "date-fns";
import { useEffectEvent } from "use-effect-event";
import { getTheme_v2, rgba } from "@sanity/ui/theme";
import { isSanityDocument as isSanityDocument$1, isValidationErrorMarker, isKeySegment, isIndexSegment, isReferenceSchemaType, isObjectSchemaType, isDocumentSchemaType } from "@sanity/types";
import isEqual from "lodash/isEqual.js";
import shallowEquals from "shallow-equals";
import uniqBy from "lodash/uniqBy.js";
import negate from "lodash/negate.js";
import { MenuGroup } from "./MenuGroup.mjs";
import { parse } from "groq-js";
import { ChannelError, ServerError, ClientError } from "@sanity/client";
import { observableCallback } from "observable-callback";
import { exhaustMapWithTrailing } from "rxjs-exhaustmap-with-trailing";
import { flexRender, createColumnHelper, useReactTable, getPaginationRowModel, getFilteredRowModel, getCoreRowModel } from "@tanstack/react-table";
function DocTitle(props) {
  const $ = c(21), {
    document: documentValue
  } = props, schema = useSchema();
  let t0;
  $[0] !== documentValue._type || $[1] !== schema ? (t0 = schema.get(documentValue._type), $[0] = documentValue._type, $[1] = schema, $[2] = t0) : t0 = $[2];
  const schemaType = t0, {
    t
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[3] !== documentValue || $[4] !== schemaType ? (t1 = {
    schemaType,
    value: documentValue
  }, $[3] = documentValue, $[4] = schemaType, $[5] = t1) : t1 = $[5];
  const {
    error,
    value
  } = unstable_useValuePreview(t1);
  if (!schemaType) {
    let t22;
    $[6] !== documentValue._type || $[7] !== t ? (t22 = t("doc-title.unknown-schema-type.text", {
      schemaType: documentValue._type
    }), $[6] = documentValue._type, $[7] = t, $[8] = t22) : t22 = $[8];
    let t32;
    return $[9] !== t22 ? (t32 = /* @__PURE__ */ jsx("code", { children: t22 }), $[9] = t22, $[10] = t32) : t32 = $[10], t32;
  }
  if (error) {
    let t22;
    $[11] !== error.message || $[12] !== t ? (t22 = t("doc-title.error.text", {
      errorMessage: error.message
    }), $[11] = error.message, $[12] = t, $[13] = t22) : t22 = $[13];
    let t32;
    return $[14] !== t22 ? (t32 = /* @__PURE__ */ jsx(Fragment, { children: t22 }), $[14] = t22, $[15] = t32) : t32 = $[15], t32;
  }
  let t2;
  $[16] !== t || $[17] !== value?.title ? (t2 = value?.title || /* @__PURE__ */ jsx("span", { style: {
    color: "var(--card-muted-fg-color)"
  }, children: t("doc-title.fallback.text") }), $[16] = t, $[17] = value?.title, $[18] = t2) : t2 = $[18];
  let t3;
  return $[19] !== t2 ? (t3 = /* @__PURE__ */ jsx(Fragment, { children: t2 }), $[19] = t2, $[20] = t3) : t3 = $[20], t3;
}
const ChevronWrapper = styled(Box)`
  margin-left: auto;
`, CrossDatasetReferencesDetails = styled.details`
  flex: none;

  &[open] ${ChevronWrapper} {
    transform: rotate(180deg);
  }
`, CrossDatasetReferencesSummary = styled.summary`
  list-style: none;

  &::-webkit-details-marker {
    display: none;
  }
`, Table$1 = styled.table`
  width: 100%;
  text-align: left;
  padding: 0 ${({
  theme
}) => rem(theme.sanity.space[2])};
  border-collapse: collapse;

  th {
    padding: ${({
  theme
}) => rem(theme.sanity.space[1])};
  }

  td {
    padding: 0 ${({
  theme
}) => rem(theme.sanity.space[1])};
  }

  tr > *:last-child {
    text-align: right;
  }
`, DocumentIdFlex = styled(Flex)`
  min-height: 33px;
`, OtherReferenceCount = (props) => {
  const $ = c(13), {
    t
  } = useTranslation(structureLocaleNamespace), difference = props.totalCount - props.references.length;
  if (!difference)
    return null;
  let t0;
  $[0] !== difference || $[1] !== t ? (t0 = t("confirm-delete-dialog.other-reference-count.title", {
    count: difference
  }), $[0] = difference, $[1] = t, $[2] = t0) : t0 = $[2];
  let t1;
  $[3] !== t0 ? (t1 = /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: t0 }), $[3] = t0, $[4] = t1) : t1 = $[4];
  let t2;
  $[5] !== t ? (t2 = t("confirm-delete-dialog.other-reference-count.tooltip"), $[5] = t, $[6] = t2) : t2 = $[6];
  let t3;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t3 = /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: /* @__PURE__ */ jsx(InfoOutlineIcon, {}) }), $[7] = t3) : t3 = $[7];
  let t4;
  $[8] !== t2 ? (t4 = /* @__PURE__ */ jsx(Tooltip, { portal: !0, placement: "top", content: t2, children: t3 }), $[8] = t2, $[9] = t4) : t4 = $[9];
  let t5;
  return $[10] !== t1 || $[11] !== t4 ? (t5 = /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsxs(Inline, { space: 2, children: [
    t1,
    t4
  ] }) }), $[10] = t1, $[11] = t4, $[12] = t5) : t5 = $[12], t5;
};
function PaneItemPreview(props) {
  const $ = c(27), {
    icon,
    layout,
    presence,
    schemaType,
    value
  } = props, versionsInfo = useDocumentVersionInfo(value._id), {
    perspectiveStack
  } = usePerspective();
  let t0, t1;
  $[0] !== perspectiveStack || $[1] !== props.documentPreviewStore || $[2] !== schemaType || $[3] !== value._id ? (t1 = getPreviewStateObservable(props.documentPreviewStore, schemaType, value._id, perspectiveStack), $[0] = perspectiveStack, $[1] = props.documentPreviewStore, $[2] = schemaType, $[3] = value._id, $[4] = t1) : t1 = $[4], t0 = t1;
  const previewStateObservable = t0;
  let t2;
  $[5] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {
    snapshot: null,
    isLoading: !0,
    original: null
  }, $[5] = t2) : t2 = $[5];
  const {
    snapshot,
    original,
    isLoading: previewIsLoading
  } = useObservable(previewStateObservable, t2), isLoading = previewIsLoading;
  let t3;
  $[6] !== isLoading || $[7] !== presence || $[8] !== versionsInfo.draft || $[9] !== versionsInfo.published || $[10] !== versionsInfo.versions ? (t3 = isLoading ? null : /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
    presence && presence.length > 0 && /* @__PURE__ */ jsx(DocumentPreviewPresence, { presence }),
    /* @__PURE__ */ jsx(DocumentStatusIndicator, { draft: versionsInfo.draft, published: versionsInfo.published, versions: versionsInfo.versions })
  ] }) }), $[6] = isLoading, $[7] = presence, $[8] = versionsInfo.draft, $[9] = versionsInfo.published, $[10] = versionsInfo.versions, $[11] = t3) : t3 = $[11];
  const status = t3;
  let t4;
  $[12] !== versionsInfo.draft || $[13] !== versionsInfo.published || $[14] !== versionsInfo.versions ? (t4 = /* @__PURE__ */ jsx(DocumentStatus, { draft: versionsInfo.draft, published: versionsInfo.published, versions: versionsInfo.versions }), $[12] = versionsInfo.draft, $[13] = versionsInfo.published, $[14] = versionsInfo.versions, $[15] = t4) : t4 = $[15];
  const tooltip = t4;
  let t5;
  $[16] !== original || $[17] !== snapshot || $[18] !== value ? (t5 = getPreviewValueWithFallback({
    snapshot,
    original,
    fallback: value
  }), $[16] = original, $[17] = snapshot, $[18] = value, $[19] = t5) : t5 = $[19];
  let t6;
  return $[20] !== icon || $[21] !== isLoading || $[22] !== layout || $[23] !== status || $[24] !== t5 || $[25] !== tooltip ? (t6 = /* @__PURE__ */ jsx(SanityDefaultPreview, { ...t5, isPlaceholder: isLoading, icon, layout, status, tooltip }), $[20] = icon, $[21] = isLoading, $[22] = layout, $[23] = status, $[24] = t5, $[25] = tooltip, $[26] = t6) : t6 = $[26], t6;
}
const BackLink = forwardRef(function(props, ref) {
  const $ = c(9), {
    routerPanesState,
    groupIndex
  } = useContext(PaneRouterContext);
  let t0, t1;
  $[0] !== groupIndex || $[1] !== routerPanesState ? (t1 = routerPanesState.slice(0, groupIndex), $[0] = groupIndex, $[1] = routerPanesState, $[2] = t1) : t1 = $[2], t0 = t1;
  const panes = t0;
  let t2, t3;
  $[3] !== panes ? (t3 = {
    panes
  }, $[3] = panes, $[4] = t3) : t3 = $[4], t2 = t3;
  const state2 = t2;
  let t4;
  return $[5] !== props || $[6] !== ref || $[7] !== state2 ? (t4 = /* @__PURE__ */ jsx(StateLink, { ...props, ref, state: state2 }), $[5] = props, $[6] = ref, $[7] = state2, $[8] = t4) : t4 = $[8], t4;
});
function usePaneLayout() {
  const pane2 = useContext(PaneLayoutContext);
  if (!pane2)
    throw new Error("PaneLayout: missing context value");
  return pane2;
}
const ChildLink = forwardRef(function(props, ref) {
  const $ = c(19);
  let childId, childParameters, childPayload, rest;
  $[0] !== props ? ({
    childId,
    childPayload,
    childParameters,
    ...rest
  } = props, $[0] = props, $[1] = childId, $[2] = childParameters, $[3] = childPayload, $[4] = rest) : (childId = $[1], childParameters = $[2], childPayload = $[3], rest = $[4]);
  const {
    routerPanesState,
    groupIndex
  } = useContext(PaneRouterContext);
  let t0;
  if ($[5] !== childId || $[6] !== childParameters || $[7] !== childPayload || $[8] !== groupIndex || $[9] !== routerPanesState) {
    let t12;
    $[11] !== childId || $[12] !== childParameters || $[13] !== childPayload ? (t12 = [{
      id: childId,
      params: childParameters,
      payload: childPayload
    }], $[11] = childId, $[12] = childParameters, $[13] = childPayload, $[14] = t12) : t12 = $[14], t0 = {
      panes: [...routerPanesState.slice(0, groupIndex + 1), t12]
    }, $[5] = childId, $[6] = childParameters, $[7] = childPayload, $[8] = groupIndex, $[9] = routerPanesState, $[10] = t0;
  } else
    t0 = $[10];
  let t1;
  return $[15] !== ref || $[16] !== rest || $[17] !== t0 ? (t1 = /* @__PURE__ */ jsx(StateLink, { ...rest, ref, state: t0 }), $[15] = ref, $[16] = rest, $[17] = t0, $[18] = t1) : t1 = $[18], t1;
}), ParameterizedLink = forwardRef(function(props, ref) {
  const $ = c(22), {
    routerPanesState: currentPanes,
    groupIndex,
    siblingIndex
  } = useContext(PaneRouterContext);
  let params, payload, rest;
  $[0] !== props ? ({
    params,
    payload,
    ...rest
  } = props, $[0] = props, $[1] = params, $[2] = payload, $[3] = rest) : (params = $[1], payload = $[2], rest = $[3]);
  const nextParams = useUnique(params), nextPayload = useUnique(payload);
  let t0;
  const currentGroup = currentPanes[groupIndex], currentSibling = currentGroup[siblingIndex], t1 = nextParams ?? currentSibling.params, t2 = nextPayload ?? currentSibling.payload;
  let t3;
  $[4] !== currentSibling || $[5] !== t1 || $[6] !== t2 ? (t3 = {
    ...currentSibling,
    params: t1,
    payload: t2
  }, $[4] = currentSibling, $[5] = t1, $[6] = t2, $[7] = t3) : t3 = $[7];
  const nextSibling = t3;
  let t4;
  $[8] !== currentGroup || $[9] !== nextSibling || $[10] !== siblingIndex ? (t4 = [...currentGroup.slice(0, siblingIndex), nextSibling, ...currentGroup.slice(siblingIndex + 1)], $[8] = currentGroup, $[9] = nextSibling, $[10] = siblingIndex, $[11] = t4) : t4 = $[11];
  const nextGroup = t4;
  let t5;
  $[12] !== currentPanes || $[13] !== groupIndex || $[14] !== nextGroup ? (t5 = [...currentPanes.slice(0, groupIndex), nextGroup, ...currentPanes.slice(groupIndex + 1)], $[12] = currentPanes, $[13] = groupIndex, $[14] = nextGroup, $[15] = t5) : t5 = $[15];
  const nextPanes = t5;
  let t6;
  $[16] !== nextPanes ? (t6 = {
    panes: nextPanes
  }, $[16] = nextPanes, $[17] = t6) : t6 = $[17], t0 = t6;
  const nextState = t0;
  let t7;
  return $[18] !== nextState || $[19] !== ref || $[20] !== rest ? (t7 = /* @__PURE__ */ jsx(StateLink, { ref, ...rest, state: nextState }), $[18] = nextState, $[19] = ref, $[20] = rest, $[21] = t7) : t7 = $[21], t7;
}), ReferenceChildLink = forwardRef(function(t0, ref) {
  const $ = c(22);
  let children, documentId, documentType, parentRefPath, rest, template;
  $[0] !== t0 ? ({
    documentId,
    documentType,
    parentRefPath,
    children,
    template,
    ...rest
  } = t0, $[0] = t0, $[1] = children, $[2] = documentId, $[3] = documentType, $[4] = parentRefPath, $[5] = rest, $[6] = template) : (children = $[1], documentId = $[2], documentType = $[3], parentRefPath = $[4], rest = $[5], template = $[6]);
  const t1 = template?.params;
  let t2;
  $[7] !== parentRefPath ? (t2 = toString(parentRefPath), $[7] = parentRefPath, $[8] = t2) : t2 = $[8];
  let t3;
  $[9] !== template ? (t3 = template && {
    template: template?.id
  }, $[9] = template, $[10] = t3) : t3 = $[10];
  let t4;
  $[11] !== documentType || $[12] !== t2 || $[13] !== t3 ? (t4 = {
    type: documentType,
    parentRefPath: t2,
    ...t3
  }, $[11] = documentType, $[12] = t2, $[13] = t3, $[14] = t4) : t4 = $[14];
  let t5;
  return $[15] !== children || $[16] !== documentId || $[17] !== ref || $[18] !== rest || $[19] !== t1 || $[20] !== t4 ? (t5 = /* @__PURE__ */ jsx(ChildLink, { ...rest, ref, childId: documentId, childPayload: t1, childParameters: t4, children }), $[15] = children, $[16] = documentId, $[17] = ref, $[18] = rest, $[19] = t1, $[20] = t4, $[21] = t5) : t5 = $[21], t5;
});
function usePaneRouter() {
  return useContext(PaneRouterContext);
}
const EMPTY_ARRAY$1 = [];
function ReferencePreviewLink(props) {
  const $ = c(16), {
    onClick,
    type,
    value
  } = props, t0 = value?._id;
  let t1;
  $[0] !== t0 ? (t1 = getPublishedId(t0), $[0] = t0, $[1] = t1) : t1 = $[1];
  const documentPresence = useDocumentPresence(t1), documentPreviewStore = useDocumentPreviewStore(), {
    ReferenceChildLink: ReferenceChildLink2
  } = usePaneRouter();
  let t2;
  $[2] !== ReferenceChildLink2 || $[3] !== type?.name || $[4] !== value?._id ? (t2 = function(linkProps) {
    return /* @__PURE__ */ jsx(ReferenceChildLink2, { documentId: value?._id, documentType: type?.name, parentRefPath: EMPTY_ARRAY$1, ...linkProps });
  }, $[2] = ReferenceChildLink2, $[3] = type?.name, $[4] = value?._id, $[5] = t2) : t2 = $[5];
  const t3 = t2, t4 = type?.icon, t5 = documentPresence?.length > 0 ? documentPresence : EMPTY_ARRAY$1;
  let t6;
  $[6] !== documentPreviewStore || $[7] !== t4 || $[8] !== t5 || $[9] !== type || $[10] !== value ? (t6 = /* @__PURE__ */ jsx(PaneItemPreview, { documentPreviewStore, icon: t4, layout: "compact", presence: t5, schemaType: type, value }), $[6] = documentPreviewStore, $[7] = t4, $[8] = t5, $[9] = type, $[10] = value, $[11] = t6) : t6 = $[11];
  let t7;
  return $[12] !== onClick || $[13] !== t3 || $[14] !== t6 ? (t7 = /* @__PURE__ */ jsx(PreviewCard, { __unstable_focusRing: !0, as: t3, "data-as": "a", onClick, radius: 2, children: t6 }), $[12] = onClick, $[13] = t3, $[14] = t6, $[15] = t7) : t7 = $[15], t7;
}
function ConfirmDeleteDialogBody(t0) {
  const $ = c(78), {
    crossDatasetReferences,
    internalReferences,
    documentTitle,
    totalCount,
    action,
    datasetNames,
    hasUnknownDatasetNames,
    onReferenceLinkClick
  } = t0, schema = useSchema(), toast = useToast(), {
    t
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== onReferenceLinkClick || $[1] !== schema || $[2] !== t ? (t1 = (item) => {
    const type = schema.get(item._type);
    return type ? /* @__PURE__ */ jsx(ReferencePreviewLink, { type, value: item, onClick: onReferenceLinkClick }) : /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(SanityDefaultPreview, { icon: UnknownIcon, title: t("confirm-delete-dialog.preview-item.preview-unavailable.title"), subtitle: t("confirm-delete-dialog.preview-item.preview-unavailable.subtitle", {
      documentId: item._id
    }), layout: "default" }) });
  }, $[0] = onReferenceLinkClick, $[1] = schema, $[2] = t, $[3] = t1) : t1 = $[3];
  const renderPreviewItem = t1;
  if (internalReferences?.totalCount === 0 && crossDatasetReferences?.totalCount === 0) {
    let t22;
    $[4] !== documentTitle ? (t22 = {
      DocumentTitle: () => /* @__PURE__ */ jsx("strong", { children: documentTitle })
    }, $[4] = documentTitle, $[5] = t22) : t22 = $[5];
    let t32;
    return $[6] !== action || $[7] !== t || $[8] !== t22 ? (t32 = /* @__PURE__ */ jsx(Text, { as: "p", size: 1, children: /* @__PURE__ */ jsx(Translate, { t, i18nKey: "confirm-delete-dialog.confirmation.text", context: action, components: t22 }) }), $[6] = action, $[7] = t, $[8] = t22, $[9] = t32) : t32 = $[9], t32;
  }
  let T0, T1, T2, t10, t11, t12, t2, t3, t4, t5, t6, t7, t8, t9;
  if ($[10] !== action || $[11] !== crossDatasetReferences || $[12] !== datasetNames || $[13] !== documentTitle || $[14] !== hasUnknownDatasetNames || $[15] !== internalReferences || $[16] !== renderPreviewItem || $[17] !== t || $[18] !== toast || $[19] !== totalCount) {
    const normalizedDatasetNames = [...datasetNames, ...hasUnknownDatasetNames ? ["unavailable"] : []], datasetSubtitle = t("confirm-delete-dialog.cdr-summary.subtitle", {
      count: normalizedDatasetNames.length,
      datasets: normalizedDatasetNames.join(", "),
      context: hasUnknownDatasetNames && normalizedDatasetNames.length ? "unavailable" : ""
    });
    T2 = Flex, t9 = "column", t10 = 4;
    let t132;
    $[34] === Symbol.for("react.memo_cache_sentinel") ? (t132 = /* @__PURE__ */ jsx(Text, { "aria-hidden": "true", size: 1, children: /* @__PURE__ */ jsx(WarningOutlineIcon, {}) }), $[34] = t132) : t132 = $[34];
    let t142;
    $[35] !== documentTitle ? (t142 = {
      DocumentTitle: () => documentTitle
    }, $[35] = documentTitle, $[36] = t142) : t142 = $[36];
    let t152;
    $[37] !== totalCount ? (t152 = {
      count: totalCount
    }, $[37] = totalCount, $[38] = t152) : t152 = $[38], $[39] !== t || $[40] !== t142 || $[41] !== t152 ? (t11 = /* @__PURE__ */ jsx(Card, { padding: 3, radius: 2, tone: "caution", flex: "none", children: /* @__PURE__ */ jsxs(Flex, { children: [
      t132,
      /* @__PURE__ */ jsx(Box, { flex: 1, marginLeft: 3, children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Translate, { i18nKey: "confirm-delete-dialog.referring-document-count.text", components: t142, t, values: t152 }) }) })
    ] }) }), $[39] = t, $[40] = t142, $[41] = t152, $[42] = t11) : t11 = $[42];
    let t162;
    $[43] !== documentTitle ? (t162 = {
      DocumentTitle: () => documentTitle
    }, $[43] = documentTitle, $[44] = t162) : t162 = $[44], $[45] !== action || $[46] !== t || $[47] !== t162 ? (t12 = /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Translate, { i18nKey: "confirm-delete-dialog.referring-documents-descriptor.text", t, context: action, components: t162 }) }) }), $[45] = action, $[46] = t, $[47] = t162, $[48] = t12) : t12 = $[48], T1 = Card, t5 = 2, t6 = 1, t7 = "auto", t8 = 2, T0 = Flex, t2 = "column", $[49] !== internalReferences || $[50] !== renderPreviewItem ? (t3 = internalReferences.totalCount > 0 && /* @__PURE__ */ jsxs(Stack, { as: "ul", marginBottom: 2, space: 2, "data-testid": "internal-references", children: [
      internalReferences?.references.map((item_0) => /* @__PURE__ */ jsx(Box, { as: "li", children: renderPreviewItem(item_0) }, item_0._id)),
      internalReferences.totalCount > internalReferences.references.length && /* @__PURE__ */ jsx(Box, { as: "li", padding: 3, children: /* @__PURE__ */ jsx(OtherReferenceCount, { ...internalReferences }) })
    ] }), $[49] = internalReferences, $[50] = renderPreviewItem, $[51] = t3) : t3 = $[51], t4 = crossDatasetReferences.totalCount > 0 && /* @__PURE__ */ jsxs(CrossDatasetReferencesDetails, { "data-testid": "cross-dataset-references", style: {
      borderTop: internalReferences.totalCount > 0 ? "1px solid var(--card-shadow-outline-color)" : void 0
    }, children: [
      /* @__PURE__ */ jsx(CrossDatasetReferencesSummary, { children: /* @__PURE__ */ jsx(Card, { as: "a", marginTop: internalReferences.totalCount > 0 ? 2 : 0, radius: 2, shadow: 1, paddingY: 1, children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, paddingX: 3, paddingY: 1, children: [
        /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(DocumentsIcon, {}) }),
        /* @__PURE__ */ jsxs(Stack, { space: 2, children: [
          /* @__PURE__ */ jsx(Text, { textOverflow: "ellipsis", size: 1, children: t("confirm-delete-dialog.cdr-summary.title", {
            count: normalizedDatasetNames.length,
            documentCount: t("confirm-delete-dialog.cdr-summary.document-count", {
              count: crossDatasetReferences.totalCount
            })
          }) }),
          /* @__PURE__ */ jsx(Text, { title: datasetSubtitle, textOverflow: "ellipsis", size: 1, muted: !0, children: datasetSubtitle })
        ] }),
        /* @__PURE__ */ jsx(ChevronWrapper, { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsx(ChevronDownIcon, {}) }) })
      ] }) }) }),
      /* @__PURE__ */ jsxs(Box, { overflow: "auto", paddingTop: 2, children: [
        /* @__PURE__ */ jsxs(Table$1, { children: [
          /* @__PURE__ */ jsx("thead", { children: /* @__PURE__ */ jsxs("tr", { children: [
            /* @__PURE__ */ jsx("th", { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, style: {
              minWidth: "5rem"
            }, weight: "medium", children: t("confirm-delete-dialog.cdr-table.project-id.label") }) }),
            /* @__PURE__ */ jsx("th", { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.dataset.label") }) }),
            /* @__PURE__ */ jsx("th", { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.document-id.label") }) })
          ] }) }),
          /* @__PURE__ */ jsx("tbody", { children: crossDatasetReferences.references.filter(_temp$q).map((t172, index) => {
            const {
              projectId,
              datasetName,
              documentId
            } = t172;
            return /* @__PURE__ */ jsxs("tr", { children: [
              /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsx(Text, { size: 1, children: projectId }) }),
              /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsx(Text, { size: 1, children: datasetName || "unavailable" }) }),
              /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsxs(DocumentIdFlex, { align: "center", gap: 2, justify: "flex-end", children: [
                /* @__PURE__ */ jsx(Text, { textOverflow: "ellipsis", size: 1, children: documentId || "unavailable" }),
                documentId && /* @__PURE__ */ jsx(Button, { mode: "bleed", icon: CopyIcon, tooltipProps: {
                  content: t("confirm-delete-dialog.cdr-table.copy-id-button.tooltip")
                }, onClick: () => {
                  navigator.clipboard.writeText(documentId).catch(() => {
                    toast.push({
                      status: "error",
                      title: t("confirm-delete-dialog.cdr-table.id-copied-toast.title-failed")
                    });
                  });
                } })
              ] }) })
            ] }, `${documentId}-${index}`);
          }) })
        ] }),
        /* @__PURE__ */ jsx(OtherReferenceCount, { ...crossDatasetReferences })
      ] })
    ] }), $[10] = action, $[11] = crossDatasetReferences, $[12] = datasetNames, $[13] = documentTitle, $[14] = hasUnknownDatasetNames, $[15] = internalReferences, $[16] = renderPreviewItem, $[17] = t, $[18] = toast, $[19] = totalCount, $[20] = T0, $[21] = T1, $[22] = T2, $[23] = t10, $[24] = t11, $[25] = t12, $[26] = t2, $[27] = t3, $[28] = t4, $[29] = t5, $[30] = t6, $[31] = t7, $[32] = t8, $[33] = t9;
  } else
    T0 = $[20], T1 = $[21], T2 = $[22], t10 = $[23], t11 = $[24], t12 = $[25], t2 = $[26], t3 = $[27], t4 = $[28], t5 = $[29], t6 = $[30], t7 = $[31], t8 = $[32], t9 = $[33];
  let t13;
  $[52] !== T0 || $[53] !== t2 || $[54] !== t3 || $[55] !== t4 ? (t13 = /* @__PURE__ */ jsxs(T0, { direction: t2, children: [
    t3,
    t4
  ] }), $[52] = T0, $[53] = t2, $[54] = t3, $[55] = t4, $[56] = t13) : t13 = $[56];
  let t14;
  $[57] !== T1 || $[58] !== t13 || $[59] !== t5 || $[60] !== t6 || $[61] !== t7 || $[62] !== t8 ? (t14 = /* @__PURE__ */ jsx(T1, { radius: t5, shadow: t6, flex: t7, padding: t8, children: t13 }), $[57] = T1, $[58] = t13, $[59] = t5, $[60] = t6, $[61] = t7, $[62] = t8, $[63] = t14) : t14 = $[63];
  let t15;
  $[64] !== documentTitle ? (t15 = {
    DocumentTitle: () => documentTitle
  }, $[64] = documentTitle, $[65] = t15) : t15 = $[65];
  let t16;
  $[66] !== action || $[67] !== t || $[68] !== t15 ? (t16 = /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Translate, { i18nKey: "confirm-delete-dialog.referential-integrity-disclaimer.text", t, context: action, components: t15 }) }) }), $[66] = action, $[67] = t, $[68] = t15, $[69] = t16) : t16 = $[69];
  let t17;
  return $[70] !== T2 || $[71] !== t10 || $[72] !== t11 || $[73] !== t12 || $[74] !== t14 || $[75] !== t16 || $[76] !== t9 ? (t17 = /* @__PURE__ */ jsxs(T2, { direction: t9, gap: t10, children: [
    t11,
    t12,
    t14,
    t16
  ] }), $[70] = T2, $[71] = t10, $[72] = t11, $[73] = t12, $[74] = t14, $[75] = t16, $[76] = t9, $[77] = t17) : t17 = $[77], t17;
}
function _temp$q(reference) {
  return "projectId" in reference;
}
function isClientError(e) {
  return typeof e != "object" || !e ? !1 : "statusCode" in e && "response" in e;
}
const POLL_INTERVAL = 5e3;
let visiblePoll$;
const getVisiblePoll$ = () => (visiblePoll$ || (visiblePoll$ = fromEvent(document, "visibilitychange").pipe(
  // add empty emission to have this fire on creation
  startWith(null),
  map(() => document.visibilityState === "visible"),
  distinctUntilChanged(),
  switchMap((visible) => visible ? (
    // using timer instead of interval since timer will emit on creation
    timer(0, POLL_INTERVAL)
  ) : EMPTY),
  shareReplay({
    refCount: !0,
    bufferSize: 1
  })
)), visiblePoll$);
function getDocumentExistence(documentId, {
  versionedClient
}) {
  const draftId = getDraftId(documentId), publishedId = getPublishedId(documentId), requestOptions = {
    uri: versionedClient.getDataUrl("doc", `${draftId},${publishedId}`),
    json: !0,
    query: {
      excludeContent: "true"
    },
    tag: "use-referring-documents.document-existence"
  };
  return versionedClient.observable.request(requestOptions).pipe(map(({
    omitted
  }) => {
    const nonExistant = omitted.filter((doc) => doc.reason === "existence");
    if (nonExistant.length !== 2)
      return nonExistant.length === 0 || nonExistant.some((doc) => doc.id === draftId) ? publishedId : draftId;
  }));
}
function fetchCrossDatasetReferences(documentId, context) {
  const {
    versionedClient
  } = context;
  return getVisiblePoll$().pipe(switchMap(() => getDocumentExistence(documentId, context)), switchMap((checkDocumentId) => {
    if (!checkDocumentId)
      return of({
        totalCount: 0,
        references: []
      });
    const currentDataset = versionedClient.config().dataset;
    return versionedClient.observable.request({
      url: `/data/references/${currentDataset}/documents/${checkDocumentId}/to?excludeInternalReferences=true&excludePaths=true`,
      tag: "use-referring-documents.external"
    }).pipe(catchError((e) => {
      if (isClientError(e) && e.statusCode === 404)
        return of({
          totalCount: 0,
          references: []
        });
      throw e;
    }));
  }));
}
const useInternalReferences = createHookFromObservableFactory(([documentId, documentStore]) => documentStore.listenQuery({
  fetch: '{"references":*[references($documentId)][0...100]{_id,_type},"totalCount":count(*[references($documentId)])}',
  listen: "*[references($documentId)]"
}, {
  documentId
}, {
  tag: "use-referring-documents",
  transitions: ["appear", "disappear"],
  throttleTime: 5e3
})), useCrossDatasetReferences = createHookFromObservableFactory(([documentId, versionedClient]) => getVisiblePoll$().pipe(switchMap(() => fetchCrossDatasetReferences(documentId, {
  versionedClient
}))));
function useReferringDocuments(documentId) {
  const $ = c(24), versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), documentStore = useDocumentStore();
  let t0;
  $[0] !== documentId ? (t0 = getPublishedId(documentId), $[0] = documentId, $[1] = t0) : t0 = $[1];
  const publishedId = t0;
  let t1, t2;
  $[2] !== documentStore || $[3] !== publishedId ? (t2 = [publishedId, documentStore], $[2] = documentStore, $[3] = publishedId, $[4] = t2) : t2 = $[4], t1 = t2;
  const [internalReferences, isInternalReferencesLoading] = useInternalReferences(t1);
  let t3, t4;
  $[5] !== publishedId || $[6] !== versionedClient ? (t4 = [publishedId, versionedClient], $[5] = publishedId, $[6] = versionedClient, $[7] = t4) : t4 = $[7], t3 = t4;
  const [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences(t3);
  let t5;
  $[8] !== crossDatasetReferences?.references ? (t5 = () => Array.from(new Set(crossDatasetReferences?.references.map(_temp$p).filter(Boolean))).sort(), $[8] = crossDatasetReferences?.references, $[9] = t5) : t5 = $[9];
  let t6;
  $[10] !== t5 ? (t6 = t5(), $[10] = t5, $[11] = t6) : t6 = $[11];
  const projectIds = t6;
  let t7, t8;
  $[12] !== crossDatasetReferences?.references ? (t8 = Array.from(new Set(crossDatasetReferences?.references.map(_temp2$9).filter(_temp3$2))).sort(), $[12] = crossDatasetReferences?.references, $[13] = t8) : t8 = $[13], t7 = t8;
  const datasetNames = t7;
  let t9;
  $[14] !== crossDatasetReferences?.references ? (t9 = () => !!crossDatasetReferences?.references.some(_temp4$2), $[14] = crossDatasetReferences?.references, $[15] = t9) : t9 = $[15];
  const hasUnknownDatasetNames = t9(), t10 = (internalReferences?.totalCount || 0) + (crossDatasetReferences?.totalCount || 0), t11 = isInternalReferencesLoading || isCrossDatasetReferencesLoading;
  let t12;
  return $[16] !== crossDatasetReferences || $[17] !== datasetNames || $[18] !== hasUnknownDatasetNames || $[19] !== internalReferences || $[20] !== projectIds || $[21] !== t10 || $[22] !== t11 ? (t12 = {
    totalCount: t10,
    projectIds,
    datasetNames,
    hasUnknownDatasetNames,
    internalReferences,
    crossDatasetReferences,
    isLoading: t11
  }, $[16] = crossDatasetReferences, $[17] = datasetNames, $[18] = hasUnknownDatasetNames, $[19] = internalReferences, $[20] = projectIds, $[21] = t10, $[22] = t11, $[23] = t12) : t12 = $[23], t12;
}
function _temp4$2(crossDatasetReference_1) {
  return typeof crossDatasetReference_1.datasetName != "string";
}
function _temp3$2(datasetName) {
  return !!datasetName && datasetName !== "";
}
function _temp2$9(crossDatasetReference_0) {
  return crossDatasetReference_0?.datasetName || "";
}
function _temp$p(crossDatasetReference) {
  return crossDatasetReference.projectId;
}
const DialogBody$1 = styled(Box)`
  box-sizing: border-box;
`, LoadingContainer = styled(Flex).attrs({
  align: "center",
  direction: "column",
  justify: "center"
})`
  height: 110px;
`;
function ConfirmDeleteDialog(t0) {
  const $ = c(40), {
    id,
    type,
    action: t1,
    onCancel,
    onConfirm
  } = t0, action = t1 === void 0 ? "delete" : t1, {
    t
  } = useTranslation(structureLocaleNamespace), dialogId = `deletion-confirmation-${useId()}`, {
    internalReferences,
    crossDatasetReferences,
    isLoading,
    totalCount,
    projectIds,
    datasetNames,
    hasUnknownDatasetNames
  } = useReferringDocuments(id);
  let t2, t3;
  $[0] !== id || $[1] !== type ? (t3 = {
    _id: id,
    _type: type
  }, $[0] = id, $[1] = type, $[2] = t3) : t3 = $[2], t2 = t3;
  let t4;
  $[3] !== t2 ? (t4 = /* @__PURE__ */ jsx(DocTitle, { document: t2 }), $[3] = t2, $[4] = t4) : t4 = $[4];
  const documentTitle = t4, showConfirmButton = !isLoading;
  let t5;
  $[5] !== action || $[6] !== t ? (t5 = t("confirm-delete-dialog.header.text", {
    context: action
  }), $[5] = action, $[6] = t, $[7] = t5) : t5 = $[7];
  let t6;
  $[8] !== t ? (t6 = t("confirm-delete-dialog.cancel-button.text"), $[8] = t, $[9] = t6) : t6 = $[9];
  let t7;
  $[10] !== onCancel || $[11] !== t6 ? (t7 = {
    onClick: onCancel,
    text: t6
  }, $[10] = onCancel, $[11] = t6, $[12] = t7) : t7 = $[12];
  let t8;
  $[13] !== action || $[14] !== onConfirm || $[15] !== showConfirmButton || $[16] !== t || $[17] !== totalCount ? (t8 = showConfirmButton ? {
    text: totalCount > 0 ? t("confirm-delete-dialog.confirm-anyway-button.text", {
      context: action
    }) : t("confirm-delete-dialog.confirm-button.text", {
      context: action
    }),
    onClick: onConfirm
  } : void 0, $[13] = action, $[14] = onConfirm, $[15] = showConfirmButton, $[16] = t, $[17] = totalCount, $[18] = t8) : t8 = $[18];
  let t9;
  $[19] !== t7 || $[20] !== t8 ? (t9 = {
    cancelButton: t7,
    confirmButton: t8
  }, $[19] = t7, $[20] = t8, $[21] = t9) : t9 = $[21];
  let t10;
  $[22] !== action || $[23] !== crossDatasetReferences || $[24] !== datasetNames || $[25] !== documentTitle || $[26] !== hasUnknownDatasetNames || $[27] !== internalReferences || $[28] !== isLoading || $[29] !== onCancel || $[30] !== projectIds || $[31] !== t || $[32] !== totalCount ? (t10 = /* @__PURE__ */ jsx(DialogBody$1, { children: crossDatasetReferences && internalReferences && !isLoading ? /* @__PURE__ */ jsx(ConfirmDeleteDialogBody, { crossDatasetReferences, internalReferences, documentTitle, isLoading, totalCount, action, projectIds, datasetNames, hasUnknownDatasetNames, onReferenceLinkClick: onCancel }) : /* @__PURE__ */ jsx(LoadingContainer, { "data-testid": "loading-container", children: /* @__PURE__ */ jsx(LoadingBlock, { showText: !0, title: t("confirm-delete-dialog.loading.text") }) }) }), $[22] = action, $[23] = crossDatasetReferences, $[24] = datasetNames, $[25] = documentTitle, $[26] = hasUnknownDatasetNames, $[27] = internalReferences, $[28] = isLoading, $[29] = onCancel, $[30] = projectIds, $[31] = t, $[32] = totalCount, $[33] = t10) : t10 = $[33];
  let t11;
  return $[34] !== dialogId || $[35] !== onCancel || $[36] !== t10 || $[37] !== t5 || $[38] !== t9 ? (t11 = /* @__PURE__ */ jsx(Dialog, { width: 1, id: dialogId, header: t5, footer: t9, onClose: onCancel, onClickOutside: onCancel, children: t10 }), $[34] = dialogId, $[35] = onCancel, $[36] = t10, $[37] = t5, $[38] = t9, $[39] = t11) : t11 = $[39], t11;
}
function ConfirmDeleteDialogContainer(props) {
  const $ = c(6), {
    t
  } = useTranslation(structureLocaleNamespace), id = useId(), [error, setError] = useState(null);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => setError(null), $[0] = t0) : t0 = $[0];
  const handleRetry = t0;
  let t1;
  return $[1] !== error || $[2] !== id || $[3] !== props || $[4] !== t ? (t1 = error ? /* @__PURE__ */ jsx(Dialog, { id: `dialog-error-${id}`, "data-testid": "confirm-delete-error-dialog", header: t("confirm-delete-dialog.error.title.text"), footer: {
    confirmButton: {
      text: t("confirm-delete-dialog.error.retry-button.text"),
      onClick: handleRetry,
      tone: "default"
    }
  }, onClose: props.onCancel, children: /* @__PURE__ */ jsx(Box, { padding: 4, children: /* @__PURE__ */ jsx(Text, { size: 1, children: t("confirm-delete-dialog.error.message.text") }) }) }) : /* @__PURE__ */ jsx(ErrorBoundary, { onCatch: setError, children: /* @__PURE__ */ jsx(ConfirmDeleteDialog, { ...props }) }), $[1] = error, $[2] = id, $[3] = props, $[4] = t, $[5] = t1) : t1 = $[5], t1;
}
function Delay(t0) {
  const $ = c(6), {
    children,
    ms: t1
  } = t0, ms = t1 === void 0 ? 0 : t1, [ready, setReady] = useState(ms <= 0);
  let t2, t3;
  if ($[0] !== ms ? (t2 = () => {
    if (ms <= 0)
      return;
    const timeoutId = setTimeout(() => setReady(!0), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, t3 = [ms], $[0] = ms, $[1] = t2, $[2] = t3) : (t2 = $[1], t3 = $[2]), useEffect(t2, t3), !ready || !children) {
    let t42;
    return $[3] === Symbol.for("react.memo_cache_sentinel") ? (t42 = /* @__PURE__ */ jsx(Fragment, {}), $[3] = t42) : t42 = $[3], t42;
  }
  let t4;
  return $[4] !== children ? (t4 = typeof children == "function" ? children() : children, $[4] = children, $[5] = t4) : t4 = $[5], t4;
}
const PANE_DEBUG = !1, PANE_COLLAPSED_WIDTH = 51, PANE_DEFAULT_MIN_WIDTH = 204, Root$9 = styled(Layer)`
  position: relative;
  width: 1px;
  min-width: 1px;

  &:before {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    width: 1px;
    background-color: var(--card-border-color);
  }

  &:not([data-disabled]) {
    cursor: ew-resize;
    width: 9px;
    min-width: 9px;
    margin: 0 -4px;

    &:before {
      left: 4px;
    }

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 9px;
      bottom: 0;
      background-color: var(--card-border-color);
      opacity: 0;
      transition: opacity 150ms;
    }

    &[data-dragging]:after,
    &:hover:after {
      opacity: 0.2;
    }
  }
`;
function PaneDivider(t0) {
  const $ = c(7), {
    disabled,
    element
  } = t0, {
    resize
  } = usePaneLayout(), [dragging, setDragging] = useState(!1);
  let t1;
  $[0] !== element || $[1] !== resize ? (t1 = (event) => {
    if (!element)
      return;
    setDragging(!0), event.preventDefault();
    const startX = event.pageX;
    resize("start", element, 0);
    const handleMouseMove = (e) => {
      e.preventDefault();
      const deltaX = e.pageX - startX;
      resize("move", element, deltaX);
    }, handleMouseUp = (e_0) => {
      e_0.preventDefault(), setDragging(!1), window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("mouseup", handleMouseUp), resize("end", element, 0);
    };
    window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
  }, $[0] = element, $[1] = resize, $[2] = t1) : t1 = $[2];
  const handleMouseDown = t1, t2 = disabled ? "" : void 0, t3 = dragging ? "" : void 0;
  let t4;
  return $[3] !== handleMouseDown || $[4] !== t2 || $[5] !== t3 ? (t4 = /* @__PURE__ */ jsx(Root$9, { "data-disabled": t2, "data-dragging": t3, onMouseDown: handleMouseDown }), $[3] = handleMouseDown, $[4] = t2, $[5] = t3, $[6] = t4) : t4 = $[6], t4;
}
const Root$8 = styled(Card)`
  outline: none;

  // NOTE: This will render a border to the right side of each pane
  // without taking up physical space.
  box-shadow: 1px 0 0 var(--card-border-color);
`, Pane = forwardRef(function(props, forwardedRef) {
  const $ = c(86);
  let children, currentMaxWidthProp, currentMinWidthProp, id, maxWidthProp, minWidthProp, restProps, t0, t1;
  $[0] !== props ? ({
    children,
    currentMinWidth: currentMinWidthProp,
    currentMaxWidth: currentMaxWidthProp,
    flex: t0,
    id,
    minWidth: minWidthProp,
    maxWidth: maxWidthProp,
    selected: t1,
    ...restProps
  } = props, $[0] = props, $[1] = children, $[2] = currentMaxWidthProp, $[3] = currentMinWidthProp, $[4] = id, $[5] = maxWidthProp, $[6] = minWidthProp, $[7] = restProps, $[8] = t0, $[9] = t1) : (children = $[1], currentMaxWidthProp = $[2], currentMinWidthProp = $[3], id = $[4], maxWidthProp = $[5], minWidthProp = $[6], restProps = $[7], t0 = $[8], t1 = $[9]);
  const flexProp = t0 === void 0 ? 1 : t0, selected = t1 === void 0 ? !1 : t1, [rootElement, setRootElement] = useState(null), {
    collapse,
    collapsed: layoutCollapsed,
    expand,
    expandedElement,
    mount,
    panes
  } = usePaneLayout();
  let pane2, t2;
  if ($[10] !== panes || $[11] !== rootElement) {
    let t32;
    $[14] !== rootElement ? (t32 = (p) => p.element === rootElement, $[14] = rootElement, $[15] = t32) : t32 = $[15], pane2 = panes.find(t32), t2 = pane2 && panes.indexOf(pane2), $[10] = panes, $[11] = rootElement, $[12] = pane2, $[13] = t2;
  } else
    pane2 = $[12], t2 = $[13];
  const paneIndex = t2, nextPane = typeof paneIndex == "number" ? panes[paneIndex + 1] : void 0, isLast = paneIndex === panes.length - 1, expanded = expandedElement === rootElement, collapsed = layoutCollapsed ? !1 : pane2?.collapsed || !1, nextCollapsed = nextPane?.collapsed || !1, ref = useRef(null), flex = pane2?.flex ?? flexProp, currentMinWidth = pane2?.currentMinWidth ?? currentMinWidthProp, currentMaxWidth = pane2?.currentMaxWidth ?? currentMaxWidthProp;
  let t3;
  $[16] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => ref.current, $[16] = t3) : t3 = $[16], useImperativeHandle(forwardedRef, t3);
  let t4;
  $[17] === Symbol.for("react.memo_cache_sentinel") ? (t4 = (refValue) => {
    setRootElement(refValue), ref.current = refValue;
  }, $[17] = t4) : t4 = $[17];
  const setRef = t4;
  let t5, t6;
  $[18] !== currentMaxWidthProp || $[19] !== currentMinWidthProp || $[20] !== flexProp || $[21] !== id || $[22] !== maxWidthProp || $[23] !== minWidthProp || $[24] !== mount || $[25] !== rootElement ? (t5 = () => {
    if (rootElement)
      return mount(rootElement, {
        currentMinWidth: currentMinWidthProp,
        currentMaxWidth: currentMaxWidthProp,
        flex: flexProp,
        id,
        minWidth: minWidthProp,
        maxWidth: maxWidthProp
      });
  }, t6 = [currentMinWidthProp, currentMaxWidthProp, flexProp, id, minWidthProp, maxWidthProp, mount, rootElement], $[18] = currentMaxWidthProp, $[19] = currentMinWidthProp, $[20] = flexProp, $[21] = id, $[22] = maxWidthProp, $[23] = minWidthProp, $[24] = mount, $[25] = rootElement, $[26] = t5, $[27] = t6) : (t5 = $[26], t6 = $[27]), useLayoutEffect(t5, t6);
  let t7;
  $[28] !== collapse || $[29] !== rootElement ? (t7 = () => {
    rootElement && collapse(rootElement);
  }, $[28] = collapse, $[29] = rootElement, $[30] = t7) : t7 = $[30];
  const handleCollapse = t7;
  let t8;
  $[31] !== expand || $[32] !== rootElement ? (t8 = () => {
    rootElement && expand(rootElement);
  }, $[31] = expand, $[32] = rootElement, $[33] = t8) : t8 = $[33];
  const handleExpand = t8;
  let t9;
  const t10 = layoutCollapsed ? !1 : collapsed;
  let t11;
  $[34] !== handleCollapse || $[35] !== handleExpand || $[36] !== isLast || $[37] !== paneIndex || $[38] !== rootElement || $[39] !== t10 ? (t11 = {
    collapse: handleCollapse,
    collapsed: t10,
    expand: handleExpand,
    index: paneIndex,
    isLast,
    rootElement
  }, $[34] = handleCollapse, $[35] = handleExpand, $[36] = isLast, $[37] = paneIndex, $[38] = rootElement, $[39] = t10, $[40] = t11) : t11 = $[40], t9 = t11;
  const contextValue = t9;
  let t12;
  bb0: {
    if (layoutCollapsed) {
      t12 = void 0;
      break bb0;
    }
    if (collapsed) {
      t12 = PANE_COLLAPSED_WIDTH;
      break bb0;
    }
    if (currentMinWidth === 0) {
      t12 = minWidthProp || PANE_DEFAULT_MIN_WIDTH;
      break bb0;
    }
    if (isLast) {
      t12 = minWidthProp || PANE_DEFAULT_MIN_WIDTH;
      break bb0;
    }
    t12 = currentMinWidth || minWidthProp || PANE_DEFAULT_MIN_WIDTH;
  }
  const minWidth = t12;
  let t13;
  bb1: {
    if (collapsed) {
      t13 = PANE_COLLAPSED_WIDTH;
      break bb1;
    }
    if (layoutCollapsed && isLast) {
      t13 = void 0;
      break bb1;
    }
    if (isLast) {
      if (maxWidthProp) {
        t13 = currentMaxWidth ?? maxWidthProp;
        break bb1;
      }
      t13 = void 0;
      break bb1;
    }
    t13 = currentMaxWidth ?? maxWidthProp;
  }
  const maxWidth = t13, hidden = layoutCollapsed && !isLast;
  let t14, t15;
  $[41] !== collapsed || $[42] !== isLast || $[43] !== layoutCollapsed || $[44] !== nextCollapsed || $[45] !== rootElement ? (t15 = !isLast && !layoutCollapsed && /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneResizer", children: /* @__PURE__ */ jsx(PaneDivider, { disabled: collapsed || nextCollapsed, element: rootElement }) }), $[41] = collapsed, $[42] = isLast, $[43] = layoutCollapsed, $[44] = nextCollapsed, $[45] = rootElement, $[46] = t15) : t15 = $[46], t14 = t15;
  const divider = t14;
  let t16;
  const t17 = maxWidth === 1 / 0 ? void 0 : maxWidth;
  let t18;
  $[47] !== flex || $[48] !== minWidth || $[49] !== t17 ? (t18 = {
    flex,
    minWidth,
    maxWidth: t17
  }, $[47] = flex, $[48] = minWidth, $[49] = t17, $[50] = t18) : t18 = $[50], t16 = t18;
  const style = t16, t19 = layoutCollapsed ? void 0 : "hidden", t20 = collapsed ? "" : void 0, t21 = selected ? "" : void 0;
  let t22;
  $[51] !== collapsed || $[52] !== currentMaxWidth || $[53] !== currentMinWidth || $[54] !== expanded || $[55] !== flex || $[56] !== maxWidth || $[57] !== minWidth || $[58] !== paneIndex ? (t22 = PANE_DEBUG, $[51] = collapsed, $[52] = currentMaxWidth, $[53] = currentMinWidth, $[54] = expanded, $[55] = flex, $[56] = maxWidth, $[57] = minWidth, $[58] = paneIndex, $[59] = t22) : t22 = $[59];
  let t23;
  $[60] !== children || $[61] !== hidden ? (t23 = !hidden && /* @__PURE__ */ jsx(Flex, { direction: "column", height: "fill", children }), $[60] = children, $[61] = hidden, $[62] = t23) : t23 = $[62];
  let t24;
  $[63] !== rootElement || $[64] !== t23 ? (t24 = /* @__PURE__ */ jsx(BoundaryElementProvider, { element: rootElement, children: t23 }), $[63] = rootElement, $[64] = t23, $[65] = t24) : t24 = $[65];
  let t25;
  $[66] !== hidden || $[67] !== id || $[68] !== paneIndex || $[69] !== restProps || $[70] !== style || $[71] !== t19 || $[72] !== t20 || $[73] !== t21 || $[74] !== t22 || $[75] !== t24 ? (t25 = /* @__PURE__ */ jsxs(Root$8, { "data-testid": "pane", "data-ui": "Pane", tone: "inherit", hidden, id, overflow: t19, ...restProps, "data-pane-collapsed": t20, "data-pane-index": paneIndex, "data-pane-selected": t21, ref: setRef, style, children: [
    t22,
    t24
  ] }), $[66] = hidden, $[67] = id, $[68] = paneIndex, $[69] = restProps, $[70] = style, $[71] = t19, $[72] = t20, $[73] = t21, $[74] = t22, $[75] = t24, $[76] = t25) : t25 = $[76];
  let t26;
  $[77] !== isLast || $[78] !== t25 ? (t26 = /* @__PURE__ */ jsx(IsLastPaneProvider, { isLastPane: isLast, children: t25 }), $[77] = isLast, $[78] = t25, $[79] = t26) : t26 = $[79];
  let t27;
  $[80] !== contextValue || $[81] !== t26 ? (t27 = /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "pane", children: /* @__PURE__ */ jsx(PaneContext.Provider, { value: contextValue, children: t26 }) }), $[80] = contextValue, $[81] = t26, $[82] = t27) : t27 = $[82];
  let t28;
  return $[83] !== divider || $[84] !== t27 ? (t28 = /* @__PURE__ */ jsxs(Fragment, { children: [
    t27,
    divider
  ] }), $[83] = divider, $[84] = t27, $[85] = t28) : t28 = $[85], t28;
}), Root$7 = styled(Card)`
  position: relative;
  outline: none;
`;
Root$7.displayName = "PaneContent__root";
function usePane() {
  const pane2 = useContext(PaneContext);
  if (!pane2)
    throw new Error("Pane: missing context value");
  return pane2;
}
const PaneContent = forwardRef(function(props, ref) {
  const $ = c(14);
  let as, children, overflow, padding, restProps;
  $[0] !== props ? ({
    as,
    children,
    overflow,
    padding,
    ...restProps
  } = props, $[0] = props, $[1] = as, $[2] = children, $[3] = overflow, $[4] = padding, $[5] = restProps) : (as = $[1], children = $[2], overflow = $[3], padding = $[4], restProps = $[5]);
  const {
    collapsed
  } = usePane(), {
    collapsed: layoutCollapsed
  } = usePaneLayout(), t0 = layoutCollapsed ? void 0 : overflow;
  let t1;
  return $[6] !== as || $[7] !== children || $[8] !== collapsed || $[9] !== padding || $[10] !== ref || $[11] !== restProps || $[12] !== t0 ? (t1 = /* @__PURE__ */ jsx(Root$7, { "data-testid": "pane-content", forwardedAs: as, ...restProps, flex: 1, hidden: collapsed, overflow: t0, padding, ref, tone: "inherit", children }), $[6] = as, $[7] = children, $[8] = collapsed, $[9] = padding, $[10] = ref, $[11] = restProps, $[12] = t0, $[13] = t1) : t1 = $[13], t1;
});
function toLowerCaseNoSpaces(str) {
  return str ? str.toLocaleLowerCase().replaceAll(" ", "") : "";
}
const MENU_GROUP_POPOVER_PROPS = {
  constrainSize: !0,
  placement: "left-start",
  portal: !0
};
function PaneMenuButtonItem(props) {
  const $ = c(35), {
    disabled,
    isAfterGroup,
    node
  } = props, getI18nText = useGetI18nText("i18n" in node ? node : void 0);
  if (node.type === "divider") {
    let t02;
    return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t02 = /* @__PURE__ */ jsx(MenuDivider, {}), $[0] = t02) : t02 = $[0], t02;
  }
  let t0;
  $[1] !== getI18nText || $[2] !== node ? (t0 = getI18nText(node), $[1] = getI18nText, $[2] = node, $[3] = t0) : t0 = $[3];
  const {
    title
  } = t0;
  if (node.type === "group") {
    if (node.children.length === 0)
      return null;
    if (node.expanded) {
      let t13;
      $[4] !== isAfterGroup ? (t13 = isAfterGroup && /* @__PURE__ */ jsx(MenuDivider, {}), $[4] = isAfterGroup, $[5] = t13) : t13 = $[5];
      let t23;
      $[6] !== disabled || $[7] !== node.children || $[8] !== node.disabled ? (t23 = node.children.map((child, childIndex) => /* @__PURE__ */ jsx(PaneMenuButtonItem, { disabled: disabled || !!node.disabled, isAfterGroup: node.children[childIndex - 1]?.type === "group", node: child }, child.key)), $[6] = disabled, $[7] = node.children, $[8] = node.disabled, $[9] = t23) : t23 = $[9];
      let t33;
      return $[10] !== t13 || $[11] !== t23 ? (t33 = /* @__PURE__ */ jsxs(Fragment, { children: [
        t13,
        t23
      ] }), $[10] = t13, $[11] = t23, $[12] = t33) : t33 = $[12], t33;
    }
    let t12;
    $[13] !== isAfterGroup ? (t12 = isAfterGroup && /* @__PURE__ */ jsx(MenuDivider, {}), $[13] = isAfterGroup, $[14] = t12) : t12 = $[14];
    const t22 = node.icon;
    let t32;
    $[15] !== disabled || $[16] !== node.children || $[17] !== node.disabled ? (t32 = node.children.map((child_0, childIndex_0) => /* @__PURE__ */ jsx(PaneMenuButtonItem, { disabled: disabled || !!node.disabled, isAfterGroup: node.children[childIndex_0 - 1]?.type === "group", node: child_0 }, child_0.key)), $[15] = disabled, $[16] = node.children, $[17] = node.disabled, $[18] = t32) : t32 = $[18];
    let t4;
    $[19] !== disabled || $[20] !== node.icon || $[21] !== t32 || $[22] !== title ? (t4 = /* @__PURE__ */ jsx(MenuGroup, { disabled, icon: t22, popover: MENU_GROUP_POPOVER_PROPS, text: title, children: t32 }), $[19] = disabled, $[20] = node.icon, $[21] = t32, $[22] = title, $[23] = t4) : t4 = $[23];
    let t5;
    return $[24] !== t12 || $[25] !== t4 ? (t5 = /* @__PURE__ */ jsxs(Fragment, { children: [
      t12,
      t4
    ] }), $[24] = t12, $[25] = t4, $[26] = t5) : t5 = $[26], t5;
  }
  let t1;
  $[27] !== isAfterGroup ? (t1 = isAfterGroup && /* @__PURE__ */ jsx(MenuDivider, {}), $[27] = isAfterGroup, $[28] = t1) : t1 = $[28];
  let t2;
  $[29] !== disabled || $[30] !== node ? (t2 = /* @__PURE__ */ jsx(PaneContextMenuItemResolver, { disabled, node }), $[29] = disabled, $[30] = node, $[31] = t2) : t2 = $[31];
  let t3;
  return $[32] !== t1 || $[33] !== t2 ? (t3 = /* @__PURE__ */ jsxs(Fragment, { children: [
    t1,
    t2
  ] }), $[32] = t1, $[33] = t2, $[34] = t3) : t3 = $[34], t3;
}
function PaneContextMenuItemResolver(props) {
  const $ = c(5), {
    node
  } = props;
  if (node.intent) {
    let t02;
    return $[0] !== node.intent || $[1] !== props ? (t02 = /* @__PURE__ */ jsx(PaneContextIntentMenuItem, { ...props, intent: node.intent }), $[0] = node.intent, $[1] = props, $[2] = t02) : t02 = $[2], t02;
  }
  let t0;
  return $[3] !== props ? (t0 = /* @__PURE__ */ jsx(PaneContextMenuItem, { ...props }), $[3] = props, $[4] = t0) : t0 = $[4], t0;
}
function PaneContextMenuItem(props) {
  const $ = c(17), {
    disabled,
    node
  } = props;
  let t0;
  $[0] !== node.disabled ? (t0 = typeof node.disabled == "object" && /* @__PURE__ */ jsx(Text, { size: 1, children: node.disabled.reason }), $[0] = node.disabled, $[1] = t0) : t0 = $[1];
  const tooltipContent = t0, {
    title
  } = useI18nText(node), t1 = disabled || !!node.disabled;
  let t2;
  $[2] !== node.hotkey ? (t2 = node.hotkey?.split("+"), $[2] = node.hotkey, $[3] = t2) : t2 = $[3];
  const t3 = node.iconRight || node.selected && CheckmarkIcon, t4 = `action-${toLowerCaseNoSpaces(node.title)}`;
  let t5;
  $[4] !== node.icon || $[5] !== node.onAction || $[6] !== node.selected || $[7] !== node.tone || $[8] !== t1 || $[9] !== t2 || $[10] !== t3 || $[11] !== t4 || $[12] !== title ? (t5 = /* @__PURE__ */ jsx(MenuItem, { disabled: t1, hotkeys: t2, icon: node.icon, iconRight: t3, onClick: node.onAction, pressed: node.selected, text: title, tone: node.tone, "data-testid": t4 }), $[4] = node.icon, $[5] = node.onAction, $[6] = node.selected, $[7] = node.tone, $[8] = t1, $[9] = t2, $[10] = t3, $[11] = t4, $[12] = title, $[13] = t5) : t5 = $[13];
  let t6;
  return $[14] !== t5 || $[15] !== tooltipContent ? (t6 = /* @__PURE__ */ jsx(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: t5 }), $[14] = t5, $[15] = tooltipContent, $[16] = t6) : t6 = $[16], t6;
}
function PaneContextIntentMenuItem(props) {
  const $ = c(23), {
    disabled,
    intent,
    node
  } = props;
  let t0;
  $[0] !== node.disabled ? (t0 = typeof node.disabled == "object" && /* @__PURE__ */ jsx(Text, { size: 1, children: node.disabled.reason }), $[0] = node.disabled, $[1] = t0) : t0 = $[1];
  const tooltipContent = t0;
  let t1;
  $[2] !== intent.params || $[3] !== intent.type ? (t1 = {
    intent: intent.type,
    params: intent.params
  }, $[2] = intent.params, $[3] = intent.type, $[4] = t1) : t1 = $[4];
  const intentLink = useIntentLink(t1);
  let t2;
  $[5] !== intentLink || $[6] !== node ? (t2 = (event) => {
    intentLink.onClick(event), node.onAction();
  }, $[5] = intentLink, $[6] = node, $[7] = t2) : t2 = $[7];
  const handleClick = t2, {
    title
  } = useI18nText(node), t3 = disabled || !!node.disabled;
  let t4;
  $[8] !== node.hotkey ? (t4 = node.hotkey?.split("+"), $[8] = node.hotkey, $[9] = t4) : t4 = $[9];
  const t5 = node.selected ? CheckmarkIcon : void 0;
  let t6;
  $[10] !== handleClick || $[11] !== intentLink.href || $[12] !== node.icon || $[13] !== node.selected || $[14] !== node.tone || $[15] !== t3 || $[16] !== t4 || $[17] !== t5 || $[18] !== title ? (t6 = /* @__PURE__ */ jsx(MenuItem, { as: "a", disabled: t3, hotkeys: t4, href: intentLink.href, icon: node.icon, iconRight: t5, onClick: handleClick, pressed: node.selected, text: title, tone: node.tone }), $[10] = handleClick, $[11] = intentLink.href, $[12] = node.icon, $[13] = node.selected, $[14] = node.tone, $[15] = t3, $[16] = t4, $[17] = t5, $[18] = title, $[19] = t6) : t6 = $[19];
  let t7;
  return $[20] !== t6 || $[21] !== tooltipContent ? (t7 = /* @__PURE__ */ jsx(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: t6 }), $[20] = t6, $[21] = tooltipContent, $[22] = t7) : t7 = $[22], t7;
}
const CONTEXT_MENU_POPOVER_PROPS = {
  constrainSize: !0,
  placement: "bottom",
  portal: !0
};
function nodesHasTone(nodes, tone) {
  return nodes.some((node) => node.type === "item" && node.tone === tone || node.type === "group" && nodesHasTone(node.children, tone));
}
function PaneContextMenuButton(props) {
  const $ = c(13), {
    nodes,
    actionsNodes
  } = props, id = useId(), hasCritical = nodesHasTone(nodes, "critical"), hasCaution = nodesHasTone(nodes, "caution"), t0 = hasCritical ? "critical" : hasCaution ? "caution" : void 0;
  let t1;
  $[0] !== t0 ? (t1 = /* @__PURE__ */ jsx(ContextMenuButton, { tone: t0, "data-testid": "pane-context-menu-button" }), $[0] = t0, $[1] = t1) : t1 = $[1];
  let t2;
  $[2] !== actionsNodes ? (t2 = actionsNodes && /* @__PURE__ */ jsxs(Fragment, { children: [
    actionsNodes,
    /* @__PURE__ */ jsx(MenuDivider, {})
  ] }), $[2] = actionsNodes, $[3] = t2) : t2 = $[3];
  let t3;
  $[4] !== nodes ? (t3 = nodes.map((node, nodeIndex) => {
    const isAfterGroup = nodes[nodeIndex - 1]?.type === "group";
    return /* @__PURE__ */ jsx(PaneMenuButtonItem, { isAfterGroup, node }, node.key);
  }), $[4] = nodes, $[5] = t3) : t3 = $[5];
  let t4;
  $[6] !== t2 || $[7] !== t3 ? (t4 = /* @__PURE__ */ jsxs(Menu, { children: [
    t2,
    t3
  ] }), $[6] = t2, $[7] = t3, $[8] = t4) : t4 = $[8];
  let t5;
  return $[9] !== id || $[10] !== t1 || $[11] !== t4 ? (t5 = /* @__PURE__ */ jsx(MenuButton, { button: t1, id, menu: t4, popover: CONTEXT_MENU_POPOVER_PROPS }), $[9] = id, $[10] = t1, $[11] = t4, $[12] = t5) : t5 = $[12], t5;
}
const Root$6 = styled(Layer)`
  position: sticky;
  bottom: 0;
`, RootCard = styled(Card)`
  padding-bottom: env(safe-area-inset-bottom);
`, PaneFooter = forwardRef(function(props, ref) {
  const $ = c(7), {
    children,
    padding
  } = props, {
    collapsed
  } = usePane();
  let t0;
  $[0] !== children || $[1] !== padding ? (t0 = /* @__PURE__ */ jsx(RootCard, { tone: "inherit", children: /* @__PURE__ */ jsx(Box, { padding, children }) }), $[0] = children, $[1] = padding, $[2] = t0) : t0 = $[2];
  let t1;
  return $[3] !== collapsed || $[4] !== ref || $[5] !== t0 ? (t1 = /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsx(Root$6, { "data-testid": "pane-footer", hidden: collapsed, ref, children: t0 }) }), $[3] = collapsed, $[4] = ref, $[5] = t0, $[6] = t1) : t1 = $[6], t1;
}), Root$5 = styled(Layer)(({
  $border
}) => css`
    line-height: 0;
    position: sticky;
    top: 0;

    &:not([data-collapsed]):after {
      content: '';
      display: block;
      position: absolute;
      left: 0;
      right: 0;
      bottom: -1px;
      border-bottom: 1px solid ${$border ? "var(--card-border-color)" : "transparent"};
      opacity: 1;
    }
  `), Layout = styled(Flex)`
  transform-origin: calc(51px / 2);

  [data-collapsed] > div > & {
    transform: rotate(90deg);
  }
`, TitleCard = styled(Card)(({
  theme
}) => {
  const {
    fg,
    bg
  } = theme.sanity.color.card.enabled;
  return css`
    background-color: ${bg};

    [data-ui='Text'] {
      color: ${fg};
    }
  `;
}), TitleTextSkeleton = styled(TextSkeleton)`
  width: 66%;
  max-width: 175px;
`, TitleText = styled(Text)`
  cursor: default;
  outline: none;
`, PaneHeader$1 = forwardRef(function(props, ref) {
  const $ = c(48), {
    actions,
    backButton,
    border,
    contentAfter,
    loading,
    subActions,
    tabs,
    tabIndex,
    title,
    appendTitle
  } = props, {
    collapse,
    collapsed,
    expand,
    rootElement: paneElement
  } = usePane(), paneRect = useElementRect(paneElement || null);
  let t0;
  const t1 = collapsed ? paneRect?.height || window.innerHeight : void 0;
  let t2;
  $[0] !== t1 ? (t2 = {
    width: t1
  }, $[0] = t1, $[1] = t2) : t2 = $[1], t0 = t2;
  const layoutStyle = t0;
  let t3;
  $[2] !== collapse || $[3] !== collapsed ? (t3 = () => {
    collapsed || collapse();
  }, $[2] = collapse, $[3] = collapsed, $[4] = t3) : t3 = $[4];
  const handleTitleClick = t3;
  let t4;
  $[5] !== collapsed || $[6] !== expand ? (t4 = () => {
    collapsed && expand();
  }, $[5] = collapsed, $[6] = expand, $[7] = t4) : t4 = $[7];
  const handleLayoutClick = t4, showTabsOrSubActions = !!(!collapsed && (tabs || subActions)), t5 = collapsed ? "" : void 0, t6 = collapsed ? "" : void 0;
  let t7;
  $[8] !== backButton ? (t7 = backButton && /* @__PURE__ */ jsx(Box, { flex: "none", children: backButton }), $[8] = backButton, $[9] = t7) : t7 = $[9];
  const t8 = backButton ? 1 : 2;
  let t9;
  $[10] !== loading ? (t9 = loading && /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(TitleTextSkeleton, { animated: !0, radius: 1, size: 1 }) }), $[10] = loading, $[11] = t9) : t9 = $[11];
  let t10;
  $[12] !== appendTitle || $[13] !== loading || $[14] !== title ? (t10 = !loading && /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, children: [
    /* @__PURE__ */ jsx(TitleText, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title }),
    appendTitle
  ] }), $[12] = appendTitle, $[13] = loading, $[14] = title, $[15] = t10) : t10 = $[15];
  let t11;
  $[16] !== handleTitleClick || $[17] !== t10 || $[18] !== t8 || $[19] !== t9 || $[20] !== tabIndex ? (t11 = /* @__PURE__ */ jsxs(TitleCard, { __unstable_focusRing: !0, flex: 1, onClick: handleTitleClick, paddingLeft: t8, padding: 2, tabIndex, children: [
    t9,
    t10
  ] }), $[16] = handleTitleClick, $[17] = t10, $[18] = t8, $[19] = t9, $[20] = tabIndex, $[21] = t11) : t11 = $[21];
  let t12;
  $[22] !== actions || $[23] !== collapsed ? (t12 = actions && /* @__PURE__ */ jsx(Box, { hidden: collapsed, children: /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneHeader", children: actions }) }), $[22] = actions, $[23] = collapsed, $[24] = t12) : t12 = $[24];
  let t13;
  $[25] !== t11 || $[26] !== t12 || $[27] !== t7 ? (t13 = /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 3, children: [
    t7,
    t11,
    t12
  ] }), $[25] = t11, $[26] = t12, $[27] = t7, $[28] = t13) : t13 = $[28];
  let t14;
  $[29] !== collapsed || $[30] !== showTabsOrSubActions || $[31] !== subActions || $[32] !== tabs ? (t14 = showTabsOrSubActions && /* @__PURE__ */ jsxs(Flex, { align: "center", hidden: collapsed, overflow: "auto", children: [
    /* @__PURE__ */ jsx(Box, { flex: 1, marginRight: subActions ? 3 : 0, children: tabs }),
    subActions
  ] }), $[29] = collapsed, $[30] = showTabsOrSubActions, $[31] = subActions, $[32] = tabs, $[33] = t14) : t14 = $[33];
  let t15;
  $[34] !== handleLayoutClick || $[35] !== layoutStyle || $[36] !== t13 || $[37] !== t14 ? (t15 = /* @__PURE__ */ jsxs(Layout, { direction: "column", gap: 3, onClick: handleLayoutClick, padding: 3, sizing: "border", style: layoutStyle, children: [
    t13,
    t14
  ] }), $[34] = handleLayoutClick, $[35] = layoutStyle, $[36] = t13, $[37] = t14, $[38] = t15) : t15 = $[38];
  const t16 = !collapsed && contentAfter;
  let t17;
  $[39] !== t15 || $[40] !== t16 || $[41] !== t6 ? (t17 = /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneHeader", children: /* @__PURE__ */ jsxs(Card, { "data-collapsed": t6, tone: "inherit", children: [
    t15,
    t16
  ] }) }), $[39] = t15, $[40] = t16, $[41] = t6, $[42] = t17) : t17 = $[42];
  let t18;
  return $[43] !== border || $[44] !== ref || $[45] !== t17 || $[46] !== t5 ? (t18 = /* @__PURE__ */ jsx(LayerProvider, { zOffset: 100, children: /* @__PURE__ */ jsx(Root$5, { $border: border, "data-collapsed": t5, "data-testid": "pane-header", ref, children: t17 }) }), $[43] = border, $[44] = ref, $[45] = t17, $[46] = t5, $[47] = t18) : t18 = $[47], t18;
});
function getDisabledReason$1(node) {
  if (!node.disabled)
    return {
      disabledReason: void 0,
      ariaLabel: void 0,
      isDisabled: !1
    };
  const disabledReason = typeof node.disabled == "object" ? node.disabled.reason : void 0, ariaLabel = typeof node.disabled == "object" && typeof node.disabled?.reason == "string" ? node.disabled.reason : "This is disabled";
  return {
    disabledReason,
    ariaLabel,
    isDisabled: !!node.disabled
  };
}
function PaneHeaderActionButton(props) {
  const $ = c(4), {
    node
  } = props;
  if (node.type === "item") {
    let t0;
    return $[0] !== node ? (t0 = /* @__PURE__ */ jsx(PaneHeaderMenuItemActionButton, { node }), $[0] = node, $[1] = t0) : t0 = $[1], t0;
  }
  if (node.type === "group") {
    let t0;
    return $[2] !== node ? (t0 = /* @__PURE__ */ jsx(PaneHeaderMenuGroupActionButton, { node }), $[2] = node, $[3] = t0) : t0 = $[3], t0;
  }
  return console.warn('unknown menu node (expected `type: "item" | "group"`):', node), null;
}
function PaneHeaderMenuItemActionButton(props) {
  const $ = c(23), {
    node
  } = props, {
    title
  } = useI18nText(node), {
    t
  } = useTranslation();
  if (node.intent) {
    let t02;
    return $[0] !== node.intent || $[1] !== props ? (t02 = /* @__PURE__ */ jsx(PaneHeaderActionIntentButton, { ...props, intent: node.intent }), $[0] = node.intent, $[1] = props, $[2] = t02) : t02 = $[2], t02;
  }
  let t0;
  $[3] !== node ? (t0 = getDisabledReason$1(node), $[3] = node, $[4] = t0) : t0 = $[4];
  const {
    disabledReason,
    ariaLabel,
    isDisabled
  } = t0;
  let t1;
  $[5] !== ariaLabel || $[6] !== t || $[7] !== title ? (t1 = ariaLabel || title || t("status-button.aria-label"), $[5] = ariaLabel, $[6] = t, $[7] = title, $[8] = t1) : t1 = $[8];
  let t2;
  $[9] !== isDisabled || $[10] !== node.hotkey ? (t2 = !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0, $[9] = isDisabled, $[10] = node.hotkey, $[11] = t2) : t2 = $[11];
  const t3 = isDisabled ? disabledReason : title;
  let t4;
  $[12] !== t2 || $[13] !== t3 ? (t4 = {
    hotkeys: t2,
    content: t3
  }, $[12] = t2, $[13] = t3, $[14] = t4) : t4 = $[14];
  let t5;
  return $[15] !== isDisabled || $[16] !== node.icon || $[17] !== node.onAction || $[18] !== node.selected || $[19] !== node.tone || $[20] !== t1 || $[21] !== t4 ? (t5 = /* @__PURE__ */ jsx(StatusButton, { disabled: isDisabled, icon: node.icon, onClick: node.onAction, selected: node.selected, tone: node.tone, "aria-label": t1, tooltipProps: t4 }), $[15] = isDisabled, $[16] = node.icon, $[17] = node.onAction, $[18] = node.selected, $[19] = node.tone, $[20] = t1, $[21] = t4, $[22] = t5) : t5 = $[22], t5;
}
function PaneHeaderActionIntentButton(props) {
  const $ = c(27), {
    intent,
    node
  } = props;
  let t0;
  $[0] !== intent.params || $[1] !== intent.type ? (t0 = {
    intent: intent.type,
    params: intent.params
  }, $[0] = intent.params, $[1] = intent.type, $[2] = t0) : t0 = $[2];
  const intentLink = useIntentLink(t0), {
    t
  } = useTranslation();
  let t1;
  $[3] !== intentLink || $[4] !== node ? (t1 = (event) => {
    intentLink.onClick(event), node.onAction();
  }, $[3] = intentLink, $[4] = node, $[5] = t1) : t1 = $[5];
  const handleClick = t1;
  let t2;
  $[6] !== node ? (t2 = getDisabledReason$1(node), $[6] = node, $[7] = t2) : t2 = $[7];
  const {
    disabledReason,
    ariaLabel,
    isDisabled
  } = t2;
  let t3;
  $[8] !== ariaLabel || $[9] !== node.title || $[10] !== t ? (t3 = ariaLabel || node.title || t("status-button.aria-label"), $[8] = ariaLabel, $[9] = node.title, $[10] = t, $[11] = t3) : t3 = $[11];
  let t4;
  $[12] !== isDisabled || $[13] !== node.hotkey ? (t4 = !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0, $[12] = isDisabled, $[13] = node.hotkey, $[14] = t4) : t4 = $[14];
  const t5 = isDisabled ? disabledReason : node.title;
  let t6;
  $[15] !== t4 || $[16] !== t5 ? (t6 = {
    hotkeys: t4,
    content: t5,
    placement: "bottom",
    portal: !0
  }, $[15] = t4, $[16] = t5, $[17] = t6) : t6 = $[17];
  let t7;
  return $[18] !== handleClick || $[19] !== intentLink.href || $[20] !== isDisabled || $[21] !== node.icon || $[22] !== node.selected || $[23] !== node.tone || $[24] !== t3 || $[25] !== t6 ? (t7 = /* @__PURE__ */ jsx(StatusButton, { forwardedAs: "a", disabled: isDisabled, href: intentLink.href, icon: node.icon, onClick: handleClick, selected: node.selected, tone: node.tone, "aria-label": t3, tooltipProps: t6 }), $[18] = handleClick, $[19] = intentLink.href, $[20] = isDisabled, $[21] = node.icon, $[22] = node.selected, $[23] = node.tone, $[24] = t3, $[25] = t6, $[26] = t7) : t7 = $[26], t7;
}
function PaneHeaderMenuGroupActionButton(props) {
  const $ = c(16), {
    node
  } = props, {
    title
  } = useI18nText(node), t0 = !!node.disabled, t1 = node.icon ?? UnknownIcon;
  let t2;
  $[0] !== node.title ? (t2 = {
    content: node.title,
    portal: !0
  }, $[0] = node.title, $[1] = t2) : t2 = $[1];
  let t3;
  $[2] !== t0 || $[3] !== t1 || $[4] !== t2 || $[5] !== title ? (t3 = /* @__PURE__ */ jsx(Button, { disabled: t0, icon: t1, label: title, mode: "bleed", tooltipProps: t2 }), $[2] = t0, $[3] = t1, $[4] = t2, $[5] = title, $[6] = t3) : t3 = $[6];
  const t4 = useId();
  let t5;
  $[7] !== node.children || $[8] !== node.disabled ? (t5 = node.children.map((child, idx) => /* @__PURE__ */ jsx(PaneMenuButtonItem, { disabled: !!node.disabled, isAfterGroup: node.children[idx - 1]?.type === "group", node: child }, child.key)), $[7] = node.children, $[8] = node.disabled, $[9] = t5) : t5 = $[9];
  let t6;
  $[10] !== t5 ? (t6 = /* @__PURE__ */ jsx(Menu, { children: t5 }), $[10] = t5, $[11] = t6) : t6 = $[11];
  let t7;
  return $[12] !== t3 || $[13] !== t4 || $[14] !== t6 ? (t7 = /* @__PURE__ */ jsx(MenuButton, { button: t3, id: t4, menu: t6 }), $[12] = t3, $[13] = t4, $[14] = t6, $[15] = t7) : t7 = $[15], t7;
}
const Root$4 = styled(Card)`
  transition: opacity 200ms;
  position: relative;
  z-index: 1;
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
  opacity: 0;

  &:not([hidden]) {
    display: flex;
  }

  &:not([data-collapsed]) {
    overflow: auto;
  }

  &[data-mounted] {
    opacity: 1;
  }

  &[data-resizing] {
    pointer-events: none;
  }
`;
function _calcPaneResize(cache, left, right, deltaX) {
  const sum = {
    flex: cache.left.flex + cache.right.flex,
    width: cache.left.width + cache.right.width
  }, leftMinWidth = left.minWidth ?? PANE_DEFAULT_MIN_WIDTH, rightMinWidth = right.minWidth ?? PANE_DEFAULT_MIN_WIDTH, leftMaxWidth = Math.min(left.maxWidth || 1 / 0, sum.width - rightMinWidth), rightMaxWidth = Math.min(right.maxWidth || 1 / 0, sum.width - leftMinWidth);
  let minDeltaX = leftMinWidth - cache.left.width;
  const rightMinDeltaX = cache.right.width - rightMaxWidth;
  minDeltaX < rightMinDeltaX && (minDeltaX = rightMinDeltaX);
  let maxDeltaX = cache.right.width - rightMinWidth;
  const leftMaxDeltaX = leftMaxWidth - cache.left.width;
  maxDeltaX > leftMaxDeltaX && (maxDeltaX = leftMaxDeltaX);
  const _deltaX = Math.min(Math.max(deltaX, minDeltaX), maxDeltaX), leftW = cache.left.width + _deltaX, rightW = cache.right.width - _deltaX, leftFlex = leftW / sum.width * sum.flex, rightFlex = rightW / sum.width * sum.flex;
  return {
    leftFlex,
    leftW,
    rightFlex,
    rightW
  };
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  for (; e !== rootElement; ) {
    const parentElement = e.parentElement;
    if (!parentElement) return path;
    const index = Array.from(parentElement.childNodes).indexOf(e);
    if (path.unshift(index), parentElement === rootElement)
      return path;
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  const map2 = /* @__PURE__ */ new WeakMap();
  for (const element of elements)
    map2.set(element, _getDOMPath(rootElement, element));
  const _sortByElementPath = (a, b) => {
    const _a = map2.get(a) || EMPTY_PATH, _b = map2.get(b) || EMPTY_PATH, len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1, bIndex = _b[i] || -1;
      if (aIndex !== bIndex)
        return aIndex - bIndex;
    }
    return 0;
  };
  elements.sort(_sortByElementPath);
}
function createPaneLayoutController() {
  const observers = [], elements = [], optionsMap = /* @__PURE__ */ new WeakMap(), userCollapsedElementSet = /* @__PURE__ */ new Set(), cache = {};
  let rootElement = null, rootWidth = 0, expandedElement = null, resizeDataMap = /* @__PURE__ */ new Map(), resizing = !1;
  function collapse(element) {
    userCollapsedElementSet.add(element), expandedElement === element && (expandedElement = null), _notifyObservers();
  }
  function expand(element) {
    userCollapsedElementSet.delete(element), expandedElement = element, _notifyObservers();
  }
  function mount(element, options) {
    return optionsMap.set(element, {
      ...options,
      original: options
    }), elements.push(element), rootElement && _sortElements(rootElement, elements), expand(element), () => {
      const idx = elements.indexOf(element);
      idx > -1 && elements.splice(idx, 1), optionsMap.delete(element), _notifyObservers();
    };
  }
  function resize(type, leftElement, deltaX) {
    const leftIndex = elements.indexOf(leftElement), leftOptions = optionsMap.get(leftElement);
    if (!leftOptions) return;
    const rightElement = elements[leftIndex + 1], rightOptions = optionsMap.get(rightElement);
    if (rightOptions) {
      if (type === "start" && (resizing = !0, cache.left = {
        element: leftElement,
        flex: leftOptions.flex || 1,
        width: leftElement.offsetWidth
      }, cache.right = {
        element: rightElement,
        flex: rightOptions.flex || 1,
        width: rightElement.offsetWidth
      }, _notifyObservers()), type === "move" && cache.left && cache.right) {
        resizeDataMap = /* @__PURE__ */ new Map();
        const {
          leftW,
          rightW,
          leftFlex,
          rightFlex
        } = _calcPaneResize(cache, leftOptions, rightOptions, deltaX);
        resizeDataMap.set(leftElement, {
          flex: leftFlex,
          width: leftW
        }), resizeDataMap.set(rightElement, {
          flex: rightFlex,
          width: rightW
        }), _notifyObservers();
      }
      if (type === "end") {
        resizing = !1;
        const leftResizeData = resizeDataMap.get(leftElement), rightResizeData = resizeDataMap.get(rightElement);
        optionsMap.set(leftElement, {
          ...leftOptions,
          currentMinWidth: 0,
          currentMaxWidth: leftOptions.maxWidth ?? 1 / 0,
          flex: leftResizeData?.flex ?? leftOptions.flex
        }), optionsMap.set(rightElement, {
          ...rightOptions,
          currentMinWidth: 0,
          currentMaxWidth: leftOptions.maxWidth ?? 1 / 0,
          flex: rightResizeData?.flex ?? rightOptions.flex
        }), resizeDataMap = /* @__PURE__ */ new Map(), delete cache.left, delete cache.right, _notifyObservers();
      }
    }
  }
  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }
  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth, _notifyObservers();
  }
  function subscribe(observer) {
    return observers.push(observer), () => {
      const idx = observers.push(observer);
      idx > -1 && observers.splice(idx, 1);
    };
  }
  return {
    collapse,
    expand,
    mount,
    resize,
    setRootElement,
    setRootWidth,
    subscribe
  };
  function _notifyObservers() {
    if (!rootWidth) return;
    const _elements = [];
    for (const element of elements)
      element !== expandedElement && _elements.unshift(element);
    expandedElement && _elements.unshift(expandedElement);
    const dataMap = /* @__PURE__ */ new WeakMap(), len = _elements.length, lastElement = _elements[0], collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;
    for (const element of _elements) {
      const options = optionsMap.get(element);
      if (!options)
        continue;
      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH, isLast = element === lastElement, userCollapsed = userCollapsedElementSet.has(element), sizeCollapsed = minWidth > remaingWidth, collapsed = isLast ? !1 : userCollapsed || sizeCollapsed, resizeData = resizeDataMap.get(element);
      dataMap.set(element, {
        element,
        collapsed,
        currentMinWidth: resizeData?.width ?? options.currentMinWidth,
        currentMaxWidth: resizeData?.width ?? options.currentMaxWidth,
        flex: resizeData?.flex ?? options.flex ?? 1
      }), collapsed ? remaingWidth -= PANE_COLLAPSED_WIDTH : remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
    }
    const panes = [];
    for (const element of elements) {
      const data = dataMap.get(element);
      data && panes.push(data);
    }
    for (const observer of observers)
      observer({
        expandedElement: expandedElement || elements[elements.length - 1] || null,
        panes,
        resizing
      });
  }
}
function PaneLayout(props) {
  const $ = c(41);
  let children, minWidth, onCollapse, onExpand, restProps;
  $[0] !== props ? ({
    children,
    minWidth,
    onCollapse,
    onExpand,
    ...restProps
  } = props, $[0] = props, $[1] = children, $[2] = minWidth, $[3] = onCollapse, $[4] = onExpand, $[5] = restProps) : (children = $[1], minWidth = $[2], onCollapse = $[3], onExpand = $[4], restProps = $[5]);
  const [controller] = useState(_temp$o), [rootElement, setRootElement] = useState(null), width = useElementRect(rootElement)?.width || 0, collapsed = width === void 0 || !minWidth ? void 0 : width < minWidth;
  let t0;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    expandedElement: null,
    panes: [],
    resizing: !1
  }, $[6] = t0) : t0 = $[6];
  const [state2, setState] = useState(t0);
  let t1, t2;
  $[7] !== controller || $[8] !== rootElement ? (t1 = () => controller.setRootElement(rootElement), t2 = [controller, rootElement], $[7] = controller, $[8] = rootElement, $[9] = t1, $[10] = t2) : (t1 = $[9], t2 = $[10]), useEffect(t1, t2);
  let t3, t4;
  $[11] !== controller || $[12] !== width ? (t3 = () => controller.setRootWidth(width), t4 = [controller, width], $[11] = controller, $[12] = width, $[13] = t3, $[14] = t4) : (t3 = $[13], t4 = $[14]), useEffect(t3, t4);
  let t5, t6;
  $[15] !== controller ? (t5 = () => controller.subscribe(setState), t6 = [controller], $[15] = controller, $[16] = t5, $[17] = t6) : (t5 = $[16], t6 = $[17]), useEffect(t5, t6);
  let t7, t8;
  $[18] !== collapsed || $[19] !== onCollapse || $[20] !== onExpand ? (t7 = () => {
    collapsed !== void 0 && (collapsed && onCollapse && onCollapse(), !collapsed && onExpand && onExpand());
  }, t8 = [collapsed, onCollapse, onExpand], $[18] = collapsed, $[19] = onCollapse, $[20] = onExpand, $[21] = t7, $[22] = t8) : (t7 = $[21], t8 = $[22]), useEffect(t7, t8);
  let t9, t10;
  $[23] !== collapsed || $[24] !== controller.collapse || $[25] !== controller.expand || $[26] !== controller.mount || $[27] !== controller.resize || $[28] !== state2.expandedElement || $[29] !== state2.panes || $[30] !== state2.resizing ? (t10 = {
    collapse: controller.collapse,
    collapsed,
    expand: controller.expand,
    expandedElement: state2.expandedElement,
    mount: controller.mount,
    panes: state2.panes,
    resize: controller.resize,
    resizing: state2.resizing
  }, $[23] = collapsed, $[24] = controller.collapse, $[25] = controller.expand, $[26] = controller.mount, $[27] = controller.resize, $[28] = state2.expandedElement, $[29] = state2.panes, $[30] = state2.resizing, $[31] = t10) : t10 = $[31], t9 = t10;
  const paneLayout = t9, t11 = collapsed ? "" : void 0, t12 = state2.resizing ? "" : void 0, t13 = width ? "" : void 0;
  let t14;
  $[32] !== children || $[33] !== restProps || $[34] !== t11 || $[35] !== t12 || $[36] !== t13 ? (t14 = /* @__PURE__ */ jsx(Root$4, { "data-ui": "PaneLayout", ...restProps, "data-collapsed": t11, "data-resizing": t12, "data-mounted": t13, ref: setRootElement, children }), $[32] = children, $[33] = restProps, $[34] = t11, $[35] = t12, $[36] = t13, $[37] = t14) : t14 = $[37];
  let t15;
  return $[38] !== paneLayout || $[39] !== t14 ? (t15 = /* @__PURE__ */ jsx(PaneLayoutContext.Provider, { value: paneLayout, children: t14 }), $[38] = paneLayout, $[39] = t14, $[40] = t15) : t15 = $[40], t15;
}
function _temp$o() {
  return createPaneLayoutController();
}
function isMenuNodeButton(node) {
  return (node.type === "item" || node.type === "group") && node.renderAsButton;
}
const isNotMenuNodeButton = negate(isMenuNodeButton);
function resolveMenuNodes(params) {
  const {
    fieldActions = [],
    menuItems,
    menuItemGroups
  } = params, nodes = [];
  let keyOffset = 0;
  for (let i = 0; i < fieldActions.length; i += 1) {
    const a = fieldActions[i];
    nodes.push(mapFieldActionToPaneMenuNode(a, `${i}-${a.type}`));
  }
  keyOffset += nodes.length;
  const groups = [];
  for (const itemGroup of menuItemGroups)
    groups.find((g) => g.key === itemGroup.id) || groups.push({
      type: "group",
      key: itemGroup.id,
      children: [],
      expanded: !0,
      renderAsButton: !1,
      title: itemGroup.title,
      i18n: itemGroup.i18n
    });
  const ungroupedItems = [];
  for (let i = 0; i < menuItems.length; i += 1) {
    const item = menuItems[i];
    let group = item.group && groups.find((g) => g.key === item.group);
    const disabled = typeof item.disabled == "string" ? {
      reason: item.disabled
    } : item.disabled;
    item.group && !group && (group = {
      type: "group",
      key: item.group,
      disabled,
      expanded: !0,
      icon: item.icon,
      title: item.group,
      children: [],
      renderAsButton: !1
    }, groups.push(group)), group ? group.children.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      disabled,
      onAction: () => params.actionHandler(item),
      renderAsButton: item.showAsAction ?? !1,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    }) : ungroupedItems.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      disabled,
      onAction: () => params.actionHandler(item),
      renderAsButton: item.showAsAction ?? !1,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    });
  }
  return [...ungroupedItems, ...groups, ...nodes];
}
function mapFieldActionToPaneMenuNode(a, key) {
  return a.type === "divider" ? {
    type: "divider",
    key
  } : a.type === "group" ? {
    type: "group",
    key,
    children: a.children.map((child, childIdx) => mapFieldActionToPaneMenuNode(child, `${key}-${childIdx}-${child.type}`)),
    disabled: a.disabled,
    expanded: a.expanded ?? !0,
    icon: a.icon,
    title: a.title,
    i18n: a.i18n,
    renderAsButton: a.renderAsButton ?? !1
  } : {
    type: "item",
    key,
    intent: a.intent,
    disabled: a.disabled,
    icon: a.icon,
    iconRight: a.iconRight,
    onAction: a.onAction,
    renderAsButton: a.renderAsButton ?? !1,
    selected: a.selected,
    title: a.title,
    i18n: a.i18n,
    tone: a.tone
  };
}
const IntentButton = forwardRef(function(props, ref) {
  const $ = c(10);
  let intent, restProps;
  $[0] !== props ? ({
    intent,
    ...restProps
  } = props, $[0] = props, $[1] = intent, $[2] = restProps) : (intent = $[1], restProps = $[2]);
  let t0, t1;
  $[3] !== intent ? (t1 = forwardRef(function(linkProps, linkRef) {
    return /* @__PURE__ */ jsx(IntentLink, { ...linkProps, intent: intent.type, params: intent.params, ref: linkRef, searchParams: intent.searchParams });
  }), $[3] = intent, $[4] = t1) : t1 = $[4], t0 = t1;
  const Link2 = t0;
  let t2;
  return $[5] !== Link2 || $[6] !== props.disabled || $[7] !== ref || $[8] !== restProps ? (t2 = props.disabled ? /* @__PURE__ */ jsx(Button, { ...restProps, as: "a", role: "link", "aria-disabled": "true" }) : /* @__PURE__ */ jsx(Button, { ...restProps, as: Link2, "data-as": "a", ref }), $[5] = Link2, $[6] = props.disabled, $[7] = ref, $[8] = restProps, $[9] = t2) : t2 = $[9], t2;
});
function InsufficientPermissionsMessageTooltip(t0) {
  const $ = c(12), {
    reveal,
    context,
    loading,
    children
  } = t0, currentUser = useCurrentUser(), {
    t
  } = useTranslation(structureLocaleNamespace);
  if (!reveal) {
    let t12;
    return $[0] !== children ? (t12 = /* @__PURE__ */ jsx(Fragment, { children }), $[0] = children, $[1] = t12) : t12 = $[1], t12;
  }
  let t1;
  $[2] !== context || $[3] !== currentUser || $[4] !== loading || $[5] !== t ? (t1 = loading ? t("insufficient-permissions-message-tooltip.loading-text") : /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context, currentUser }), $[2] = context, $[3] = currentUser, $[4] = loading, $[5] = t, $[6] = t1) : t1 = $[6];
  let t2;
  $[7] !== children ? (t2 = /* @__PURE__ */ jsx("div", { children }), $[7] = children, $[8] = t2) : t2 = $[8];
  let t3;
  return $[9] !== t1 || $[10] !== t2 ? (t3 = /* @__PURE__ */ jsx(Tooltip, { content: t1, portal: !0, children: t2 }), $[9] = t1, $[10] = t2, $[11] = t3) : t3 = $[11], t3;
}
const POPOVER_PROPS = {
  constrainSize: !0,
  placement: "bottom",
  portal: !0
}, getIntent = (templates, item, version) => {
  const typeName = templates.find((t) => t.id === item.templateId)?.schemaType;
  if (!typeName) return null;
  const baseParams = {
    template: item.templateId,
    type: typeName,
    version,
    id: item.initialDocumentId
  };
  return {
    type: "create",
    params: item.parameters ? [baseParams, item.parameters] : baseParams,
    searchParams: version ? [["perspective", version]] : void 0
  };
};
function PaneHeaderCreateButton(t0) {
  const $ = c(60), {
    templateItems
  } = t0, templates = useTemplates(), {
    selectedReleaseId
  } = usePerspective(), {
    t
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== templateItems || $[1] !== templates ? (t1 = [...templateItems, ...templates], $[0] = templateItems, $[1] = templates, $[2] = t1) : t1 = $[2];
  const getI18nText = useGetI18nText(t1);
  let t2;
  $[3] !== templateItems ? (t2 = {
    templateItems
  }, $[3] = templateItems, $[4] = t2) : t2 = $[4];
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions(t2);
  let t3;
  t3 = !isTemplatePermissionsLoading && templatePermissions?.length !== 0 && templatePermissions?.every(_temp$n);
  const nothingGranted = t3;
  let t4;
  bb0: {
    if (!templatePermissions) {
      let t53;
      $[5] === Symbol.for("react.memo_cache_sentinel") ? (t53 = {}, $[5] = t53) : t53 = $[5], t4 = t53;
      break bb0;
    }
    let t52;
    $[6] !== templatePermissions ? (t52 = templatePermissions.reduce(_temp2$8, {}), $[6] = templatePermissions, $[7] = t52) : t52 = $[7], t4 = t52;
  }
  const permissionsById = t4;
  if (templateItems.length === 0)
    return null;
  if (nothingGranted) {
    let t52;
    $[8] !== t ? (t52 = t("pane-header.disabled-created-button.aria-label"), $[8] = t, $[9] = t52) : t52 = $[9];
    let t62;
    $[10] !== t52 ? (t62 = /* @__PURE__ */ jsx(Button, { "aria-label": t52, icon: AddIcon, "data-testid": "action-intent-button", disabled: !0, mode: "bleed", tooltipProps: null }), $[10] = t52, $[11] = t62) : t62 = $[11];
    let t72;
    return $[12] !== isTemplatePermissionsLoading || $[13] !== t62 ? (t72 = /* @__PURE__ */ jsx(InsufficientPermissionsMessageTooltip, { context: "create-document-type", reveal: !0, loading: isTemplatePermissionsLoading, children: t62 }), $[12] = isTemplatePermissionsLoading, $[13] = t62, $[14] = t72) : t72 = $[14], t72;
  }
  if (templateItems.length === 1) {
    const firstItem = templateItems[0], disabled = !permissionsById[firstItem.id]?.granted;
    let t52;
    $[15] !== firstItem || $[16] !== selectedReleaseId || $[17] !== templates ? (t52 = getIntent(templates, firstItem, selectedReleaseId), $[15] = firstItem, $[16] = selectedReleaseId, $[17] = templates, $[18] = t52) : t52 = $[18];
    const intent = t52;
    if (!intent)
      return null;
    let t62;
    $[19] !== firstItem || $[20] !== getI18nText ? (t62 = getI18nText(firstItem), $[19] = firstItem, $[20] = getI18nText, $[21] = t62) : t62 = $[21];
    const t72 = t62.title, t82 = firstItem.icon || AddIcon;
    let t92;
    $[22] !== t ? (t92 = t("pane-header.create-new-button.tooltip"), $[22] = t, $[23] = t92) : t92 = $[23];
    let t10;
    $[24] !== t92 ? (t10 = {
      content: t92
    }, $[24] = t92, $[25] = t10) : t10 = $[25];
    let t11;
    $[26] !== disabled || $[27] !== intent || $[28] !== t10 || $[29] !== t62.title || $[30] !== t82 ? (t11 = /* @__PURE__ */ jsx(IntentButton, { "aria-label": t72, icon: t82, intent, mode: "bleed", disabled, "data-testid": "action-intent-button", tooltipProps: t10 }), $[26] = disabled, $[27] = intent, $[28] = t10, $[29] = t62.title, $[30] = t82, $[31] = t11) : t11 = $[31];
    let t12;
    return $[32] !== disabled || $[33] !== isTemplatePermissionsLoading || $[34] !== t11 ? (t12 = /* @__PURE__ */ jsx(InsufficientPermissionsMessageTooltip, { reveal: disabled, loading: isTemplatePermissionsLoading, context: "create-document-type", children: t11 }), $[32] = disabled, $[33] = isTemplatePermissionsLoading, $[34] = t11, $[35] = t12) : t12 = $[35], t12;
  }
  let t5;
  $[36] !== t ? (t5 = t("pane-header.create-new-button.tooltip"), $[36] = t, $[37] = t5) : t5 = $[37];
  let t6;
  $[38] !== t5 ? (t6 = /* @__PURE__ */ jsx(Button, { icon: AddIcon, mode: "bleed", "data-testid": "multi-action-intent-button", tooltipProps: {
    content: t5
  } }), $[38] = t5, $[39] = t6) : t6 = $[39];
  let t7;
  if ($[40] !== getI18nText || $[41] !== isTemplatePermissionsLoading || $[42] !== permissionsById || $[43] !== selectedReleaseId || $[44] !== t || $[45] !== templateItems || $[46] !== templates) {
    let t82;
    $[48] !== getI18nText || $[49] !== isTemplatePermissionsLoading || $[50] !== permissionsById || $[51] !== selectedReleaseId || $[52] !== t || $[53] !== templates ? (t82 = (item, itemIndex) => {
      const disabled_0 = !permissionsById[item.id]?.granted, intent_0 = getIntent(templates, item, selectedReleaseId), template = templates.find((i) => i.id === item.templateId);
      if (!template || !intent_0)
        return null;
      const Link2 = forwardRef((linkProps, linkRef) => disabled_0 ? /* @__PURE__ */ jsx("button", { type: "button", disabled: !0, ...linkProps, ref: linkRef }) : /* @__PURE__ */ jsx(IntentLink, { ...linkProps, intent: intent_0.type, params: intent_0.params, searchParams: intent_0.searchParams, ref: linkRef }));
      Link2.displayName = "Link";
      const {
        title
      } = getI18nText({
        ...item,
        title: item.title || getI18nText(template).title
      });
      return /* @__PURE__ */ jsx(InsufficientPermissionsMessageTooltip, { context: "create-document-type", reveal: disabled_0, loading: isTemplatePermissionsLoading, children: /* @__PURE__ */ jsx(MenuItem, { as: Link2, "data-as": disabled_0 ? "button" : "a", text: title, "aria-label": disabled_0 ? t("pane-header.disabled-created-button.aria-label") : title, disabled: disabled_0, "data-testid": `action-intent-button-${itemIndex}` }) }, item.id);
    }, $[48] = getI18nText, $[49] = isTemplatePermissionsLoading, $[50] = permissionsById, $[51] = selectedReleaseId, $[52] = t, $[53] = templates, $[54] = t82) : t82 = $[54], t7 = templateItems.map(t82), $[40] = getI18nText, $[41] = isTemplatePermissionsLoading, $[42] = permissionsById, $[43] = selectedReleaseId, $[44] = t, $[45] = templateItems, $[46] = templates, $[47] = t7;
  } else
    t7 = $[47];
  let t8;
  $[55] !== t7 ? (t8 = /* @__PURE__ */ jsx(Menu, { children: t7 }), $[55] = t7, $[56] = t8) : t8 = $[56];
  let t9;
  return $[57] !== t6 || $[58] !== t8 ? (t9 = /* @__PURE__ */ jsx(MenuButton, { button: t6, id: "create-menu", menu: t8, popover: POPOVER_PROPS }), $[57] = t6, $[58] = t8, $[59] = t9) : t9 = $[59], t9;
}
function _temp2$8(acc, permission_0) {
  return acc[permission_0.id] = permission_0, acc;
}
function _temp$n(permission) {
  return !permission.granted;
}
function isNonNullable(value) {
  return value != null;
}
const hashObject = (value) => {
  const sortObject = (v) => typeof v != "object" || !v ? v : Array.isArray(v) ? v.map(sortObject) : Object.entries(v).sort(([keyA], [keyB]) => keyA.localeCompare(keyB, "en"));
  return JSON.stringify(sortObject(((v) => JSON.parse(JSON.stringify(v)))(value)));
}, PaneHeaderActions = memo(function(props) {
  const {
    initialValueTemplateItems: initialValueTemplateItemsFromStructure = EMPTY_ARRAY$2,
    menuItems = EMPTY_ARRAY$2,
    menuItemGroups = EMPTY_ARRAY$2,
    actionHandlers = EMPTY_OBJECT
  } = props, templates = useTemplates(), handleAction = useCallback((item) => {
    if (typeof item.action == "string" && !(item.action in actionHandlers))
      return console.warn("No handler for action:", item.action), !1;
    const handler = (
      // eslint-disable-next-line no-nested-ternary
      typeof item.action == "function" ? item.action : typeof item.action == "string" ? actionHandlers[item.action] : null
    );
    return handler ? (handler(item.params), !0) : !1;
  }, [actionHandlers]), menuNodes = useMemo(() => resolveMenuNodes({
    actionHandler: handleAction,
    menuItemGroups,
    menuItems: menuItems.filter((item_0) => item_0.intent?.type !== "create")
  }), [handleAction, menuItemGroups, menuItems]), actionNodes = useMemo(() => menuNodes.filter(isMenuNodeButton), [menuNodes]), contextMenuNodes = useMemo(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]), initialValueTemplateItemFromMenuItems = useMemo(() => menuItems.map((item_1, menuItemIndex) => {
    if (item_1.intent?.type !== "create") return null;
    const {
      params
    } = item_1.intent;
    if (!params) return null;
    const intentParams = Array.isArray(params) ? params[0] : params, templateParams = Array.isArray(params) ? params[1] : void 0, templateId = intentParams.template || intentParams.type;
    if (!templateId) return null;
    const template = templates.find((t) => t.id === templateId);
    if (!template) return null;
    const initialDocumentId = intentParams.id;
    return {
      item: item_1,
      template,
      templateParams,
      menuItemIndex,
      initialDocumentId
    };
  }).filter(isNonNullable).map(({
    initialDocumentId: initialDocumentId_0,
    item: item_2,
    template: template_0,
    menuItemIndex: menuItemIndex_0,
    templateParams: templateParams_0
  }) => ({
    id: `menuItem${menuItemIndex_0}`,
    initialDocumentId: initialDocumentId_0,
    templateId: template_0.id,
    type: "initialValueTemplateItem",
    title: item_2.title || template_0.title,
    i18n: item_2.i18n || template_0.i18n,
    icon: item_2.icon,
    description: template_0.description,
    parameters: templateParams_0,
    schemaType: template_0.schemaType
  })), [menuItems, templates]), combinedInitialValueTemplates = useMemo(() => uniqBy([...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure], (item_3) => hashObject([item_3.initialDocumentId, item_3.templateId, item_3.parameters])), [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return /* @__PURE__ */ jsxs(Flex, { gap: 1, children: [
    /* @__PURE__ */ jsx(PaneHeaderCreateButton, { templateItems: combinedInitialValueTemplates }),
    actionNodes.map((node) => /* @__PURE__ */ jsx(PaneHeaderActionButton, { node }, node.key)),
    contextMenuNodes.length > 0 && /* @__PURE__ */ jsx(PaneContextMenuButton, { nodes: contextMenuNodes })
  ] });
});
function MissingSchemaType(props) {
  const $ = c(16), {
    t
  } = useTranslation(structureLocaleNamespace), {
    layout,
    value
  } = props;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    Code: "code"
  }, $[0] = t0) : t0 = $[0];
  let t1;
  $[1] !== value._type ? (t1 = {
    documentType: value._type
  }, $[1] = value._type, $[2] = t1) : t1 = $[2];
  let t2;
  $[3] !== t || $[4] !== t1 ? (t2 = /* @__PURE__ */ jsx("em", { children: /* @__PURE__ */ jsx(Translate, { t, i18nKey: "pane-item.missing-schema-type.title", components: t0, values: t1 }) }), $[3] = t, $[4] = t1, $[5] = t2) : t2 = $[5];
  let t3;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t3 = {
    Code: "code"
  }, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== value._id ? (t4 = {
    documentId: value._id
  }, $[7] = value._id, $[8] = t4) : t4 = $[8];
  let t5;
  $[9] !== t || $[10] !== t4 ? (t5 = /* @__PURE__ */ jsx(Translate, { t, i18nKey: "pane-item.missing-schema-type.subtitle", components: t3, values: t4 }), $[9] = t, $[10] = t4, $[11] = t5) : t5 = $[11];
  let t6;
  return $[12] !== layout || $[13] !== t2 || $[14] !== t5 ? (t6 = /* @__PURE__ */ jsx(SanityDefaultPreview, { title: t2, subtitle: t5, media: _temp$m, layout }), $[12] = layout, $[13] = t2, $[14] = t5, $[15] = t6) : t6 = $[15], t6;
}
function _temp$m() {
  return /* @__PURE__ */ jsx(WarningOutlineIcon, {});
}
function getIconWithFallback(icon, schemaType, defaultIcon) {
  return icon === !1 ? !1 : icon || schemaType && schemaType.icon || defaultIcon || !1;
}
function PaneItem(props) {
  const $ = c(42), {
    icon,
    id,
    layout: t0,
    pressed,
    schemaType,
    selected,
    title,
    value,
    margin,
    marginBottom,
    marginTop
  } = props, layout = t0 === void 0 ? "default" : t0, schema = useSchema(), documentPreviewStore = useDocumentPreviewStore(), {
    ChildLink: ChildLink2
  } = usePaneRouter(), documentPresence = useDocumentPresence(id), hasSchemaType = !!(schemaType && schemaType.name && schema.get(schemaType.name)), [clicked, setClicked] = useState(!1);
  let t1;
  bb0: {
    if (value && isSanityDocument$1(value)) {
      if (!schemaType || !hasSchemaType) {
        let t24;
        $[0] !== value ? (t24 = /* @__PURE__ */ jsx(MissingSchemaType, { value }), $[0] = value, $[1] = t24) : t24 = $[1], t1 = t24;
        break bb0;
      }
      let t23;
      $[2] !== icon || $[3] !== schemaType ? (t23 = getIconWithFallback(icon, schemaType, DocumentIcon), $[2] = icon, $[3] = schemaType, $[4] = t23) : t23 = $[4];
      let t33;
      $[5] !== documentPresence || $[6] !== documentPreviewStore || $[7] !== layout || $[8] !== schemaType || $[9] !== t23 || $[10] !== value ? (t33 = /* @__PURE__ */ jsx(PaneItemPreview, { documentPreviewStore, icon: t23, layout, schemaType, value, presence: documentPresence }), $[5] = documentPresence, $[6] = documentPreviewStore, $[7] = layout, $[8] = schemaType, $[9] = t23, $[10] = value, $[11] = t33) : t33 = $[11], t1 = t33;
      break bb0;
    }
    let t22;
    $[12] === Symbol.for("react.memo_cache_sentinel") ? (t22 = {
      opacity: 0.5
    }, $[12] = t22) : t22 = $[12];
    let t32;
    $[13] === Symbol.for("react.memo_cache_sentinel") ? (t32 = /* @__PURE__ */ jsx(Box, { style: t22, children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsx(ChevronRightIcon, {}) }) }), $[13] = t32) : t32 = $[13];
    let t42;
    $[14] !== icon || $[15] !== schemaType ? (t42 = getIconWithFallback(icon, schemaType, FolderIcon), $[14] = icon, $[15] = schemaType, $[16] = t42) : t42 = $[16];
    let t52;
    $[17] !== t42 || $[18] !== title ? (t52 = /* @__PURE__ */ jsx(SanityDefaultPreview, { status: t32, icon: t42, layout: "compact", title }), $[17] = t42, $[18] = title, $[19] = t52) : t52 = $[19], t1 = t52;
  }
  const preview = t1;
  let t2;
  $[20] === Symbol.for("react.memo_cache_sentinel") ? (t2 = (e) => {
    if (e.metaKey) {
      setClicked(!1);
      return;
    }
    setClicked(!0);
  }, $[20] = t2) : t2 = $[20];
  const handleClick = t2;
  let t3;
  $[21] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => setClicked(!1), $[21] = t3) : t3 = $[21];
  let t4;
  $[22] !== selected ? (t4 = [selected], $[22] = selected, $[23] = t4) : t4 = $[23], useEffect(t3, t4);
  const [preloading, setPreload] = useState(!1), timeoutRef = useRef(null);
  let t5;
  $[24] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => {
    timeoutRef.current = setTimeout(() => startTransition(() => setPreload(!0)), 400);
  }, $[24] = t5) : t5 = $[24];
  const handleMouseEnter = t5;
  let t6;
  $[25] === Symbol.for("react.memo_cache_sentinel") ? (t6 = () => {
    timeoutRef.current && clearTimeout(timeoutRef.current), startTransition(() => setPreload(!1));
  }, $[25] = t6) : t6 = $[25];
  const handleMouseLeave = t6, t7 = `pane-item-${title}`, t8 = ChildLink2, t9 = selected || clicked;
  let t10;
  $[26] !== id || $[27] !== preloading || $[28] !== schemaType || $[29] !== value ? (t10 = preloading && schemaType?.name && value && isSanityDocument$1(value) && /* @__PURE__ */ jsx(PreloadDocumentPane, { documentId: id, documentType: schemaType.name }), $[26] = id, $[27] = preloading, $[28] = schemaType, $[29] = value, $[30] = t10) : t10 = $[30];
  let t11;
  return $[31] !== id || $[32] !== margin || $[33] !== marginBottom || $[34] !== marginTop || $[35] !== pressed || $[36] !== preview || $[37] !== t10 || $[38] !== t7 || $[39] !== t8 || $[40] !== t9 ? (t11 = /* @__PURE__ */ jsxs(PreviewCard, { "data-testid": t7, __unstable_focusRing: !0, as: t8, childId: id, "data-as": "a", margin, marginBottom, marginTop, onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, pressed, radius: 2, selected: t9, sizing: "border", tabIndex: -1, tone: "inherit", children: [
    preview,
    t10
  ] }), $[31] = id, $[32] = margin, $[33] = marginBottom, $[34] = marginTop, $[35] = pressed, $[36] = preview, $[37] = t10, $[38] = t7, $[39] = t8, $[40] = t9, $[41] = t11) : t11 = $[41], t11;
}
function PreloadDocumentPane(props) {
  const $ = c(2), {
    documentId,
    documentType
  } = props;
  let t0;
  return $[0] !== documentId ? (t0 = getPublishedId(documentId), $[0] = documentId, $[1] = t0) : t0 = $[1], useEditState(t0, documentType), null;
}
PreloadDocumentPane.displayName = "PreloadDocumentPane";
const RenderActionCollectionState = memo((props) => {
  const $ = c(10), {
    actions,
    children,
    actionProps,
    onActionComplete,
    group
  } = props;
  let t0;
  $[0] !== actionProps.id || $[1] !== actionProps.liveEditSchemaType || $[2] !== children ? (t0 = (t12) => {
    const {
      states
    } = t12;
    return /* @__PURE__ */ jsx(ActionsGuardWrapper, { states, documentId: actionProps.liveEditSchemaType ? getPublishedId(actionProps.id) : getDraftId(actionProps.id), children });
  }, $[0] = actionProps.id, $[1] = actionProps.liveEditSchemaType, $[2] = children, $[3] = t0) : t0 = $[3];
  let t1;
  return $[4] !== actionProps || $[5] !== actions || $[6] !== group || $[7] !== onActionComplete || $[8] !== t0 ? (t1 = /* @__PURE__ */ jsx(GetHookCollectionState, { onReset: onActionComplete, hooks: actions, args: actionProps, group, children: t0 }), $[4] = actionProps, $[5] = actions, $[6] = group, $[7] = onActionComplete, $[8] = t0, $[9] = t1) : t1 = $[9], t1;
});
RenderActionCollectionState.displayName = "Memo(RenderActionCollectionState)";
const SUPPORTED_LINKED_TO_CANVAS_ACTIONS = ["delete", "duplicate", "publish", "unpublish", "unlinkFromCanvas", "editInCanvas", "linkToCanvas", "schedule"], ActionsGuardWrapper = (props) => {
  const $ = c(9), {
    states,
    children,
    documentId
  } = props, {
    t
  } = useTranslation(structureLocaleNamespace), {
    isLinked
  } = useCanvasCompanionDoc(documentId);
  let t0;
  bb0: {
    if (isLinked) {
      let t12;
      if ($[0] !== children || $[1] !== states || $[2] !== t) {
        let t2;
        $[4] !== t ? (t2 = (s) => !s.action || !SUPPORTED_LINKED_TO_CANVAS_ACTIONS.includes(s.action) ? {
          ...s,
          disabled: !0,
          title: t("action.disabled-by-canvas.tooltip")
        } : s, $[4] = t, $[5] = t2) : t2 = $[5], t12 = children({
          states: states.map(t2)
        }), $[0] = children, $[1] = states, $[2] = t, $[3] = t12;
      } else
        t12 = $[3];
      t0 = t12;
      break bb0;
    }
    let t1;
    $[6] !== children || $[7] !== states ? (t1 = children({
      states
    }), $[6] = children, $[7] = states, $[8] = t1) : t1 = $[8], t0 = t1;
  }
  return t0;
}, RenderBadgeCollectionState = memo((props) => {
  const $ = c(4), {
    badges,
    children,
    badgeProps
  } = props;
  let t0;
  return $[0] !== badgeProps || $[1] !== badges || $[2] !== children ? (t0 = /* @__PURE__ */ jsx(GetHookCollectionState, { hooks: badges, args: badgeProps, children }), $[0] = badgeProps, $[1] = badges, $[2] = children, $[3] = t0) : t0 = $[3], t0;
});
RenderBadgeCollectionState.displayName = "Memo(RenderBadgeCollectionState)";
function useCreatePathSyncChannel() {
  const $ = c(1);
  let t0, t1;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = new Subject(), $[0] = t1) : t1 = $[0], t0 = t1, t0;
}
const DIFF_VIEW_SEARCH_PARAMETER = "diffView", DIFF_VIEW_PREVIOUS_DOCUMENT_SEARCH_PARAMETER = "previousDocument", DIFF_VIEW_NEXT_DOCUMENT_SEARCH_PARAMETER = "nextDocument", DIFF_SEARCH_PARAM_DELIMITER = ",";
function useDiffViewRouter() {
  const $ = c(9), {
    navigate,
    state: routerState
  } = useRouter();
  let t0;
  $[0] !== navigate || $[1] !== routerState ? (t0 = (t12) => {
    const {
      mode,
      previousDocument,
      nextDocument
    } = t12, next = {
      ...fromPairs(routerState._searchParams),
      ...mode ? {
        [DIFF_VIEW_SEARCH_PARAMETER]: mode
      } : {},
      ...previousDocument ? {
        [DIFF_VIEW_PREVIOUS_DOCUMENT_SEARCH_PARAMETER]: [previousDocument.type, previousDocument.id].join(DIFF_SEARCH_PARAM_DELIMITER)
      } : {},
      ...nextDocument ? {
        [DIFF_VIEW_NEXT_DOCUMENT_SEARCH_PARAMETER]: [nextDocument.type, nextDocument.id].join(DIFF_SEARCH_PARAM_DELIMITER)
      } : {}
    };
    navigate({
      ...routerState,
      _searchParams: toPairs(next)
    });
  }, $[0] = navigate, $[1] = routerState, $[2] = t0) : t0 = $[2];
  const navigateDiffView = t0;
  let t1;
  $[3] !== navigate || $[4] !== routerState ? (t1 = () => {
    navigate({
      ...routerState,
      _searchParams: (routerState._searchParams ?? []).filter(_temp$l)
    });
  }, $[3] = navigate, $[4] = routerState, $[5] = t1) : t1 = $[5];
  const exitDiffView = t1;
  let t2;
  return $[6] !== exitDiffView || $[7] !== navigateDiffView ? (t2 = {
    navigateDiffView,
    exitDiffView
  }, $[6] = exitDiffView, $[7] = navigateDiffView, $[8] = t2) : t2 = $[8], t2;
}
function _temp$l(t0) {
  const [key] = t0;
  return ![DIFF_VIEW_SEARCH_PARAMETER, DIFF_VIEW_PREVIOUS_DOCUMENT_SEARCH_PARAMETER, DIFF_VIEW_NEXT_DOCUMENT_SEARCH_PARAMETER].includes(key);
}
const diffViewModes = ["version"];
function isDiffViewMode(maybeDiffViewMode) {
  return diffViewModes.includes(maybeDiffViewMode);
}
function useDiffViewState({
  onParamsError
} = {}) {
  const {
    state: routerState
  } = useRouter(), searchParams = new URLSearchParams(routerState._searchParams), previousDocument = searchParams.get(DIFF_VIEW_PREVIOUS_DOCUMENT_SEARCH_PARAMETER), nextDocument = searchParams.get(DIFF_VIEW_NEXT_DOCUMENT_SEARCH_PARAMETER), mode = searchParams.get(DIFF_VIEW_SEARCH_PARAMETER), anyParamSet = [previousDocument, nextDocument, mode].some((param) => param !== null), params = useMemo(() => parseParams({
    previousDocument: previousDocument ?? "",
    nextDocument: nextDocument ?? "",
    mode: mode ?? ""
  }), [mode, nextDocument, previousDocument]);
  return useEffect(() => {
    params.result === "error" && anyParamSet && onParamsError?.(params.errors);
  }, [anyParamSet, onParamsError, params]), params.result === "error" ? {
    isActive: !1
  } : {
    state: "ready",
    isActive: !0,
    ...params.params
  };
}
function parseParams({
  previousDocument,
  nextDocument,
  mode
}) {
  const errors = [], [previousDocumentType, previousDocumentId] = previousDocument.split(DIFF_SEARCH_PARAM_DELIMITER).filter(Boolean), [nextDocumentType, nextDocumentId] = nextDocument.split(DIFF_SEARCH_PARAM_DELIMITER).filter(Boolean);
  return isDiffViewMode(mode) || errors.push(["invalidModeParam", mode]), (typeof previousDocumentType > "u" || typeof previousDocumentId > "u") && errors.push(["invalidPreviousDocumentParam", previousDocument]), (typeof nextDocumentType > "u" || typeof nextDocumentId > "u") && errors.push(["invalidNextDocumentParam", nextDocument]), errors.length !== 0 ? {
    result: "error",
    errors
  } : {
    result: "success",
    params: {
      mode,
      documents: {
        previous: {
          type: previousDocumentType,
          id: previousDocumentId
        },
        next: {
          type: nextDocumentType,
          id: nextDocumentId
        }
      }
    }
  };
}
function useScrollMirror(elements) {
  const $ = c(3);
  let t0, t1;
  $[0] !== elements ? (t0 = () => {
    const existentElements = elements.filter(_temp$k);
    if (existentElements.length === 0)
      return;
    const scrollMirror = new ScrollMirror(existentElements);
    return () => scrollMirror.destroy();
  }, t1 = [elements], $[0] = elements, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), useEffect(t0, t1);
}
function _temp$k(element) {
  return element !== null;
}
const VersionModeHeaderLayout = styled.header`
  display: grid;
  grid-area: header;
  grid-template-columns: 1fr min-content 1fr;
  border-block-end: 1px solid var(--card-border-color);
`, VersionModeHeaderLayoutSection = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
`, VersionModeHeader = ({
  documentId,
  state: state2
}) => {
  const {
    t
  } = useTranslation(structureLocaleNamespace), {
    data: documentVersions
  } = useDocumentVersions({
    documentId
  }), {
    exitDiffView,
    navigateDiffView
  } = useDiffViewRouter(), {
    documents
  } = useDiffViewState(), activeReleases = useActiveReleases(), releasesIds = documentVersions.flatMap((id) => getVersionFromId(id) ?? []), releases = useMemo(() => activeReleases.data.filter((release) => {
    const releaseId = getReleaseIdFromReleaseDocumentId(release._id);
    return typeof releaseId < "u" && releasesIds.includes(releaseId);
  }), [activeReleases.data, releasesIds]), onSelectPreviousRelease = useCallback((selectedDocumentId) => {
    typeof documents?.previous < "u" && navigateDiffView({
      previousDocument: {
        ...documents.previous,
        id: selectedDocumentId
      }
    });
  }, [documents?.previous, navigateDiffView]), onSelectNextRelease = useCallback((selectedDocumentId_0) => {
    typeof documents?.next < "u" && navigateDiffView({
      nextDocument: {
        ...documents.next,
        id: selectedDocumentId_0
      }
    });
  }, [documents?.next, navigateDiffView]);
  return /* @__PURE__ */ jsxs(VersionModeHeaderLayout, { children: [
    /* @__PURE__ */ jsxs(VersionModeHeaderLayoutSection, { children: [
      /* @__PURE__ */ jsx(Box, { padding: 4, children: /* @__PURE__ */ jsx(Text, { as: "h1", size: 1, muted: !0, children: t("compare-versions.title") }) }),
      typeof documents?.previous < "u" && /* @__PURE__ */ jsx(VersionMenu, { releases, onSelectRelease: onSelectPreviousRelease, role: "previous", documentId, state: state2, document: documents.previous })
    ] }),
    /* @__PURE__ */ jsx(Flex, { align: "center", paddingX: 3, children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(TransferIcon, {}) }) }),
    /* @__PURE__ */ jsxs(VersionModeHeaderLayoutSection, { children: [
      typeof documents?.next < "u" && /* @__PURE__ */ jsx(VersionMenu, { releases, onSelectRelease: onSelectNextRelease, role: "next", documentId, state: state2, document: documents.next }),
      /* @__PURE__ */ jsx(Box, { padding: 3, style: {
        justifySelf: "end"
      }, children: /* @__PURE__ */ jsx(Button$1, { icon: CloseIcon, mode: "bleed", onClick: exitDiffView, padding: 2 }) })
    ] })
  ] });
}, VersionMenu = ({
  releases = [],
  onSelectRelease,
  role,
  documentId,
  document: document2
}) => {
  const {
    published,
    draft
  } = useEditState(getPublishedId(document2.id), document2.type), selected = useMemo(() => findRelease(document2.id, releases), [document2.id, releases]), {
    t: tStructure
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation(), {
    document: {
      drafts: {
        enabled: isDraftModelEnabled
      }
    }
  } = useWorkspace();
  return /* @__PURE__ */ jsx(MenuButton, { id: role, button: /* @__PURE__ */ jsx(Button$1, { type: "button", mode: "bleed", padding: 2, paddingRight: 3, radius: "full", selected: !0, ...getMenuButtonProps({
    selected,
    tCore,
    tStructure
  }) }), menu: /* @__PURE__ */ jsxs(Menu, { children: [
    published && /* @__PURE__ */ jsx(VersionMenuItem, { type: "published", onSelect: onSelectRelease, isSelected: selected === "published", documentId }),
    isDraftModelEnabled && draft && /* @__PURE__ */ jsx(VersionMenuItem, { type: "draft", onSelect: onSelectRelease, isSelected: selected === "draft", documentId }),
    releases.map((release) => /* @__PURE__ */ jsx(VersionMenuItem, { release, onSelect: onSelectRelease, isSelected: typeof selected != "string" && selected?._id === release._id, documentId }, release._id))
  ] }) });
}, VersionMenuItem = ({
  type,
  release,
  onSelect,
  isSelected,
  documentId
}) => {
  const {
    t: tCore
  } = useTranslation(), {
    t: tStructure
  } = useTranslation(structureLocaleNamespace), onClick = useCallback(() => {
    if (type === "draft") {
      onSelect(getDraftId(documentId));
      return;
    }
    if (type === "published") {
      onSelect(getPublishedId(documentId));
      return;
    }
    typeof release?._id < "u" && onSelect(getVersionId(documentId, getReleaseIdFromReleaseDocumentId(release._id)));
  }, [type, onSelect, documentId, release?._id]);
  if (type)
    return /* @__PURE__ */ jsx(MenuItem$1, { padding: 1, paddingRight: 3, onClick, pressed: isSelected, children: /* @__PURE__ */ jsxs(Flex, { gap: 1, children: [
      /* @__PURE__ */ jsx(ReleaseAvatar, { padding: 2, tone: type === "published" ? "positive" : "caution" }),
      /* @__PURE__ */ jsx(Box, { paddingY: 2, children: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: tStructure(["compare-versions.status", type].join(".")) }) })
    ] }) });
  const tone_0 = release ? getReleaseTone(release) : "neutral";
  return /* @__PURE__ */ jsx(MenuItem$1, { padding: 1, paddingRight: 3, onClick, pressed: isSelected, children: /* @__PURE__ */ jsxs(Flex, { gap: 1, children: [
    /* @__PURE__ */ jsx(ReleaseAvatar, { padding: 2, tone: tone_0 }),
    /* @__PURE__ */ jsxs(Stack, { flex: 1, paddingY: 2, paddingRight: 2, space: 2, children: [
      /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: release.metadata.title || tCore("release.placeholder-untitled-release") }),
      ["asap", "undecided"].includes(release.metadata.releaseType) && /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: tCore(`release.type.${release.metadata.releaseType}`) }),
      release.metadata.releaseType === "scheduled" && /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: formatRelativeLocalePublishDate(release) })
    ] }),
    /* @__PURE__ */ jsx(Flex, { flex: "none", children: isReleaseScheduledOrScheduling(release) && /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(LockIcon, {}) }) }) })
  ] }) });
};
function getMenuButtonProps({
  selected,
  tCore,
  tStructure
}) {
  if (typeof selected > "u")
    return {
      text: tCore("common.loading"),
      tone: "neutral",
      disabled: !0
    };
  if (isReleaseDocument(selected)) {
    const tone2 = selected ? getReleaseTone(selected) : "neutral";
    return {
      text: selected?.metadata.title || tCore("release.placeholder-untitled-release"),
      icon: /* @__PURE__ */ jsx(ReleaseAvatar, { padding: 1, tone: tone2 }),
      iconRight: selected && isReleaseScheduledOrScheduling(selected) ? /* @__PURE__ */ jsx(LockIcon, {}) : void 0,
      tone: tone2
    };
  }
  const tone = selected === "published" ? "positive" : "caution";
  return {
    text: tStructure(["compare-versions.status", selected].join(".")),
    icon: /* @__PURE__ */ jsx(ReleaseAvatar, { padding: 1, tone }),
    tone
  };
}
function findRelease(documentId, releases) {
  return isPublishedId(documentId) ? "published" : isDraftId(documentId) ? "draft" : releases.find(({
    _id
  }) => getReleaseIdFromReleaseDocumentId(_id) === getVersionFromId(documentId));
}
const DialogLayout = styled.div`
  --offset-block: 40px;
  display: grid;
  height: calc(100vh - var(--offset-block));
  min-height: 0;
  overflow: hidden;
  grid-template-areas:
    'header header'
    'previous-document next-document';
  grid-template-columns: 1fr 1fr;
  grid-template-rows: min-content minmax(0, 1fr);
`;
function pickDocumentLayoutComponent(plugin) {
  return plugin.document?.components?.unstable_layout;
}
function usePathSyncChannel(t0) {
  const $ = c(11), {
    syncChannel,
    id
  } = t0;
  let t1;
  $[0] !== id || $[1] !== syncChannel ? (t1 = (state2) => syncChannel.next({
    ...state2,
    source: id
  }), $[0] = id, $[1] = syncChannel, $[2] = t1) : t1 = $[2];
  const push = t1;
  let t2, t3;
  if ($[3] !== id || $[4] !== syncChannel) {
    let t42;
    $[6] !== id ? (t42 = (t5) => {
      const {
        source
      } = t5;
      return source !== id;
    }, $[6] = id, $[7] = t42) : t42 = $[7], t3 = syncChannel.pipe(distinctUntilChanged$1(_temp$j), filter(t42), map$1(_temp2$7)), $[3] = id, $[4] = syncChannel, $[5] = t3;
  } else
    t3 = $[5];
  t2 = t3;
  const path = t2;
  let t4;
  return $[8] !== path || $[9] !== push ? (t4 = {
    path,
    push
  }, $[8] = path, $[9] = push, $[10] = t4) : t4 = $[10], t4;
}
function _temp2$7(state_0) {
  return state_0.path;
}
function _temp$j(previous, next) {
  return deepEquals(previous.path, next.path);
}
const Scroller$5 = styled.div`
  position: relative;
  height: 100%;
  overflow: auto;
  scroll-behavior: smooth;
  scrollbar-width: var(--scrollbar-width);
  overscroll-behavior: contain;
  will-change: scroll-position;
`, DiffViewPaneLayout = styled(Card)`
  position: relative;
  grid-area: var(--grid-area);
`, Container = styled(Container$1)`
  width: auto;
`, DiffViewPane = forwardRef(function(t0, ref) {
  const $ = c(36), {
    role,
    documentType,
    documentId,
    scrollElement,
    syncChannel,
    compareDocument
  } = t0, containerElement = useRef(null), [portalElement, setPortalElement] = useState(null), [boundaryElement, setBoundaryElement] = useState(null);
  let t1;
  $[0] !== compareDocument || $[1] !== documentId || $[2] !== documentType || $[3] !== role || $[4] !== scrollElement || $[5] !== syncChannel ? (t1 = () => /* @__PURE__ */ jsx(DiffViewDocument, { compareDocument, documentId, documentType, role, scrollElement, syncChannel }), $[0] = compareDocument, $[1] = documentId, $[2] = documentType, $[3] = role, $[4] = scrollElement, $[5] = syncChannel, $[6] = t1) : t1 = $[6];
  const t2 = t1;
  let t3;
  $[7] !== t2 ? (t3 = {
    pick: pickDocumentLayoutComponent,
    defaultComponent: t2
  }, $[7] = t2, $[8] = t3) : t3 = $[8];
  const DocumentLayout2 = useMiddlewareComponents(t3);
  let t4;
  $[9] === Symbol.for("react.memo_cache_sentinel") ? (t4 = {
    isInteractive: !1,
    onOpenReviewChanges: noop,
    onSetFocus: noop,
    isReviewChangesOpen: !1
  }, $[9] = t4) : t4 = $[9];
  const t5 = `${role}-document`;
  let t6;
  $[10] !== t5 ? (t6 = {
    "--grid-area": t5
  }, $[10] = t5, $[11] = t6) : t6 = $[11];
  const t7 = t6, t8 = role === "next", t9 = role !== "next" && "none";
  let t10;
  $[12] !== t9 ? (t10 = {
    "--scrollbar-width": t9
  }, $[12] = t9, $[13] = t10) : t10 = $[13];
  const t11 = t10;
  let t12;
  $[14] !== DocumentLayout2 || $[15] !== documentId || $[16] !== documentType ? (t12 = /* @__PURE__ */ jsx(DialogProvider, { position: "absolute", children: /* @__PURE__ */ jsx(Container, { ref: containerElement, padding: 4, width: 1, children: /* @__PURE__ */ jsx(DocumentLayout2, { documentId, documentType }) }) }), $[14] = DocumentLayout2, $[15] = documentId, $[16] = documentType, $[17] = t12) : t12 = $[17];
  let t13;
  $[18] !== portalElement || $[19] !== t12 ? (t13 = /* @__PURE__ */ jsx(PortalProvider, { element: portalElement, children: t12 }), $[18] = portalElement, $[19] = t12, $[20] = t13) : t13 = $[20];
  let t14;
  $[21] !== ref || $[22] !== t11 || $[23] !== t13 ? (t14 = /* @__PURE__ */ jsx(Scroller$5, { ref, style: t11, children: t13 }), $[21] = ref, $[22] = t11, $[23] = t13, $[24] = t14) : t14 = $[24];
  let t15;
  $[25] === Symbol.for("react.memo_cache_sentinel") ? (t15 = /* @__PURE__ */ jsx("div", { "data-testid": "diffView-document-panel-portal", ref: setPortalElement }), $[25] = t15) : t15 = $[25];
  let t16;
  $[26] !== t14 || $[27] !== t7 || $[28] !== t8 ? (t16 = /* @__PURE__ */ jsxs(DiffViewPaneLayout, { ref: setBoundaryElement, style: t7, borderLeft: t8, children: [
    t14,
    t15
  ] }), $[26] = t14, $[27] = t7, $[28] = t8, $[29] = t16) : t16 = $[29];
  let t17;
  $[30] !== boundaryElement || $[31] !== t16 ? (t17 = /* @__PURE__ */ jsx(BoundaryElementProvider, { element: boundaryElement, children: t16 }), $[30] = boundaryElement, $[31] = t16, $[32] = t17) : t17 = $[32];
  let t18;
  return $[33] !== scrollElement || $[34] !== t17 ? (t18 = /* @__PURE__ */ jsx(ReviewChangesContext.Provider, { value: t4, children: /* @__PURE__ */ jsx(ChangeIndicatorsTracker, { children: /* @__PURE__ */ jsx(VirtualizerScrollInstanceProvider, { scrollElement, containerElement, children: t17 }) }) }), $[33] = scrollElement, $[34] = t17, $[35] = t18) : t18 = $[35], t18;
}), DiffViewDocument = (t0) => {
  const $ = c(56), {
    role,
    documentType,
    documentId,
    syncChannel,
    compareDocument
  } = t0;
  let t1;
  $[0] !== compareDocument ? (t1 = {
    compareDocument
  }, $[0] = compareDocument, $[1] = t1) : t1 = $[1];
  const compareValue = useCompareValue(t1), [patchChannel] = useState(_temp$i);
  let t2;
  $[2] !== documentId ? (t2 = getPublishedId(documentId), $[2] = documentId, $[3] = t2) : t2 = $[3];
  let t3;
  $[4] !== documentId ? (t3 = perspectiveName(documentId), $[4] = documentId, $[5] = t3) : t3 = $[5];
  let t4;
  $[6] !== documentId ? (t4 = getVersionFromId(documentId), $[6] = documentId, $[7] = t4) : t4 = $[7];
  let t5;
  $[8] !== compareValue || $[9] !== documentType || $[10] !== t2 || $[11] !== t3 || $[12] !== t4 ? (t5 = {
    documentId: t2,
    documentType,
    selectedPerspectiveName: t3,
    releaseId: t4,
    comparisonValue: compareValue
  }, $[8] = compareValue, $[9] = documentType, $[10] = t2, $[11] = t3, $[12] = t4, $[13] = t5) : t5 = $[13];
  const t6 = useDocumentForm(t5);
  let collapsedFieldSets, collapsedPaths, documentForm, formState, onBlur, onChange, onFocus, onProgrammaticFocus, onSetActiveFieldGroup, onSetCollapsedFieldSet, onSetCollapsedPath, ready, schemaType, value;
  $[14] !== t6 ? ({
    formState,
    onChange,
    onFocus,
    onBlur,
    onSetActiveFieldGroup,
    onSetCollapsedFieldSet,
    onSetCollapsedPath,
    collapsedFieldSets,
    ready,
    collapsedPaths,
    schemaType,
    value,
    onProgrammaticFocus,
    ...documentForm
  } = t6, $[14] = t6, $[15] = collapsedFieldSets, $[16] = collapsedPaths, $[17] = documentForm, $[18] = formState, $[19] = onBlur, $[20] = onChange, $[21] = onFocus, $[22] = onProgrammaticFocus, $[23] = onSetActiveFieldGroup, $[24] = onSetCollapsedFieldSet, $[25] = onSetCollapsedPath, $[26] = ready, $[27] = schemaType, $[28] = value) : (collapsedFieldSets = $[15], collapsedPaths = $[16], documentForm = $[17], formState = $[18], onBlur = $[19], onChange = $[20], onFocus = $[21], onProgrammaticFocus = $[22], onSetActiveFieldGroup = $[23], onSetCollapsedFieldSet = $[24], onSetCollapsedPath = $[25], ready = $[26], schemaType = $[27], value = $[28]);
  const isLoading = formState === null || !ready;
  let t7;
  $[29] !== role || $[30] !== syncChannel ? (t7 = {
    id: role,
    syncChannel
  }, $[29] = role, $[30] = syncChannel, $[31] = t7) : t7 = $[31];
  const pathSyncChannel = usePathSyncChannel(t7);
  let t8;
  $[32] !== documentForm || $[33] !== pathSyncChannel || $[34] !== role ? (t8 = (path) => {
    documentForm.onPathOpen(path), pathSyncChannel.push({
      source: role,
      path
    });
  }, $[32] = documentForm, $[33] = pathSyncChannel, $[34] = role, $[35] = t8) : t8 = $[35];
  const onPathOpen = t8;
  let t10, t9;
  $[36] !== onProgrammaticFocus || $[37] !== pathSyncChannel.path ? (t9 = () => {
    const subscription = pathSyncChannel.path.subscribe(onProgrammaticFocus);
    return () => subscription.unsubscribe();
  }, t10 = [onProgrammaticFocus, pathSyncChannel.path], $[36] = onProgrammaticFocus, $[37] = pathSyncChannel.path, $[38] = t10, $[39] = t9) : (t10 = $[38], t9 = $[39]), useEffect(t9, t10);
  let t11;
  return $[40] !== collapsedFieldSets || $[41] !== collapsedPaths || $[42] !== formState || $[43] !== isLoading || $[44] !== onBlur || $[45] !== onChange || $[46] !== onFocus || $[47] !== onPathOpen || $[48] !== onSetActiveFieldGroup || $[49] !== onSetCollapsedFieldSet || $[50] !== onSetCollapsedPath || $[51] !== patchChannel || $[52] !== role || $[53] !== schemaType || $[54] !== value ? (t11 = isLoading ? /* @__PURE__ */ jsx(LoadingBlock, { showText: !0 }) : /* @__PURE__ */ jsx(CommentsEnabledContext.Provider, { value: {
    enabled: !1,
    mode: null
  }, children: /* @__PURE__ */ jsx(FormBuilder, { __internal_patchChannel: patchChannel, id: `diffView-pane-${role}`, onChange, onPathFocus: onFocus, onPathOpen, onPathBlur: onBlur, onFieldGroupSelect: onSetActiveFieldGroup, onSetFieldSetCollapsed: onSetCollapsedFieldSet, onSetPathCollapsed: onSetCollapsedPath, collapsedPaths, collapsedFieldSets, focusPath: formState.focusPath, changed: formState.changed, focused: formState.focused, groups: formState.groups, validation: formState.validation, members: formState.members, presence: formState.presence, schemaType, value }) }), $[40] = collapsedFieldSets, $[41] = collapsedPaths, $[42] = formState, $[43] = isLoading, $[44] = onBlur, $[45] = onChange, $[46] = onFocus, $[47] = onPathOpen, $[48] = onSetActiveFieldGroup, $[49] = onSetCollapsedFieldSet, $[50] = onSetCollapsedPath, $[51] = patchChannel, $[52] = role, $[53] = schemaType, $[54] = value, $[55] = t11) : t11 = $[55], t11;
};
function perspectiveName(documentId) {
  if (isVersionId(documentId))
    return getVersionFromId(documentId);
  if (isPublishedId(documentId))
    return "published";
}
function useCompareValue(t0) {
  const $ = c(4), {
    compareDocument
  } = t0;
  let t1;
  $[0] !== compareDocument.id ? (t1 = getPublishedId(compareDocument.id), $[0] = compareDocument.id, $[1] = t1) : t1 = $[1];
  const t2 = compareDocument.type;
  let t3;
  $[2] !== compareDocument.id ? (t3 = getVersionFromId(compareDocument.id), $[2] = compareDocument.id, $[3] = t3) : t3 = $[3];
  const compareDocumentEditState = useEditState(t1, t2, "low", t3);
  let t4;
  bb0: {
    if (isVersionId(compareDocument.id)) {
      t4 = compareDocumentEditState.version ?? void 0;
      break bb0;
    }
    if (isDraftId(compareDocument.id)) {
      t4 = compareDocumentEditState.draft ?? void 0;
      break bb0;
    }
    if (isPublishedId(compareDocument.id)) {
      t4 = compareDocumentEditState.published ?? void 0;
      break bb0;
    }
    t4 = void 0;
  }
  return t4;
}
function _temp$i() {
  return createPatchChannel();
}
const Link = styled.a`
  flex: 1;
  text-decoration: none;
  color: inherit;
`, EditReferenceLinkComponent = (t0) => {
  const $ = c(6), {
    children,
    documentId: _documentId,
    documentType
  } = t0;
  let t1;
  $[0] !== _documentId || $[1] !== documentType ? (t1 = {
    intent: "edit",
    params: {
      id: _documentId,
      type: documentType
    }
  }, $[0] = _documentId, $[1] = documentType, $[2] = t1) : t1 = $[2];
  const {
    href
  } = useIntentLink(t1);
  let t2;
  return $[3] !== children || $[4] !== href ? (t2 = /* @__PURE__ */ jsx(Link, { href, target: "_blank", rel: "noopener noreferrer", children }), $[3] = children, $[4] = href, $[5] = t2) : t2 = $[5], t2;
}, DiffView = (t0) => {
  const $ = c(24), {
    documentId
  } = t0, {
    documents,
    state: state2,
    mode
  } = useDiffViewState(), {
    exitDiffView
  } = useDiffViewRouter(), syncChannel = useCreatePathSyncChannel(), [previousPaneElement, setPreviousPaneElement] = useState(null), [nextPaneElement, setNextPaneElement] = useState(null), referenceInputOptionsContext = useContext(ReferenceInputOptionsContext);
  let t1, t2;
  $[0] !== referenceInputOptionsContext ? (t2 = {
    ...referenceInputOptionsContext,
    disableNew: !0,
    EditReferenceLinkComponent
  }, $[0] = referenceInputOptionsContext, $[1] = t2) : t2 = $[1], t1 = t2;
  const diffViewReferenceInputOptionsContext = t1;
  let t3;
  $[2] !== nextPaneElement || $[3] !== previousPaneElement ? (t3 = [previousPaneElement, nextPaneElement], $[2] = nextPaneElement, $[3] = previousPaneElement, $[4] = t3) : t3 = $[4], useScrollMirror(t3);
  let t4;
  $[5] !== documentId || $[6] !== mode || $[7] !== state2 ? (t4 = mode === "version" && /* @__PURE__ */ jsx(VersionModeHeader, { documentId, state: state2 }), $[5] = documentId, $[6] = mode, $[7] = state2, $[8] = t4) : t4 = $[8];
  let t5;
  $[9] !== documents || $[10] !== nextPaneElement || $[11] !== previousPaneElement || $[12] !== state2 || $[13] !== syncChannel ? (t5 = state2 === "ready" && /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(DiffViewPane, { documentType: documents.previous.type, documentId: documents.previous.id, role: "previous", ref: setPreviousPaneElement, scrollElement: previousPaneElement, syncChannel, compareDocument: documents.previous }),
    /* @__PURE__ */ jsx(DiffViewPane, { documentType: documents.next.type, documentId: documents.next.id, role: "next", ref: setNextPaneElement, scrollElement: nextPaneElement, syncChannel, compareDocument: documents.previous })
  ] }), $[9] = documents, $[10] = nextPaneElement, $[11] = previousPaneElement, $[12] = state2, $[13] = syncChannel, $[14] = t5) : t5 = $[14];
  let t6;
  $[15] !== t4 || $[16] !== t5 ? (t6 = /* @__PURE__ */ jsxs(DialogLayout, { children: [
    t4,
    t5
  ] }), $[15] = t4, $[16] = t5, $[17] = t6) : t6 = $[17];
  let t7;
  $[18] !== exitDiffView || $[19] !== t6 ? (t7 = /* @__PURE__ */ jsx(Dialog, { id: "diffView", width: "auto", onClose: exitDiffView, padding: !1, __unstable_hideCloseButton: !0, children: t6 }), $[18] = exitDiffView, $[19] = t6, $[20] = t7) : t7 = $[20];
  let t8;
  return $[21] !== diffViewReferenceInputOptionsContext || $[22] !== t7 ? (t8 = /* @__PURE__ */ jsx(ReferenceInputOptionsContext.Provider, { value: diffViewReferenceInputOptionsContext, children: t7 }), $[21] = diffViewReferenceInputOptionsContext, $[22] = t7, $[23] = t8) : t8 = $[23], t8;
}, DiffViewDocumentLayout = (t0) => {
  const $ = c(9), {
    children,
    documentId
  } = t0, toast = useToast(), {
    t
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== t || $[1] !== toast ? (t1 = {
    onParamsError: (errors) => {
      toast.push({
        id: "diffViewParamsParsingError",
        status: "error",
        title: t("compare-version.error.invalidParams.title"),
        description: /* @__PURE__ */ jsx("ul", { children: errors.map((t22) => {
          const [error, input] = t22;
          return /* @__PURE__ */ jsx("li", { children: t(`compare-version.error.${error}`, {
            input
          }) }, error);
        }) })
      });
    }
  }, $[0] = t, $[1] = toast, $[2] = t1) : t1 = $[2];
  const {
    isActive
  } = useDiffViewState(t1);
  let t2;
  $[3] !== documentId || $[4] !== isActive ? (t2 = isActive && /* @__PURE__ */ jsx(DiffView, { documentId }), $[3] = documentId, $[4] = isActive, $[5] = t2) : t2 = $[5];
  let t3;
  return $[6] !== children || $[7] !== t2 ? (t3 = /* @__PURE__ */ jsxs(Fragment, { children: [
    children,
    t2
  ] }), $[6] = children, $[7] = t2, $[8] = t3) : t3 = $[8], t3;
};
function ErrorPane(props) {
  const $ = c(12), {
    children,
    currentMinWidth,
    flex,
    minWidth,
    paneKey,
    title: t0,
    tone: t1
  } = props, title = t0 === void 0 ? "Error" : t0, tone = t1 === void 0 ? "critical" : t1;
  let t2;
  $[0] !== title ? (t2 = /* @__PURE__ */ jsx(PaneHeader$1, { title }), $[0] = title, $[1] = t2) : t2 = $[1];
  let t3;
  $[2] !== children ? (t3 = /* @__PURE__ */ jsx(PaneContent, { overflow: "auto", children: /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 5, children }) }), $[2] = children, $[3] = t3) : t3 = $[3];
  let t4;
  return $[4] !== currentMinWidth || $[5] !== flex || $[6] !== minWidth || $[7] !== paneKey || $[8] !== t2 || $[9] !== t3 || $[10] !== tone ? (t4 = /* @__PURE__ */ jsxs(Pane, { currentMinWidth, flex, id: paneKey, minWidth, tone, children: [
    t2,
    t3
  ] }), $[4] = currentMinWidth, $[5] = flex, $[6] = minWidth, $[7] = paneKey, $[8] = t2, $[9] = t3, $[10] = tone, $[11] = t4) : t4 = $[11], t4;
}
function getWaitMessages(path) {
  const thresholds = [{
    ms: 300,
    messageKey: "panes.resolving.default-message"
  }, {
    ms: 5e3,
    messageKey: "panes.resolving.slow-resolve-message"
  }];
  if (isDev) {
    const message = ["Check console for errors?", "Is your observable/promise resolving?", path.length > 0 ? `Structure path: ${path.join(" \u279D ")}` : ""];
    thresholds.push({
      ms: 1e4,
      message: message.join(`
`)
    });
  }
  const src = of(null);
  return merge(...thresholds.map((threshold) => src.pipe(mapTo("messageKey" in threshold ? {
    messageKey: threshold.messageKey
  } : {
    message: threshold.message
  }), delay(threshold.ms))));
}
const DEFAULT_MESSAGE_KEY = "panes.resolving.default-message", Content$2 = styled(Flex)`
  opacity: 0;
  transition: opacity 200ms;

  &[data-mounted] {
    opacity: 1;
  }
`, LoadingPane = memo((props) => {
  const $ = c(28), {
    delay: t0,
    flex,
    message: t1,
    minWidth,
    paneKey,
    path,
    selected,
    title,
    tone
  } = props, delay2 = t0 === void 0 ? 300 : t0, messageProp = t1 === void 0 ? getWaitMessages : t1, {
    t
  } = useTranslation(structureLocaleNamespace);
  let t2;
  bb0: {
    if (typeof messageProp == "function") {
      let t32;
      $[0] !== messageProp || $[1] !== path ? (t32 = messageProp(path ? path.split(";") : []), $[0] = messageProp, $[1] = path, $[2] = t32) : t32 = $[2], t2 = t32;
      break bb0;
    }
    t2 = messageProp;
  }
  const resolvedMessage = t2;
  let t3;
  $[3] !== resolvedMessage || $[4] !== t ? (t3 = () => typeof resolvedMessage == "string" ? resolvedMessage : t(DEFAULT_MESSAGE_KEY), $[3] = resolvedMessage, $[4] = t, $[5] = t3) : t3 = $[5];
  const [currentMessage, setCurrentMessage] = useState(t3);
  let t4, t5;
  $[6] !== resolvedMessage || $[7] !== t ? (t4 = () => {
    if (typeof resolvedMessage != "object" || typeof resolvedMessage.subscribe != "function")
      return;
    const sub = resolvedMessage.subscribe((message) => {
      setCurrentMessage("messageKey" in message ? t(message.messageKey) : message.message);
    });
    return () => sub.unsubscribe();
  }, t5 = [resolvedMessage, t], $[6] = resolvedMessage, $[7] = t, $[8] = t4, $[9] = t5) : (t4 = $[8], t5 = $[9]), useEffect(t4, t5);
  const [contentElement, setContentElement] = useState(null), [mounted, setMounted] = useState(!1);
  let t6, t7;
  $[10] !== contentElement ? (t6 = () => {
    if (contentElement)
      return _raf2(() => setMounted(!0));
  }, t7 = [contentElement], $[10] = contentElement, $[11] = t6, $[12] = t7) : (t6 = $[11], t7 = $[12]), useEffect(t6, t7);
  const t8 = mounted ? "" : void 0, t9 = title || currentMessage;
  let t10;
  $[13] !== t9 ? (t10 = /* @__PURE__ */ jsx(LoadingBlock, { showText: !0, title: t9 }), $[13] = t9, $[14] = t10) : t10 = $[14];
  let t11;
  $[15] !== t10 || $[16] !== t8 ? (t11 = /* @__PURE__ */ jsx(Content$2, { align: "center", "data-mounted": t8, direction: "column", height: "fill", justify: "center", ref: setContentElement, children: t10 }), $[15] = t10, $[16] = t8, $[17] = t11) : t11 = $[17];
  const content = t11;
  let t12;
  $[18] !== content || $[19] !== delay2 ? (t12 = /* @__PURE__ */ jsx(PaneContent, { children: content }), $[18] = content, $[19] = delay2, $[20] = t12) : t12 = $[20];
  let t13;
  return $[21] !== flex || $[22] !== minWidth || $[23] !== paneKey || $[24] !== selected || $[25] !== t12 || $[26] !== tone ? (t13 = /* @__PURE__ */ jsx(Pane, { flex, id: paneKey, minWidth, selected, tone, children: t12 }), $[21] = flex, $[22] = minWidth, $[23] = paneKey, $[24] = selected, $[25] = t12, $[26] = tone, $[27] = t13) : t13 = $[27], t13;
});
LoadingPane.displayName = "Memo(LoadingPane)";
function useDocumentPane() {
  const documentPane = useContext(DocumentPaneContext);
  if (!documentPane)
    throw new Error("DocumentPane: missing context value");
  return documentPane;
}
function CommentsWrapper(props) {
  const $ = c(8), {
    children,
    documentId,
    documentType
  } = props;
  let t0;
  $[0] !== children || $[1] !== documentId || $[2] !== documentType ? (t0 = /* @__PURE__ */ jsx(CommentsProviderWrapper, { documentId, documentType, children }), $[0] = children, $[1] = documentId, $[2] = documentType, $[3] = t0) : t0 = $[3];
  let t1;
  return $[4] !== documentId || $[5] !== documentType || $[6] !== t0 ? (t1 = /* @__PURE__ */ jsx(CommentsEnabledProvider, { documentId, documentType, children: t0 }), $[4] = documentId, $[5] = documentType, $[6] = t0, $[7] = t1) : t1 = $[7], t1;
}
function CommentsProviderWrapper(props) {
  const $ = c(25), {
    children,
    documentId,
    documentType
  } = props, {
    enabled
  } = useCommentsEnabled(), {
    connectionState,
    onPathOpen,
    inspector,
    openInspector
  } = useDocumentPane(), {
    selectedReleaseId
  } = usePerspective(), {
    params,
    setParams,
    createPathWithParams
  } = usePaneRouter(), {
    studioUrl
  } = useStudioUrl(window.location.origin), selectedCommentId = params?.comment, paramsRef = useRef(params);
  let t0, t1;
  $[0] !== params ? (t0 = () => {
    paramsRef.current = params;
  }, t1 = [params], $[0] = params, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), useLayoutEffect(t0, t1);
  let t2;
  $[3] !== createPathWithParams || $[4] !== studioUrl ? (t2 = (commentId) => {
    const path = createPathWithParams({
      ...paramsRef.current,
      comment: commentId,
      inspect: COMMENTS_INSPECTOR_NAME
    });
    return `${studioUrl}${path}`;
  }, $[3] = createPathWithParams, $[4] = studioUrl, $[5] = t2) : t2 = $[5];
  const getCommentLink = t2;
  let t3;
  $[6] !== setParams ? (t3 = () => {
    setParams({
      ...paramsRef.current,
      comment: void 0
    });
  }, $[6] = setParams, $[7] = t3) : t3 = $[7];
  const handleClearSelectedComment = t3;
  let t4;
  $[8] !== inspector?.name || $[9] !== openInspector ? (t4 = () => {
    inspector?.name !== COMMENTS_INSPECTOR_NAME && openInspector(COMMENTS_INSPECTOR_NAME);
  }, $[8] = inspector?.name, $[9] = openInspector, $[10] = t4) : t4 = $[10];
  const handleOpenCommentsInspector = t4;
  if (!enabled) {
    let t52;
    return $[11] !== children ? (t52 = /* @__PURE__ */ jsx(Fragment, { children }), $[11] = children, $[12] = t52) : t52 = $[12], t52;
  }
  const t5 = inspector?.name === COMMENTS_INSPECTOR_NAME, t6 = connectionState === "connecting";
  let t7;
  return $[13] !== children || $[14] !== documentId || $[15] !== documentType || $[16] !== getCommentLink || $[17] !== handleClearSelectedComment || $[18] !== handleOpenCommentsInspector || $[19] !== onPathOpen || $[20] !== selectedCommentId || $[21] !== selectedReleaseId || $[22] !== t5 || $[23] !== t6 ? (t7 = /* @__PURE__ */ jsx(CommentsProvider, { documentId, documentType, getCommentLink, isCommentsOpen: t5, isConnecting: t6, onClearSelectedComment: handleClearSelectedComment, onCommentsOpen: handleOpenCommentsInspector, onPathOpen, selectedCommentId, sortOrder: "desc", type: "field", releaseId: selectedReleaseId, children }), $[13] = children, $[14] = documentId, $[15] = documentType, $[16] = getCommentLink, $[17] = handleClearSelectedComment, $[18] = handleOpenCommentsInspector, $[19] = onPathOpen, $[20] = selectedCommentId, $[21] = selectedReleaseId, $[22] = t5, $[23] = t6, $[24] = t7) : t7 = $[24], t7;
}
function useFilteredReleases({
  displayed,
  documentId
}) {
  const {
    selectedReleaseId
  } = usePerspective(), {
    data: releases
  } = useActiveReleases(), {
    data: archivedReleases
  } = useArchivedReleases(), {
    data: documentVersions
  } = useDocumentVersions({
    documentId
  }), isCreatingDocument = displayed && !displayed._createdAt, {
    params
  } = usePaneRouter();
  return useMemo(() => {
    if (!documentVersions) return {
      notCurrentReleases: [],
      currentReleases: [],
      inCreation: null
    };
    const releasesIds = documentVersions.map((id) => getVersionFromId(id)), activeReleases = releases.reduce((acc, release) => {
      const versionDocExists = releasesIds.includes(getReleaseIdFromReleaseDocumentId(release._id)), releaseId = getReleaseIdFromReleaseDocumentId(release._id);
      return isCreatingDocument && releaseId === getVersionFromId(displayed._id || "") && releaseId === selectedReleaseId ? acc.inCreation = release : versionDocExists ? acc.currentReleases.push(release) : acc.notCurrentReleases.push(release), acc;
    }, {
      notCurrentReleases: [],
      currentReleases: [],
      inCreation: null
    });
    if (!params?.historyVersion) return activeReleases;
    const archivedRelease = archivedReleases.find((r) => getReleaseIdFromReleaseDocumentId(r._id) === params?.historyVersion);
    return archivedRelease?.state === "archived" && activeReleases.currentReleases.push(archivedRelease), activeReleases;
  }, [archivedReleases, isCreatingDocument, displayed?._id, documentVersions, params?.historyVersion, releases, selectedReleaseId]);
}
function useDocumentIdStack({
  displayed,
  documentId,
  editState
}) {
  const {
    document: {
      drafts: {
        enabled: isDraftModelEnabled
      }
    }
  } = useWorkspace(), filteredReleases = useFilteredReleases({
    displayed,
    documentId
  }), systemStack = [editState?.published?._id, isDraftModelEnabled ? editState?.draft?._id : []].flat(), releaseStack = filteredReleases.currentReleases.map((release) => editState?.id && getVersionId(editState.id, getReleaseIdFromReleaseDocumentId(release._id))), stack = systemStack.concat(releaseStack).filter((id) => typeof id == "string"), position = useMemo(() => stack.findIndex((id_0) => id_0 === displayed?._id), [displayed?._id, stack]), previousId = useMemo(() => stack[position - 1] ?? void 0, [position, stack]), nextId = useMemo(() => stack[position + 1] ?? void 0, [position, stack]);
  return {
    position,
    previousId,
    nextId,
    stack
  };
}
function useStructureTool() {
  const structureTool2 = useContext(StructureToolContext);
  if (!structureTool2)
    throw new Error("StructureTool: missing context value");
  return structureTool2;
}
const DOCUMENT_PANEL_MIN_WIDTH = 320, DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600, DOCUMENT_INSPECTOR_MIN_WIDTH = 320, DOCUMENT_INSPECTOR_MAX_WIDTH = 540, EMPTY_PARAMS$2 = {}, INSPECT_ACTION_PREFIX = "inspect:", DEFAULT_MENU_ITEM_GROUPS = [{
  id: "inspectors"
}, {
  id: "links"
}], HISTORY_INSPECTOR_NAME = "sanity/structure/history", VALIDATION_INSPECTOR_NAME = "sanity/structure/validation";
function DocumentInspectorMenuItemsResolver(props) {
  const {
    documentId,
    documentType,
    inspectors: inspectors2,
    onMenuItems
  } = props, len = inspectors2.length, [menuItems, setMenuItems] = useState(() => Array.from(new Array(len)));
  useEffect(() => {
    if (menuItems.length !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++)
        newFieldActions[i] = menuItems[i];
      setMenuItems(newFieldActions);
    }
  }, [len, menuItems]);
  const setMenuItem = useCallback((index, node) => {
    setMenuItems((prev) => {
      const next = [...prev];
      return next[index] = node, next;
    });
  }, []);
  useEffect(() => {
    onMenuItems(menuItems.filter(Boolean));
  }, [menuItems, onMenuItems]);
  const InspectorMenuItems = useMemo(() => inspectors2.map((inspector, index_0) => inspector.useMenuItem ? [defineInspectorMenuItemComponent({
    documentId,
    documentType,
    index: index_0,
    setMenuItem,
    useMenuItem: inspector.useMenuItem
  }), inspector.name] : [() => null, ""]), [documentId, documentType, inspectors2, setMenuItem]);
  return /* @__PURE__ */ jsx(Fragment, { children: InspectorMenuItems.map(([InspectorMenuItem, key]) => key && /* @__PURE__ */ jsx(InspectorMenuItem, {}, key)) });
}
DocumentInspectorMenuItemsResolver.displayName = "DocumentInspectorMenuItemsResolver";
function defineInspectorMenuItemComponent({
  documentId,
  documentType,
  index,
  setMenuItem,
  useMenuItem: useMenuItem2
}) {
  return memo(function() {
    const $ = c(4);
    let t0;
    $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
      documentId,
      documentType
    }, $[0] = t0) : t0 = $[0];
    const menuItem = useMenuItem2(t0), node = useUnique(menuItem);
    let t1, t2;
    return $[1] !== node ? (t1 = () => {
      setMenuItem(index, node);
    }, t2 = [node], $[1] = node, $[2] = t1, $[3] = t2) : (t1 = $[2], t2 = $[3]), useEffect(t1, t2), null;
  });
}
function useDocumentTitle() {
  const $ = c(19), {
    connectionState,
    schemaType,
    title,
    displayed
  } = useDocumentPane(), {
    t
  } = useTranslation(structureLocaleNamespace), subscribed = !!displayed;
  let t0;
  $[0] !== displayed || $[1] !== schemaType || $[2] !== subscribed ? (t0 = {
    enabled: subscribed,
    schemaType,
    value: displayed
  }, $[0] = displayed, $[1] = schemaType, $[2] = subscribed, $[3] = t0) : t0 = $[3];
  const {
    error,
    value
  } = unstable_useValuePreview(t0);
  if (connectionState === "connecting" && !subscribed) {
    let t12;
    return $[4] === Symbol.for("react.memo_cache_sentinel") ? (t12 = {
      error: void 0,
      title: void 0
    }, $[4] = t12) : t12 = $[4], t12;
  }
  if (title) {
    let t12;
    return $[5] !== title ? (t12 = {
      error: void 0,
      title
    }, $[5] = title, $[6] = t12) : t12 = $[6], t12;
  }
  if (!displayed) {
    const t12 = schemaType?.title || schemaType?.name;
    let t22;
    $[7] !== t || $[8] !== t12 ? (t22 = t("panes.document-header-title.new.text", {
      schemaType: t12
    }), $[7] = t, $[8] = t12, $[9] = t22) : t22 = $[9];
    let t3;
    return $[10] !== t22 ? (t3 = {
      error: void 0,
      title: t22
    }, $[10] = t22, $[11] = t3) : t3 = $[11], t3;
  }
  if (error) {
    let t12;
    $[12] !== error.message || $[13] !== t ? (t12 = t("panes.document-list-pane.error.text", {
      error: error.message
    }), $[12] = error.message, $[13] = t, $[14] = t12) : t12 = $[14];
    let t22;
    return $[15] !== t12 ? (t22 = {
      error: t12,
      title: void 0
    }, $[15] = t12, $[16] = t22) : t22 = $[16], t22;
  }
  const t1 = value?.title;
  let t2;
  return $[17] !== t1 ? (t2 = {
    error: void 0,
    title: t1
  }, $[17] = t1, $[18] = t2) : t2 = $[18], t2;
}
const IGNORE_OPS = ["patch", "commit"], DocumentOperationResults = memo(function() {
  const $ = c(12), {
    push: pushToast
  } = useToast(), {
    documentId,
    documentType,
    value: documentPaneValue
  } = useDocumentPane(), documentTitleInfo = useDocumentTitle(), titleError = documentTitleInfo.error, event = useDocumentOperationEvent(documentId, documentType), prevEvent = useRef(event), paneRouter = usePaneRouter(), {
    t
  } = useTranslation(structureLocaleNamespace);
  let t0;
  bb0: {
    if (!documentTitleInfo.title && !titleError && !IGNORE_OPS.includes(event?.op) && typeof documentPaneValue.title == "string" && event?.type === "success") {
      t0 = documentPaneValue.title;
      break bb0;
    }
    t0 = documentTitleInfo.title;
  }
  const title = t0;
  let t1;
  $[0] !== t || $[1] !== title ? (t1 = title || t("panes.document-operation-results.operation-undefined-title"), $[0] = t, $[1] = title, $[2] = t1) : t1 = $[2];
  const documentTitleBase = t1;
  let t2;
  $[3] !== documentTitleBase ? (t2 = documentTitleBase.length > 25 ? `${documentTitleBase.slice(0, 25)}...` : documentTitleBase, $[3] = documentTitleBase, $[4] = t2) : t2 = $[4];
  const documentTitle = t2;
  let t3, t4;
  return $[5] !== documentTitle || $[6] !== event || $[7] !== paneRouter || $[8] !== pushToast || $[9] !== t ? (t3 = () => {
    if (!event || event === prevEvent.current)
      return;
    let cleanupId;
    return event.type === "error" && pushToast({
      closable: !0,
      duration: 3e4,
      status: "error",
      title: t("panes.document-operation-results.operation-error", {
        context: event.op
      }),
      description: /* @__PURE__ */ jsxs("details", { children: [
        /* @__PURE__ */ jsx("summary", { children: t("panes.document-operation-results.error.summary.title") }),
        event.error.message
      ] })
    }), event.type === "success" && !IGNORE_OPS.includes(event.op) && pushToast({
      closable: !0,
      status: "success",
      title: /* @__PURE__ */ jsx(Translate, { context: event.op, i18nKey: "panes.document-operation-results.operation-success", t, values: {
        op: event.op,
        title: documentTitle
      }, components: {
        Strong: "strong"
      } })
    }), event.type === "success" && event.op === "delete" && (cleanupId = setTimeout(() => paneRouter.closeCurrentAndAfter(), 0)), prevEvent.current = event, () => clearTimeout(cleanupId);
  }, t4 = [event, paneRouter, pushToast, t, documentTitle], $[5] = documentTitle, $[6] = event, $[7] = paneRouter, $[8] = pushToast, $[9] = t, $[10] = t3, $[11] = t4) : (t3 = $[10], t4 = $[11]), useEffect(t3, t4), null;
}), isLiveEditEnabled = (schemaType) => schemaType.liveEdit === !0;
function hasObsoleteDraft({
  editState,
  workspace,
  schemaType
}) {
  if (!editState?.ready)
    return {
      result: void 0
    };
  const draftExists = editState.draft !== null, {
    document: {
      drafts: {
        enabled: isDraftModelEnabled
      }
    }
  } = workspace;
  return draftExists === !1 ? {
    result: !1
  } : isDraftModelEnabled ? isLiveEditEnabled(schemaType) ? {
    result: !0,
    reason: "LIVE_EDIT_ACTIVE"
  } : {
    result: !1
  } : {
    result: !0,
    reason: "DRAFT_MODEL_INACTIVE"
  };
}
function mustChooseNewDocumentDestination({
  isSelectedPerspectiveWriteable,
  editState
}) {
  return isNewDocument(editState) && !isSelectedPerspectiveWriteable.result;
}
const Root$3 = styled(Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0
});
function DocumentInspectorHeader(props) {
  const $ = c(25);
  let children, closeButtonLabel, forwardedAs, onClose, restProps, title;
  $[0] !== props ? ({
    as: forwardedAs,
    children,
    closeButtonLabel,
    onClose,
    title,
    ...restProps
  } = props, $[0] = props, $[1] = children, $[2] = closeButtonLabel, $[3] = forwardedAs, $[4] = onClose, $[5] = restProps, $[6] = title) : (children = $[1], closeButtonLabel = $[2], forwardedAs = $[3], onClose = $[4], restProps = $[5], title = $[6]);
  const {
    t
  } = useTranslation(structureLocaleNamespace);
  let t0;
  $[7] !== title ? (t0 = /* @__PURE__ */ jsx(Box, { flex: 1, padding: 3, children: /* @__PURE__ */ jsx(Text, { as: "h1", size: 1, weight: "medium", children: title }) }), $[7] = title, $[8] = t0) : t0 = $[8];
  let t1;
  $[9] !== t ? (t1 = t("document-inspector.close-button.tooltip"), $[9] = t, $[10] = t1) : t1 = $[10];
  let t2;
  $[11] !== t1 ? (t2 = {
    content: t1
  }, $[11] = t1, $[12] = t2) : t2 = $[12];
  let t3;
  $[13] !== closeButtonLabel || $[14] !== onClose || $[15] !== t2 ? (t3 = /* @__PURE__ */ jsx(Box, { flex: "none", padding: 1, children: /* @__PURE__ */ jsx(Button, { "aria-label": closeButtonLabel, icon: CloseIcon, mode: "bleed", onClick: onClose, tooltipProps: t2 }) }), $[13] = closeButtonLabel, $[14] = onClose, $[15] = t2, $[16] = t3) : t3 = $[16];
  let t4;
  $[17] !== t0 || $[18] !== t3 ? (t4 = /* @__PURE__ */ jsxs(Flex, { padding: 2, children: [
    t0,
    t3
  ] }), $[17] = t0, $[18] = t3, $[19] = t4) : t4 = $[19];
  let t5;
  return $[20] !== children || $[21] !== forwardedAs || $[22] !== restProps || $[23] !== t4 ? (t5 = /* @__PURE__ */ jsxs(Root$3, { ...restProps, as: forwardedAs, children: [
    t4,
    children
  ] }), $[20] = children, $[21] = forwardedAs, $[22] = restProps, $[23] = t4, $[24] = t5) : t5 = $[24], t5;
}
function DocumentInspectorPanel(props) {
  const $ = c(14), {
    documentId,
    documentType,
    flex
  } = props, {
    collapsed
  } = usePane(), {
    closeInspector,
    inspector
  } = useDocumentPane(), {
    features
  } = useStructureTool();
  let t0;
  $[0] !== closeInspector || $[1] !== inspector ? (t0 = () => {
    inspector && closeInspector(inspector.name);
  }, $[0] = closeInspector, $[1] = inspector, $[2] = t0) : t0 = $[2];
  const handleClose = t0;
  if (collapsed || !inspector)
    return null;
  const Component = inspector.component;
  let t1;
  $[3] !== Component || $[4] !== documentId || $[5] !== documentType || $[6] !== handleClose ? (t1 = /* @__PURE__ */ jsx(Component, { onClose: handleClose, documentId, documentType }), $[3] = Component, $[4] = documentId, $[5] = documentType, $[6] = handleClose, $[7] = t1) : t1 = $[7];
  const element = t1;
  if (features.resizablePanes) {
    let t22;
    return $[8] !== element || $[9] !== flex ? (t22 = /* @__PURE__ */ jsx(Resizable, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, resizerPosition: "left", maxWidth: DOCUMENT_INSPECTOR_MAX_WIDTH, minWidth: DOCUMENT_INSPECTOR_MIN_WIDTH, children: element }), $[8] = element, $[9] = flex, $[10] = t22) : t22 = $[10], t22;
  }
  let t2;
  return $[11] !== element || $[12] !== flex ? (t2 = /* @__PURE__ */ jsx(Box, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, children: element }), $[11] = element, $[12] = flex, $[13] = t2) : t2 = $[13], t2;
}
const STRUCTURE_TOOL_NAMESPACE = "studio.structure-tool";
function useStructureToolSetting(namespace, key, defaultValue) {
  const $ = c(16), keyValueStore = useKeyValueStore();
  let t0;
  $[0] !== key || $[1] !== namespace ? (t0 = [STRUCTURE_TOOL_NAMESPACE, namespace, key].filter(Boolean), $[0] = key, $[1] = namespace, $[2] = t0) : t0 = $[2];
  const keyValueStoreKey = t0.join(".");
  let t1, t2;
  if ($[3] !== defaultValue || $[4] !== keyValueStore || $[5] !== keyValueStoreKey) {
    let t32;
    $[7] !== defaultValue ? (t32 = (value) => value === null ? defaultValue : value, $[7] = defaultValue, $[8] = t32) : t32 = $[8], t2 = keyValueStore.getKey(keyValueStoreKey).pipe(map(t32)), $[3] = defaultValue, $[4] = keyValueStore, $[5] = keyValueStoreKey, $[6] = t2;
  } else
    t2 = $[6];
  t1 = t2;
  const value_0 = useObservable(t1, defaultValue);
  let t3;
  $[9] !== keyValueStore || $[10] !== keyValueStoreKey || $[11] !== value_0 ? (t3 = (newValue) => {
    newValue !== value_0 && keyValueStore.setKey(keyValueStoreKey, newValue);
  }, $[9] = keyValueStore, $[10] = keyValueStoreKey, $[11] = value_0, $[12] = t3) : t3 = $[12];
  const set = t3;
  let t4, t5;
  return $[13] !== set || $[14] !== value_0 ? (t5 = [value_0, set], $[13] = set, $[14] = value_0, $[15] = t5) : t5 = $[15], t4 = t5, t4;
}
const VIEW_MODE_PARSED = {
  id: "parsed",
  title: "document-inspector.view-mode.parsed"
}, VIEW_MODE_RAW = {
  id: "raw",
  title: "document-inspector.view-mode.raw-json"
}, VIEW_MODES = [VIEW_MODE_PARSED, VIEW_MODE_RAW], lru = new QuickLRU({
  maxSize: 1e3
});
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  return cached === void 0 ? (lru.set(keyPath, Array.isArray(value) || isRecord(value)), isExpanded(keyPath, value)) : cached;
}
function toggleExpanded(event) {
  const {
    path
  } = event, current = lru.get(path);
  current !== void 0 && lru.set(path, !current);
}
function selectElement(element) {
  const sel = window.getSelection();
  if (sel) {
    const range = document.createRange();
    sel.removeAllRanges(), range.selectNodeContents(element), sel.addRange(range);
  }
}
function select(event) {
  selectElement(event.currentTarget);
}
function maybeSelectAll(event) {
  event.keyCode === 65 && (event.metaKey || event.ctrlKey) && (event.preventDefault(), selectElement(event.currentTarget));
}
function isDocumentLike(value) {
  return isRecord(value) && isString(value._id) && isString(value._type);
}
const JSONInspectorWrapper = styled.div(({
  theme
}) => {
  const {
    color,
    fonts,
    space
  } = theme.sanity;
  return css`
    & .json-inspector,
    & .json-inspector .json-inspector__selection {
      font-family: ${fonts.code.family};
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
      color: var(--card-code-fg-color);
    }

    & .json-inspector .json-inspector__leaf {
      padding-left: ${rem(space[4])};
    }

    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {
      padding-top: ${rem(space[3])};
      padding-left: 0;
    }

    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {
      display: none;
    }

    & .json-inspector .json-inspector__line {
      display: block;
      position: relative;
      cursor: default;
    }

    & .json-inspector .json-inspector__line::after {
      content: '';
      position: absolute;
      top: 0;
      left: -200px;
      right: -50px;
      bottom: 0;
      z-index: -1;
      pointer-events: none;
    }

    & .json-inspector .json-inspector__line:hover::after {
      background: var(--card-code-bg-color);
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {
      cursor: pointer;
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {
      content: '▸ ';
      margin-left: calc(0 - ${rem(space[4])} + 3px);
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    &
      .json-inspector
      .json-inspector__leaf_expanded.json-inspector__leaf_composite
      > .json-inspector__line::before {
      content: '▾ ';
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    & .json-inspector .json-inspector__radio,
    & .json-inspector .json-inspector__flatpath {
      display: none;
    }

    & .json-inspector .json-inspector__value {
      margin-left: ${rem(space[4] / 2)};
    }

    &
      .json-inspector
      > .json-inspector__leaf_root
      > .json-inspector__line
      > .json-inspector__key
      + .json-inspector__value {
      margin: 0;
    }

    & .json-inspector .json-inspector__key {
      color: ${color.syntax.property};
    }

    & .json-inspector .json-inspector__value_helper,
    & .json-inspector .json-inspector__value_null {
      color: ${color.syntax.constant};
    }

    & .json-inspector .json-inspector__not-found {
      padding-top: ${rem(space[3])};
    }

    & .json-inspector .json-inspector__value_string {
      color: ${color.syntax.string};
    }

    & .json-inspector .json-inspector__value_boolean {
      color: ${color.syntax.boolean};
    }

    & .json-inspector .json-inspector__value_number {
      color: ${color.syntax.number};
    }

    & .json-inspector .json-inspector__show-original {
      display: inline-block;
      padding: 0 6px;
      cursor: pointer;
    }

    & .json-inspector .json-inspector__show-original:hover {
      color: inherit;
    }

    & .json-inspector .json-inspector__show-original::before {
      content: '↔';
    }

    & .json-inspector .json-inspector__show-original:hover::after {
      content: ' expand';
    }
  `;
});
function Search(props) {
  const $ = c(8), {
    onChange,
    query
  } = props;
  let t0;
  $[0] !== onChange ? (t0 = (event) => onChange(event.target.value), $[0] = onChange, $[1] = t0) : t0 = $[1];
  const handleChange = t0, {
    t
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[2] !== t ? (t1 = t("document-inspector.search.placeholder"), $[2] = t, $[3] = t1) : t1 = $[3];
  const t2 = query || "";
  let t3;
  return $[4] !== handleChange || $[5] !== t1 || $[6] !== t2 ? (t3 = /* @__PURE__ */ jsx(TextInput, { icon: SearchIcon, onChange: handleChange, placeholder: t1, radius: 2, value: t2 }), $[4] = handleChange, $[5] = t1, $[6] = t2, $[7] = t3) : t3 = $[7], t3;
}
function InspectDialog(props) {
  const $ = c(49), {
    value
  } = props, {
    onInspectClose,
    paneKey
  } = useDocumentPane(), dialogIdPrefix = `${paneKey}_inspect_`, [viewModeId, onViewModeChange] = useStructureToolSetting("inspect-view-mode", null, "parsed");
  let t0;
  $[0] !== viewModeId ? (t0 = VIEW_MODES.find((mode) => mode.id === viewModeId), $[0] = viewModeId, $[1] = t0) : t0 = $[1];
  const viewMode = t0;
  let t1;
  $[2] !== onViewModeChange ? (t1 = () => {
    onViewModeChange(VIEW_MODE_PARSED.id);
  }, $[2] = onViewModeChange, $[3] = t1) : t1 = $[3];
  const setParsedViewMode = t1;
  let t2;
  $[4] !== onViewModeChange ? (t2 = () => {
    onViewModeChange(VIEW_MODE_RAW.id);
  }, $[4] = onViewModeChange, $[5] = t2) : t2 = $[5];
  const setRawViewMode = t2, {
    t
  } = useTranslation(structureLocaleNamespace), t3 = `${dialogIdPrefix}dialog`;
  let t4;
  $[6] !== t || $[7] !== value ? (t4 = isDocumentLike(value) ? /* @__PURE__ */ jsx(Translate, { t, i18nKey: "document-inspector.dialog.title", components: {
    DocumentTitle: () => /* @__PURE__ */ jsx("em", { children: /* @__PURE__ */ jsx(DocTitle, { document: value }) })
  } }) : /* @__PURE__ */ jsx("em", { children: t("document-inspector.dialog.title-no-value") }), $[6] = t, $[7] = value, $[8] = t4) : t4 = $[8];
  let t5;
  $[9] === Symbol.for("react.memo_cache_sentinel") ? (t5 = {
    position: "sticky",
    bottom: 0,
    zIndex: 3
  }, $[9] = t5) : t5 = $[9];
  const t6 = `${dialogIdPrefix}tabpanel`, t7 = `${dialogIdPrefix}tab-${VIEW_MODE_PARSED.id}`;
  let t8;
  $[10] !== t ? (t8 = t(VIEW_MODE_PARSED.title), $[10] = t, $[11] = t8) : t8 = $[11];
  const t9 = viewMode === VIEW_MODE_PARSED;
  let t10;
  $[12] !== setParsedViewMode || $[13] !== t6 || $[14] !== t7 || $[15] !== t8 || $[16] !== t9 ? (t10 = /* @__PURE__ */ jsx(Tab, { "aria-controls": t6, id: t7, label: t8, onClick: setParsedViewMode, selected: t9 }), $[12] = setParsedViewMode, $[13] = t6, $[14] = t7, $[15] = t8, $[16] = t9, $[17] = t10) : t10 = $[17];
  const t11 = `${dialogIdPrefix}tabpanel`, t12 = `${dialogIdPrefix}tab-${VIEW_MODE_RAW.id}`;
  let t13;
  $[18] !== t ? (t13 = t(VIEW_MODE_RAW.title), $[18] = t, $[19] = t13) : t13 = $[19];
  const t14 = viewMode === VIEW_MODE_RAW;
  let t15;
  $[20] !== setRawViewMode || $[21] !== t11 || $[22] !== t12 || $[23] !== t13 || $[24] !== t14 ? (t15 = /* @__PURE__ */ jsx(Tab, { "aria-controls": t11, id: t12, label: t13, onClick: setRawViewMode, selected: t14 }), $[20] = setRawViewMode, $[21] = t11, $[22] = t12, $[23] = t13, $[24] = t14, $[25] = t15) : t15 = $[25];
  let t16;
  $[26] !== t10 || $[27] !== t15 ? (t16 = /* @__PURE__ */ jsx(Card, { padding: 3, paddingTop: 0, shadow: 1, style: t5, children: /* @__PURE__ */ jsxs(TabList, { space: 1, children: [
    t10,
    t15
  ] }) }), $[26] = t10, $[27] = t15, $[28] = t16) : t16 = $[28];
  const t17 = `${dialogIdPrefix}tab-${viewModeId}`, t18 = `${dialogIdPrefix}tabpanel`;
  let t19;
  $[29] === Symbol.for("react.memo_cache_sentinel") ? (t19 = {
    outline: "none"
  }, $[29] = t19) : t19 = $[29];
  let t20;
  $[30] !== value || $[31] !== viewMode ? (t20 = viewMode === VIEW_MODE_PARSED && /* @__PURE__ */ jsx(JSONInspectorWrapper, { children: /* @__PURE__ */ jsx(JsonInspector, { data: value, isExpanded, onClick: toggleExpanded, search: Search, filterOptions: {
    ignoreCase: !0
  } }) }), $[30] = value, $[31] = viewMode, $[32] = t20) : t20 = $[32];
  let t21;
  $[33] !== value || $[34] !== viewMode ? (t21 = viewMode === VIEW_MODE_RAW && /* @__PURE__ */ jsx(Code, { language: "json", tabIndex: 0, onKeyDown: maybeSelectAll, onDoubleClick: select, onFocus: select, size: 1, children: JSON.stringify(value, null, 2) }), $[33] = value, $[34] = viewMode, $[35] = t21) : t21 = $[35];
  let t22;
  $[36] !== t17 || $[37] !== t18 || $[38] !== t20 || $[39] !== t21 ? (t22 = /* @__PURE__ */ jsxs(TabPanel, { "aria-labelledby": t17, flex: 1, id: t18, overflow: "auto", padding: 4, style: t19, children: [
    t20,
    t21
  ] }), $[36] = t17, $[37] = t18, $[38] = t20, $[39] = t21, $[40] = t22) : t22 = $[40];
  let t23;
  $[41] !== t16 || $[42] !== t22 ? (t23 = /* @__PURE__ */ jsxs(Flex, { direction: "column", height: "fill", children: [
    t16,
    t22
  ] }), $[41] = t16, $[42] = t22, $[43] = t23) : t23 = $[43];
  let t24;
  return $[44] !== onInspectClose || $[45] !== t23 || $[46] !== t3 || $[47] !== t4 ? (t24 = /* @__PURE__ */ jsx(Dialog, { bodyHeight: "fill", id: t3, header: t4, onClose: onInspectClose, onClickOutside: onInspectClose, padding: !1, width: 2, children: t23 }), $[44] = onInspectClose, $[45] = t23, $[46] = t3, $[47] = t4, $[48] = t24) : t24 = $[48], t24;
}
function Banner(props) {
  const $ = c(22);
  let Icon, action, content, rest, t0, t1;
  $[0] !== props ? ({
    action,
    content,
    icon: Icon,
    tone: t0,
    paddingY: t1,
    ...rest
  } = props, $[0] = props, $[1] = Icon, $[2] = action, $[3] = content, $[4] = rest, $[5] = t0, $[6] = t1) : (Icon = $[1], action = $[2], content = $[3], rest = $[4], t0 = $[5], t1 = $[6]);
  const tone = t0 === void 0 ? "transparent" : t0, paddingY = t1 === void 0 ? 2 : t1;
  let t2;
  $[7] !== Icon ? (t2 = Icon && /* @__PURE__ */ jsx(Text, { size: 0, children: /* @__PURE__ */ jsx(Icon, {}) }), $[7] = Icon, $[8] = t2) : t2 = $[8];
  let t3;
  $[9] !== content ? (t3 = /* @__PURE__ */ jsx(Flex, { align: "center", flex: 1, gap: 2, paddingY: 2, children: content }), $[9] = content, $[10] = t3) : t3 = $[10];
  let t4;
  $[11] !== action ? (t4 = action && /* @__PURE__ */ jsx(Button, { ...action, mode: action.mode || "ghost", tone: action.tone || "default" }), $[11] = action, $[12] = t4) : t4 = $[12];
  let t5;
  $[13] !== t2 || $[14] !== t3 || $[15] !== t4 ? (t5 = /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, paddingX: 2, children: [
    t2,
    t3,
    t4
  ] }), $[13] = t2, $[14] = t3, $[15] = t4, $[16] = t5) : t5 = $[16];
  let t6;
  return $[17] !== paddingY || $[18] !== rest || $[19] !== t5 || $[20] !== tone ? (t6 = /* @__PURE__ */ jsx(Box, { padding: 1, children: /* @__PURE__ */ jsx(Card, { radius: 3, paddingX: 2, paddingY, tone, ...rest, children: t5 }) }), $[17] = paddingY, $[18] = rest, $[19] = t5, $[20] = tone, $[21] = t6) : t6 = $[21], t6;
}
function DeletedDocumentBanners() {
  const $ = c(3), {
    isDeleted,
    isDeleting,
    ready
  } = useDocumentPane(), {
    selectedPerspective
  } = usePerspective();
  if (!ready)
    return null;
  if (!isPublishedPerspective(selectedPerspective) && !isDraftPerspective(selectedPerspective) && selectedPerspective.state === "archived") {
    const t0 = selectedPerspective;
    let t1;
    return $[0] !== t0 ? (t1 = /* @__PURE__ */ jsx(ArchivedReleaseBanner, { release: t0 }), $[0] = t0, $[1] = t1) : t1 = $[1], t1;
  }
  if (isDeleted && !isDeleting) {
    let t0;
    return $[2] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ jsx(DeletedDocumentBanner, {}), $[2] = t0) : t0 = $[2], t0;
  }
}
function DeletedDocumentBanner() {
  const $ = c(17), {
    documentId,
    documentType
  } = useDocumentPane(), {
    restore
  } = useDocumentOperation(documentId, documentType), {
    navigateIntent
  } = useRouter();
  let t0;
  $[0] !== documentId || $[1] !== documentType || $[2] !== navigateIntent || $[3] !== restore ? (t0 = () => {
    restore.execute("lastRevision"), navigateIntent("edit", {
      id: documentId,
      type: documentType
    });
  }, $[0] = documentId, $[1] = documentType, $[2] = navigateIntent, $[3] = restore, $[4] = t0) : t0 = $[4];
  const handleRestore = t0, {
    t
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[5] !== t ? (t1 = t("banners.deleted-document-banner.restore-button.text"), $[5] = t, $[6] = t1) : t1 = $[6];
  let t2;
  $[7] !== handleRestore || $[8] !== t1 ? (t2 = {
    onClick: handleRestore,
    text: t1
  }, $[7] = handleRestore, $[8] = t1, $[9] = t2) : t2 = $[9];
  let t3;
  $[10] !== t ? (t3 = t("banners.deleted-document-banner.text"), $[10] = t, $[11] = t3) : t3 = $[11];
  let t4;
  $[12] !== t3 ? (t4 = /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t3 }), $[12] = t3, $[13] = t4) : t4 = $[13];
  let t5;
  return $[14] !== t2 || $[15] !== t4 ? (t5 = /* @__PURE__ */ jsx(Banner, { action: t2, content: t4, "data-testid": "deleted-document-banner", icon: ReadOnlyIcon }), $[14] = t2, $[15] = t4, $[16] = t5) : t5 = $[16], t5;
}
const ArchivedReleaseBanner = (t0) => {
  const $ = c(8), {
    release
  } = t0, {
    t
  } = useTranslation();
  let t1;
  $[0] !== release.metadata?.title || $[1] !== t ? (t1 = release.metadata?.title || t("release.placeholder-untitled-release"), $[0] = release.metadata?.title, $[1] = t, $[2] = t1) : t1 = $[2];
  let t2;
  $[3] !== t1 ? (t2 = {
    title: t1
  }, $[3] = t1, $[4] = t2) : t2 = $[4];
  let t3;
  return $[5] !== t || $[6] !== t2 ? (t3 = /* @__PURE__ */ jsx(Banner, { tone: "caution", content: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: /* @__PURE__ */ jsx(Translate, { t, i18nKey: "banners.deleted-release-banner.text", values: t2 }) }), "data-testid": "deleted-release-banner", icon: DocumentRemoveIcon }), $[5] = t, $[6] = t2, $[7] = t3) : t3 = $[7], t3;
};
function DeprecatedDocumentTypeBanner() {
  const $ = c(5), {
    schemaType
  } = useDocumentPane(), {
    t
  } = useTranslation(structureLocaleNamespace);
  if (!isDeprecatedSchemaType(schemaType))
    return null;
  let t0;
  $[0] !== t ? (t0 = /* @__PURE__ */ jsx(Translate, { t, i18nKey: "banners.deprecated-document-type-banner.text" }), $[0] = t, $[1] = t0) : t0 = $[1];
  let t1;
  return $[2] !== schemaType.deprecated.reason || $[3] !== t0 ? (t1 = /* @__PURE__ */ jsx(Banner, { content: /* @__PURE__ */ jsxs(Text, { size: 1, weight: "medium", children: [
    t0,
    " ",
    schemaType.deprecated.reason
  ] }), "data-testid": "deprecated-document-type-banner", icon: ErrorOutlineIcon }), $[2] = schemaType.deprecated.reason, $[3] = t0, $[4] = t1) : t1 = $[4], t1;
}
const AskToEditDialogOpened = defineEvent({
  name: "Ask To Edit Dialog Opened",
  version: 1,
  description: 'User clicked the "Ask to edit" button in the document permissions banner'
}), AskToEditRequestSent = defineEvent({
  name: "Ask To Edit Request Sent",
  version: 1,
  description: "User sent a role change request from the dialog"
}), MAX_NOTE_LENGTH = 150, DialogBody = styled(Box)`
  box-sizing: border-box;
`;
styled(Flex).attrs({
  align: "center",
  direction: "column",
  justify: "center"
})`
  height: 110px;
`;
function RequestPermissionDialog(t0) {
  const $ = c(56), {
    onClose,
    onRequestSubmitted
  } = t0, {
    t
  } = useTranslation(structureLocaleNamespace), telemtry = useTelemetry(), dialogId = `request-permissions-${useId()}`, projectId = useProjectId();
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = {
    apiVersion: "2024-09-26"
  }, $[0] = t1) : t1 = $[0];
  const client = useClient(t1), toast = useToast(), zOffset = useZIndex(), [isSubmitting, setIsSubmitting] = useState(!1), [note, setNote] = useState(""), [msgError, setMsgError] = useState(), [hasTooManyRequests, setHasTooManyRequests] = useState(!1), [hasBeenDenied, setHasBeenDenied] = useState(!1);
  let t2;
  bb0: {
    const adminRole = "administrator";
    if (!projectId || !client) {
      let t33;
      $[1] === Symbol.for("react.memo_cache_sentinel") ? (t33 = of(adminRole), $[1] = t33) : t33 = $[1], t2 = t33;
      break bb0;
    }
    let t32;
    if ($[2] !== client.observable || $[3] !== projectId) {
      let t42;
      $[5] === Symbol.for("react.memo_cache_sentinel") ? (t42 = (roles) => roles.filter(_temp$h).find(_temp2$6) ? "editor" : adminRole, $[5] = t42) : t42 = $[5];
      let t52;
      $[6] === Symbol.for("react.memo_cache_sentinel") ? (t52 = () => of(adminRole), $[6] = t52) : t52 = $[6], t32 = client.observable.request({
        url: `/projects/${projectId}/roles`
      }).pipe(map$1(t42), startWith$1(adminRole), catchError$1(t52)), $[2] = client.observable, $[3] = projectId, $[4] = t32;
    } else
      t32 = $[4];
    t2 = t32;
  }
  const requestedRole = useObservable(t2);
  let t3;
  $[7] !== client || $[8] !== note || $[9] !== onRequestSubmitted || $[10] !== projectId || $[11] !== requestedRole || $[12] !== telemtry || $[13] !== toast ? (t3 = () => {
    setIsSubmitting(!0), client.request({
      url: `/access/project/${projectId}/requests`,
      method: "post",
      body: {
        note,
        requestUrl: window?.location.href,
        requestedRole,
        type: "role"
      }
    }).then((request) => {
      request && (onRequestSubmitted && onRequestSubmitted(), telemtry.log(AskToEditRequestSent), toast.push({
        title: "Edit access requested"
      }));
    }).catch((err) => {
      const statusCode = err?.response?.statusCode, errMessage = err?.response?.body?.message;
      statusCode === 429 && (setHasTooManyRequests(!0), setMsgError(errMessage)), statusCode === 409 ? (setHasBeenDenied(!0), setMsgError(errMessage)) : toast.push({
        title: "There was a problem submitting your request.",
        status: "error"
      });
    }).finally(() => {
      setIsSubmitting(!1);
    });
  }, $[7] = client, $[8] = note, $[9] = onRequestSubmitted, $[10] = projectId, $[11] = requestedRole, $[12] = telemtry, $[13] = toast, $[14] = t3) : t3 = $[14];
  const onSubmit = t3, t4 = zOffset.fullscreen;
  let t5;
  $[15] !== t ? (t5 = t("request-permission-dialog.header.text"), $[15] = t, $[16] = t5) : t5 = $[16];
  let t6;
  $[17] !== t ? (t6 = t("confirm-dialog.cancel-button.fallback-text"), $[17] = t, $[18] = t6) : t6 = $[18];
  let t7;
  $[19] !== onClose || $[20] !== t6 ? (t7 = {
    onClick: onClose,
    text: t6
  }, $[19] = onClose, $[20] = t6, $[21] = t7) : t7 = $[21];
  const t8 = hasTooManyRequests || hasBeenDenied;
  let t9;
  $[22] !== t ? (t9 = t("request-permission-dialog.confirm-button.text"), $[22] = t, $[23] = t9) : t9 = $[23];
  let t10;
  $[24] !== isSubmitting || $[25] !== onSubmit || $[26] !== t8 || $[27] !== t9 ? (t10 = {
    onClick: onSubmit,
    loading: isSubmitting,
    disabled: t8,
    text: t9,
    tone: "primary",
    type: "submit"
  }, $[24] = isSubmitting, $[25] = onSubmit, $[26] = t8, $[27] = t9, $[28] = t10) : t10 = $[28];
  let t11;
  $[29] !== t10 || $[30] !== t7 ? (t11 = {
    cancelButton: t7,
    confirmButton: t10
  }, $[29] = t10, $[30] = t7, $[31] = t11) : t11 = $[31];
  let t12;
  $[32] !== t ? (t12 = t("request-permission-dialog.description.text"), $[32] = t, $[33] = t12) : t12 = $[33];
  let t13;
  $[34] !== t12 ? (t13 = /* @__PURE__ */ jsx(Text, { children: t12 }), $[34] = t12, $[35] = t13) : t13 = $[35];
  let t14;
  $[36] !== hasBeenDenied || $[37] !== hasTooManyRequests || $[38] !== isSubmitting || $[39] !== msgError || $[40] !== note || $[41] !== onSubmit || $[42] !== t ? (t14 = hasTooManyRequests || hasBeenDenied ? /* @__PURE__ */ jsx(Card, { tone: "caution", padding: 3, radius: 2, shadow: 1, children: /* @__PURE__ */ jsxs(Text, { size: 1, children: [
    hasTooManyRequests && /* @__PURE__ */ jsx(Fragment, { children: msgError ?? t("request-permission-dialog.warning.limit-reached.text") }),
    hasBeenDenied && /* @__PURE__ */ jsx(Fragment, { children: msgError ?? t("request-permission-dialog.warning.denied.text") })
  ] }) }) : /* @__PURE__ */ jsxs(Stack, { space: 3, paddingBottom: 0, children: [
    /* @__PURE__ */ jsx(TextInput, { placeholder: t("request-permission-dialog.note-input.placeholder.text"), disabled: isSubmitting, onKeyDown: (e) => {
      e.key === "Enter" && onSubmit();
    }, maxLength: MAX_NOTE_LENGTH, value: note, onChange: (e_0) => {
      setNote(e_0.currentTarget.value);
    } }),
    /* @__PURE__ */ jsx(Text, { align: "right", muted: !0, size: 1, children: `${note.length}/${MAX_NOTE_LENGTH}` })
  ] }), $[36] = hasBeenDenied, $[37] = hasTooManyRequests, $[38] = isSubmitting, $[39] = msgError, $[40] = note, $[41] = onSubmit, $[42] = t, $[43] = t14) : t14 = $[43];
  let t15;
  $[44] !== t13 || $[45] !== t14 ? (t15 = /* @__PURE__ */ jsx(DialogBody, { children: /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
    t13,
    t14
  ] }) }), $[44] = t13, $[45] = t14, $[46] = t15) : t15 = $[46];
  let t16;
  $[47] !== dialogId || $[48] !== onClose || $[49] !== t11 || $[50] !== t15 || $[51] !== t5 ? (t16 = /* @__PURE__ */ jsx(Dialog, { width: 1, id: dialogId, header: t5, footer: t11, onClose, onClickOutside: onClose, children: t15 }), $[47] = dialogId, $[48] = onClose, $[49] = t11, $[50] = t15, $[51] = t5, $[52] = t16) : t16 = $[52];
  let t17;
  return $[53] !== t16 || $[54] !== zOffset.fullscreen ? (t17 = /* @__PURE__ */ jsx(DialogProvider, { position: "fixed", zOffset: t4, children: t16 }), $[53] = t16, $[54] = zOffset.fullscreen, $[55] = t17) : t17 = $[55], t17;
}
function _temp2$6(role_0) {
  return role_0.name === "editor";
}
function _temp$h(role) {
  return role?.appliesToUsers;
}
const LOADING_STATE = {
  loading: !0,
  error: !1,
  status: void 0
}, EMPTY_STATE = {
  loading: !1,
  error: !1,
  status: "none"
}, DECLINED_STATE = {
  loading: !1,
  error: !1,
  status: "declined"
}, PENDING_STATE = {
  loading: !1,
  error: !1,
  status: "pending"
}, EXPIRED_STATE = {
  loading: !1,
  error: !1,
  status: "expired"
}, useRoleRequestsStatus = () => {
  const $ = c(9);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    apiVersion: "2024-07-01"
  }, $[0] = t0) : t0 = $[0];
  const client = useClient(t0), projectId = useProjectId();
  let t1;
  bb0: {
    if (!client || !projectId) {
      let t23;
      $[1] === Symbol.for("react.memo_cache_sentinel") ? (t23 = of(EMPTY_STATE), $[1] = t23) : t23 = $[1], t1 = t23;
      break bb0;
    }
    let t22;
    $[2] !== client || $[3] !== projectId ? (t22 = checkRoleRequests(client, projectId), $[2] = client, $[3] = projectId, $[4] = t22) : t22 = $[4], t1 = t22;
  }
  const checkRoleRequests$ = t1, {
    loading,
    error,
    status
  } = useObservable(checkRoleRequests$, LOADING_STATE);
  let t2;
  return $[5] !== error || $[6] !== loading || $[7] !== status ? (t2 = {
    data: status,
    loading,
    error
  }, $[5] = error, $[6] = loading, $[7] = status, $[8] = t2) : t2 = $[8], t2;
};
function checkRoleRequests(client, projectId) {
  return client.observable.request({
    url: "/access/requests/me",
    tag: "use-role-requests-status"
  }).pipe(
    map((requests) => {
      if (!requests || requests.length === 0)
        return EMPTY_STATE;
      const projectRequests = requests.filter((request) => request.resourceId === projectId && request.type === "role"), declinedRequest = projectRequests.find((request) => request.status === "declined");
      return declinedRequest && isAfter(addWeeks(new Date(declinedRequest.createdAt), 2), /* @__PURE__ */ new Date()) ? DECLINED_STATE : projectRequests.find((request) => request.status === "pending" && isAfter(addWeeks(new Date(request.createdAt), 2), /* @__PURE__ */ new Date())) ? PENDING_STATE : projectRequests.find((request) => request.status === "pending" && isBefore(addWeeks(new Date(request.createdAt), 2), /* @__PURE__ */ new Date())) ? EXPIRED_STATE : EMPTY_STATE;
    }),
    catchError((err) => (console.error("Failed to fetch access requests", err), of({
      loading: !1,
      error: !0,
      status: void 0
    }))),
    startWith(LOADING_STATE)
    // Start with loading state
  );
}
function InsufficientPermissionBanner(t0) {
  const $ = c(33), {
    requiredPermission
  } = t0, currentUser = useCurrentUser(), {
    data: roleRequestStatus,
    loading: requestStatusLoading,
    error: requestStatusError
  } = useRoleRequestsStatus(), [requestSent, setRequestSent] = useState(!1);
  let t1;
  t1 = roleRequestStatus === "pending" || roleRequestStatus === "declined" || requestSent;
  const requestPending = t1;
  let t2;
  $[0] !== currentUser?.roles ? (t2 = currentUser?.roles || [], $[0] = currentUser?.roles, $[1] = t2) : t2 = $[1];
  const currentUserRoles = t2, isOnlyViewer = currentUserRoles.length === 1 && currentUserRoles[0].name === "viewer", [showRequestPermissionDialog, setShowRequestPermissionDialog] = useState(!1);
  let t3;
  $[2] === Symbol.for("react.memo_cache_sentinel") ? (t3 = {
    style: "short"
  }, $[2] = t3) : t3 = $[2];
  const listFormat = useListFormat(t3), {
    t
  } = useTranslation(structureLocaleNamespace), telemetry = useTelemetry();
  let roleTitles, t4;
  $[3] !== currentUserRoles || $[4] !== listFormat ? (roleTitles = currentUserRoles.map(_temp$g), t4 = listFormat.formatToParts(roleTitles).map(_temp2$5), $[3] = currentUserRoles, $[4] = listFormat, $[5] = roleTitles, $[6] = t4) : (roleTitles = $[5], t4 = $[6]);
  const roles = t4;
  let t5;
  $[7] !== roles ? (t5 = {
    Roles: () => /* @__PURE__ */ jsx(Fragment, { children: roles })
  }, $[7] = roles, $[8] = t5) : t5 = $[8];
  let t6;
  $[9] !== roleTitles || $[10] !== roles.length ? (t6 = {
    count: roles.length,
    roles: roleTitles
  }, $[9] = roleTitles, $[10] = roles.length, $[11] = t6) : t6 = $[11];
  let t7;
  $[12] !== requiredPermission || $[13] !== t || $[14] !== t5 || $[15] !== t6 ? (t7 = /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: /* @__PURE__ */ jsx(Translate, { t, i18nKey: "banners.permission-check-banner.missing-permission", components: t5, values: t6, context: requiredPermission }) }), $[12] = requiredPermission, $[13] = t, $[14] = t5, $[15] = t6, $[16] = t7) : t7 = $[16];
  let t8;
  $[17] !== isOnlyViewer || $[18] !== requestPending || $[19] !== requestStatusError || $[20] !== requestStatusLoading || $[21] !== roleRequestStatus || $[22] !== t || $[23] !== telemetry ? (t8 = isOnlyViewer && roleRequestStatus && !requestStatusError && !requestStatusLoading ? {
    onClick: requestPending ? void 0 : () => {
      setShowRequestPermissionDialog(!0), telemetry.log(AskToEditDialogOpened);
    },
    text: t(requestPending ? "banners.permission-check-banner.request-permission-button.sent" : "banners.permission-check-banner.request-permission-button.text"),
    tone: requestPending ? "default" : "primary",
    disabled: requestPending,
    mode: requestPending ? "bleed" : void 0
  } : void 0, $[17] = isOnlyViewer, $[18] = requestPending, $[19] = requestStatusError, $[20] = requestStatusLoading, $[21] = roleRequestStatus, $[22] = t, $[23] = telemetry, $[24] = t8) : t8 = $[24];
  let t9;
  $[25] !== t7 || $[26] !== t8 ? (t9 = /* @__PURE__ */ jsx(Banner, { content: t7, action: t8, "data-testid": "permission-check-banner", icon: ReadOnlyIcon }), $[25] = t7, $[26] = t8, $[27] = t9) : t9 = $[27];
  let t10;
  $[28] !== showRequestPermissionDialog ? (t10 = showRequestPermissionDialog && /* @__PURE__ */ jsx(RequestPermissionDialog, { onClose: () => setShowRequestPermissionDialog(!1), onRequestSubmitted: () => {
    setRequestSent(!0), setShowRequestPermissionDialog(!1);
  } }), $[28] = showRequestPermissionDialog, $[29] = t10) : t10 = $[29];
  let t11;
  return $[30] !== t10 || $[31] !== t9 ? (t11 = /* @__PURE__ */ jsxs(Fragment, { children: [
    t9,
    t10
  ] }), $[30] = t10, $[31] = t9, $[32] = t11) : t11 = $[32], t11;
}
function _temp2$5(part) {
  return part.type === "element" ? /* @__PURE__ */ jsx("code", { children: part.value }, part.value) : part.value;
}
function _temp$g(role) {
  return role.title;
}
const ReferenceChangedBanner = memo(() => {
  const documentPreviewStore = useDocumentPreviewStore(), {
    selectedReleaseId
  } = usePerspective(), {
    params,
    groupIndex,
    routerPanesState,
    replaceCurrent,
    BackLink: BackLink2
  } = usePaneRouter(), routerReferenceId = routerPanesState[groupIndex]?.[0].id, parentSibling = routerPanesState[groupIndex - 1]?.[0], parentId = parentSibling?.id, hasHistoryOpen = !!parentSibling?.params?.rev, parentRefPath = useMemo(() => params?.parentRefPath && fromString(params.parentRefPath) || null, [params?.parentRefPath]), {
    t
  } = useTranslation(structureLocaleNamespace), referenceInfoObservable = useMemo(() => {
    const parentRefPathSegment = parentRefPath?.[0];
    if (!parentId || !parentRefPathSegment || !parentRefPath)
      return of({
        loading: !1
      });
    const publishedId = getPublishedId(parentId), path = fromString(parentRefPathSegment), keyedSegmentIndex = path.findIndex((p) => typeof p == "object" && "_key" in p);
    return concat(
      // emit a loading state instantly
      of({
        loading: !0
      }),
      // then emit the values from watching the published ID's path
      documentPreviewStore.unstable_observePathsDocumentPair(publishedId, keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex), {
        version: selectedReleaseId
      }).pipe(
        // this debounce time is needed to prevent flashing banners due to
        // the router state updating faster than the content-lake state. we
        // debounce to wait for more emissions because the value pulled
        // initially could be stale.
        debounceTime(750),
        map(({
          draft,
          published,
          version
        }) => ({
          loading: !1,
          result: {
            availability: {
              draft: draft.availability,
              published: published.availability,
              ...version?.availability ? {
                version: version.availability
              } : {}
            },
            refValue: get(version?.snapshot || draft.snapshot || published.snapshot, parentRefPath)?._ref
          }
        }))
      )
    );
  }, [selectedReleaseId, documentPreviewStore, parentId, parentRefPath]), referenceInfo = useObservable(referenceInfoObservable, {
    loading: !0
  }), handleReloadReference = useCallback(() => {
    referenceInfo.loading || referenceInfo.result?.refValue && replaceCurrent({
      id: referenceInfo.result.refValue,
      params
    });
  }, [referenceInfo.loading, referenceInfo.result, replaceCurrent, params]);
  return (
    // if `parentId` or `parentRefPath` is not present then this banner is n/a
    !parentId || !parentRefPath || // if viewing this pane via history, then hide
    hasHistoryOpen || // if loading, hide
    referenceInfo.loading || // if the parent document is not available (e.g. due to permission denied or
    // not found) we don't want to display a warning here, but instead rely on the
    // parent view to display the appropriate message
    !referenceInfo.result?.availability.draft.available && !referenceInfo.result?.availability.published.available || // if the references are the same, then hide the reference changed banner
    referenceInfo.result?.refValue === routerReferenceId ? null : /* @__PURE__ */ jsx(Banner, { action: referenceInfo.result?.refValue ? {
      onClick: handleReloadReference,
      icon: SyncIcon,
      text: t("banners.reference-changed-banner.reason-changed.reload-button.text")
    } : {
      as: BackLink2,
      icon: CloseIcon,
      text: t("banners.reference-changed-banner.reason-removed.close-button.text")
    }, "data-testid": "reference-changed-banner", content: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: referenceInfo.result?.refValue ? t("banners.reference-changed-banner.reason-changed.text") : t("banners.reference-changed-banner.reason-removed.text") }), icon: WarningOutlineIcon, tone: "caution" })
  );
});
ReferenceChangedBanner.displayName = "Memo(ReferenceChangedBanner)";
function ArchivedReleaseDocumentBanner() {
  const {
    t
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation(), {
    data: archivedReleases
  } = useArchivedReleases(), {
    params,
    setParams
  } = usePaneRouter(), handleGoBack = () => {
    setParams({
      ...params,
      rev: params?.historyEvent || void 0,
      since: void 0,
      historyVersion: void 0
    });
  }, release = useMemo(() => archivedReleases.find((r) => getReleaseIdFromReleaseDocumentId(r._id) === params?.historyVersion), [archivedReleases, params?.historyVersion]), description = release?.state === "published" ? "banners.published-release.description" : "banners.archived-release.description", title = release?.metadata.title || tCore("release.placeholder-untitled-release");
  return /* @__PURE__ */ jsx(Banner, { tone: "caution", content: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Translate, { t, i18nKey: description, values: {
    title
  }, components: {
    VersionBadge: getVersionInlineBadge(release)
  } }) }), action: params?.archivedRelease ? void 0 : {
    text: "Go back to published version",
    onClick: handleGoBack
  } });
}
const Image = styled.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 180px;
  display: flex;
`, CANVAS_IMAGE_URL = "https://cdn.sanity.io/images/pyrmmpch/production/b47224e2f3a7d1747e43b9da1ac31739250e628b-632x376.png", CANVAS_APP_NAME = "Canvas", CanvasPopoverContent = (t0) => {
  const $ = c(22), {
    onClose
  } = t0, {
    t
  } = useTranslation(structureLocaleNamespace), ref = useRef(null);
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => [ref.current], $[0] = t1) : t1 = $[0], useClickOutsideEvent(onClose, t1);
  let t2;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t2 = /* @__PURE__ */ jsx(Image, { src: CANVAS_IMAGE_URL, alt: "Canvas" }), $[1] = t2) : t2 = $[1];
  let t3;
  $[2] === Symbol.for("react.memo_cache_sentinel") ? (t3 = /* @__PURE__ */ jsx(Text, { size: 1, weight: "semibold", children: CANVAS_APP_NAME }), $[2] = t3) : t3 = $[2];
  let t4;
  $[3] === Symbol.for("react.memo_cache_sentinel") ? (t4 = /* @__PURE__ */ jsxs(Flex, { paddingY: 1, gap: 2, children: [
    t3,
    /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: /* @__PURE__ */ jsx(ComposeSparklesIcon, {}) })
  ] }), $[3] = t4) : t4 = $[3];
  let t5;
  $[4] !== t ? (t5 = t("canvas.banner.popover-heading"), $[4] = t, $[5] = t5) : t5 = $[5];
  let t6;
  $[6] !== t5 ? (t6 = /* @__PURE__ */ jsx(Box, { paddingTop: 3, children: /* @__PURE__ */ jsx(Heading, { size: 1, children: t5 }) }), $[6] = t5, $[7] = t6) : t6 = $[7];
  let t7;
  $[8] !== t ? (t7 = t("canvas.banner.popover-description"), $[8] = t, $[9] = t7) : t7 = $[9];
  let t8;
  $[10] !== t7 ? (t8 = /* @__PURE__ */ jsx(Box, { paddingTop: 4, children: /* @__PURE__ */ jsx(Text, { size: 1, children: t7 }) }), $[10] = t7, $[11] = t8) : t8 = $[11];
  let t9;
  $[12] !== t6 || $[13] !== t8 ? (t9 = /* @__PURE__ */ jsxs(Flex, { paddingX: 4, paddingBottom: 4, paddingTop: 3, direction: "column", children: [
    t4,
    t6,
    t8
  ] }), $[12] = t6, $[13] = t8, $[14] = t9) : t9 = $[14];
  let t10;
  $[15] !== t ? (t10 = t("canvas.banner.popover-button-text"), $[15] = t, $[16] = t10) : t10 = $[16];
  let t11;
  $[17] !== t10 ? (t11 = /* @__PURE__ */ jsx(Flex, { width: "full", gap: 3, justify: "flex-end", paddingX: 4, paddingBottom: 4, children: /* @__PURE__ */ jsx(Button, { mode: "bleed", text: t10, autoFocus: !0, tone: "primary", href: "https://snty.link/canvas-docs", target: "_blank", rel: "noopener noreferrer", as: "a", iconRight: LaunchIcon }) }), $[17] = t10, $[18] = t11) : t11 = $[18];
  let t12;
  return $[19] !== t11 || $[20] !== t9 ? (t12 = /* @__PURE__ */ jsx(Card, { radius: 3, overflow: "hidden", width: 0, ref, children: /* @__PURE__ */ jsxs(Container$1, { width: 0, children: [
    t2,
    t9,
    t11
  ] }) }), $[19] = t11, $[20] = t9, $[21] = t12) : t12 = $[21], t12;
}, CanvasLinkedBannerContent = (t0) => {
  const $ = c(17), {
    documentId
  } = t0, {
    t
  } = useTranslation(structureLocaleNamespace), [open, setOpen] = useState(!1), documentVariantType = getDocumentVariantType(documentId);
  let t1;
  bb0: {
    if (documentVariantType === "published") {
      let t23;
      $[0] !== t ? (t23 = t("canvas.banner.linked-text.published"), $[0] = t, $[1] = t23) : t23 = $[1], t1 = t23;
      break bb0;
    }
    if (documentVariantType === "draft") {
      let t23;
      $[2] !== t ? (t23 = t("canvas.banner.linked-text.draft"), $[2] = t, $[3] = t23) : t23 = $[3], t1 = t23;
      break bb0;
    }
    let t22;
    $[4] !== t ? (t22 = t("canvas.banner.linked-text.version"), $[4] = t, $[5] = t22) : t22 = $[5], t1 = t22;
  }
  const variantText = t1;
  let t2;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t2 = () => setOpen(_temp$f), $[6] = t2) : t2 = $[6];
  const togglePopover = t2;
  let t3;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => setOpen(!1), $[7] = t3) : t3 = $[7];
  const onClose = t3;
  let t4;
  $[8] !== variantText ? (t4 = /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: variantText }), $[8] = variantText, $[9] = t4) : t4 = $[9];
  let t5, t6;
  $[10] === Symbol.for("react.memo_cache_sentinel") ? (t5 = /* @__PURE__ */ jsx(CanvasPopoverContent, { onClose }), t6 = /* @__PURE__ */ jsx(Button, { tooltipProps: null, mode: "bleed", tone: "default", icon: InfoOutlineIcon, onClick: togglePopover }), $[10] = t5, $[11] = t6) : (t5 = $[10], t6 = $[11]);
  let t7;
  $[12] !== open ? (t7 = /* @__PURE__ */ jsx(Popover, { open, size: 0, tone: "default", portal: !0, placement: "bottom-start", content: t5, children: t6 }), $[12] = open, $[13] = t7) : t7 = $[13];
  let t8;
  return $[14] !== t4 || $[15] !== t7 ? (t8 = /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, children: [
    t4,
    t7
  ] }), $[14] = t4, $[15] = t7, $[16] = t8) : t8 = $[16], t8;
};
function CanvasLinkedBanner() {
  const $ = c(10), {
    documentId,
    displayed
  } = useDocumentPane(), {
    t
  } = useTranslation(structureLocaleNamespace), id = displayed?._id || documentId, {
    companionDoc
  } = useCanvasCompanionDoc(id), navigateToCanvas = useNavigateToCanvasDoc(companionDoc?.canvasDocumentId, "banner");
  if (!companionDoc)
    return null;
  let t0;
  $[0] !== id ? (t0 = /* @__PURE__ */ jsx(CanvasLinkedBannerContent, { documentId: id }), $[0] = id, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== t ? (t1 = t("canvas.banner.edit-in-canvas-action"), $[2] = t, $[3] = t1) : t1 = $[3];
  let t2;
  $[4] !== navigateToCanvas || $[5] !== t1 ? (t2 = {
    mode: "ghost",
    text: t1,
    onClick: navigateToCanvas
  }, $[4] = navigateToCanvas, $[5] = t1, $[6] = t2) : t2 = $[6];
  let t3;
  return $[7] !== t0 || $[8] !== t2 ? (t3 = /* @__PURE__ */ jsx(Banner, { tone: "neutral", "data-test-id": "canvas-linked-banner", paddingY: 0, content: t0, action: t2 }), $[7] = t0, $[8] = t2, $[9] = t3) : t3 = $[9], t3;
}
function _temp$f(prev) {
  return !prev;
}
const ChooseNewDocumentDestinationBanner = (t0) => {
  const $ = c(27), {
    schemaType,
    selectedPerspective,
    reason
  } = t0, {
    t
  } = useTranslation(structureLocaleNamespace), {
    document: t1
  } = useWorkspace(), {
    drafts: t2
  } = t1, {
    enabled: isDraftModelEnabled
  } = t2;
  let t3;
  $[0] !== isDraftModelEnabled || $[1] !== schemaType ? (t3 = (t42) => {
    const {
      perspective
    } = t42;
    return {
      disabled: !isPerspectiveWriteable({
        selectedPerspective: perspective,
        isDraftModelEnabled,
        schemaType
      }).result
    };
  }, $[0] = isDraftModelEnabled, $[1] = schemaType, $[2] = t3) : t3 = $[2];
  const menuItemProps = t3;
  let t4;
  $[3] !== reason || $[4] !== t ? (t4 = reason === "PUBLISHED_NOT_WRITEABLE" && t("banners.choose-new-document-destination.cannot-create-published-document"), $[3] = reason, $[4] = t, $[5] = t4) : t4 = $[5];
  let t5;
  $[6] !== reason || $[7] !== t ? (t5 = reason === "DRAFTS_NOT_WRITEABLE" && t("banners.choose-new-document-destination.cannot-create-draft-document"), $[6] = reason, $[7] = t, $[8] = t5) : t5 = $[8];
  let t6;
  $[9] !== reason || $[10] !== selectedPerspective || $[11] !== t ? (t6 = reason === "RELEASE_NOT_ACTIVE" && isReleaseDocument(selectedPerspective) && /* @__PURE__ */ jsx(Translate, { t, i18nKey: "banners.choose-new-document-destination.release-inactive", values: {
    title: selectedPerspective.metadata.title
  }, components: {
    VersionBadge: getVersionInlineBadge(selectedPerspective)
  } }), $[9] = reason, $[10] = selectedPerspective, $[11] = t, $[12] = t6) : t6 = $[12];
  let t7;
  $[13] !== t ? (t7 = t("banners.choose-new-document-destination.choose-destination"), $[13] = t, $[14] = t7) : t7 = $[14];
  let t8;
  $[15] !== t7 ? (t8 = /* @__PURE__ */ jsxs(Fragment, { children: [
    " ",
    t7
  ] }), $[15] = t7, $[16] = t8) : t8 = $[16];
  let t9;
  $[17] !== t4 || $[18] !== t5 || $[19] !== t6 || $[20] !== t8 ? (t9 = /* @__PURE__ */ jsxs(Text, { size: 1, children: [
    t4,
    t5,
    t6,
    t8
  ] }), $[17] = t4, $[18] = t5, $[19] = t6, $[20] = t8, $[21] = t9) : t9 = $[21];
  let t10;
  $[22] !== menuItemProps ? (t10 = /* @__PURE__ */ jsx(ReleasesNav, { menuItemProps }), $[22] = menuItemProps, $[23] = t10) : t10 = $[23];
  let t11;
  return $[24] !== t10 || $[25] !== t9 ? (t11 = /* @__PURE__ */ jsx(Banner, { tone: "caution", icon: WarningOutlineIcon, content: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, children: [
    t9,
    t10
  ] }) }), $[24] = t10, $[25] = t9, $[26] = t11) : t11 = $[26], t11;
};
function CreateLinkedBanner() {
  const $ = c(5), {
    value
  } = useDocumentPane(), {
    documentLinkedBannerContent: CreateLinkedBannerContent
  } = useSanityCreateConfig().components ?? {};
  let t0;
  $[0] !== value ? (t0 = getSanityCreateLinkMetadata(value), $[0] = value, $[1] = t0) : t0 = $[1];
  const createLinkMetadata = t0;
  if (!CreateLinkedBannerContent || !createLinkMetadata)
    return null;
  let t1;
  return $[2] !== CreateLinkedBannerContent || $[3] !== createLinkMetadata ? (t1 = /* @__PURE__ */ jsx(Banner, { tone: "transparent", "data-test-id": "sanity-create-read-only-banner", content: /* @__PURE__ */ jsx(CreateLinkedBannerContent, { metadata: createLinkMetadata }) }), $[2] = CreateLinkedBannerContent, $[3] = createLinkMetadata, $[4] = t1) : t1 = $[4], t1;
}
const TOAST_DELAY = 1e3;
function DocumentNotInReleaseBanner({
  documentId,
  currentRelease,
  value,
  isScheduledRelease
}) {
  const tone = getReleaseTone(currentRelease ?? LATEST), {
    t
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation(), {
    createVersion
  } = useVersionOperations(), [versionCreateState, setVersionCreateState] = useState(), toast = useToast(), handleAddToRelease = useCallback(async () => {
    if (currentRelease._id) {
      setVersionCreateState({
        status: "creating",
        lastUpdate: /* @__PURE__ */ new Date()
      });
      try {
        await createVersion(getReleaseIdFromReleaseDocumentId(currentRelease._id), documentId, value), setVersionCreateState({
          status: "created",
          lastUpdate: /* @__PURE__ */ new Date()
        });
      } catch (err) {
        toast.push({
          status: "error",
          closable: !0,
          title: t("banners.release.error.title"),
          description: t("banners.release.error.description", {
            message: err.message
          })
        }), setVersionCreateState(void 0);
      }
    }
  }, [createVersion, currentRelease._id, documentId, t, toast, value]), now = useCurrentTime(200);
  return useConditionalToast({
    status: "info",
    id: "add-document-to-release",
    enabled: versionCreateState?.status === "created" && now.getTime() - versionCreateState.lastUpdate.getTime() > TOAST_DELAY,
    closable: !0,
    title: t("banners.release.waiting.title"),
    description: t("banners.release.waiting.description")
  }), /* @__PURE__ */ jsx(
    Banner,
    {
      tone,
      content: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Translate, { i18nKey: "banners.release.not-in-release", t, values: {
        title: currentRelease?.metadata?.title || tCore("release.placeholder-untitled-release")
      }, components: {
        VersionBadge: getVersionInlineBadge(currentRelease)
      } }) }),
      action: isScheduledRelease ? void 0 : {
        text: t("banners.release.action.add-to-release"),
        tone,
        disabled: !!versionCreateState,
        onClick: handleAddToRelease,
        mode: "default"
      }
    }
  );
}
function useCurrentTime(updateIntervalMs) {
  const $ = c(4);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ new Date(), $[0] = t0) : t0 = $[0];
  const [currentTime, setCurrentTime] = useState(t0);
  let t1, t2;
  return $[1] !== updateIntervalMs ? (t1 = () => {
    const intervalId = setInterval(() => {
      setCurrentTime(/* @__PURE__ */ new Date());
    }, updateIntervalMs);
    return () => clearInterval(intervalId);
  }, t2 = [updateIntervalMs], $[1] = updateIntervalMs, $[2] = t1, $[3] = t2) : (t1 = $[2], t2 = $[3]), useEffect(t1, t2), currentTime;
}
const ResolvedLiveEdit = defineEvent({
  name: "LiveEdit Draft Resolved",
  version: 1,
  description: "User resolved a draft of a live edit document to continue editing"
}), ObsoleteDraftBanner = (t0) => {
  const $ = c(47), {
    displayed,
    documentId,
    schemaType,
    i18nKey,
    isEditBlocking
  } = t0, {
    t
  } = useTranslation(structureLocaleNamespace), [isPublishing, setPublishing] = useState(!1), [isDiscarding, setDiscarding] = useState(!1), telemetry = useTelemetry(), {
    publish,
    discardChanges
  } = useDocumentOperation(documentId, displayed?._type || "");
  let t1;
  $[0] !== publish || $[1] !== telemetry ? (t1 = () => {
    publish.execute(), setPublishing(!0), telemetry.log(ResolvedLiveEdit, {
      liveEditResolveType: "publish"
    });
  }, $[0] = publish, $[1] = telemetry, $[2] = t1) : t1 = $[2];
  const handlePublish = t1;
  let t2;
  $[3] !== discardChanges || $[4] !== telemetry ? (t2 = () => {
    discardChanges.execute(), setDiscarding(!0), telemetry.log(ResolvedLiveEdit, {
      liveEditResolveType: "discard"
    });
  }, $[3] = discardChanges, $[4] = telemetry, $[5] = t2) : t2 = $[5];
  const handleDiscard = t2;
  let t3;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => () => {
    setPublishing(!1), setDiscarding(!1);
  }, $[6] = t3) : t3 = $[6], useEffect(t3);
  const diffViewRouter = useDiffViewRouter();
  let t4;
  $[7] !== diffViewRouter || $[8] !== displayed?._id || $[9] !== schemaType.name ? (t4 = () => {
    typeof displayed?._id > "u" || diffViewRouter.navigateDiffView({
      mode: "version",
      previousDocument: {
        type: schemaType.name,
        id: getPublishedId(displayed?._id)
      },
      nextDocument: {
        type: schemaType.name,
        id: getDraftId(displayed?._id)
      }
    });
  }, $[7] = diffViewRouter, $[8] = displayed?._id, $[9] = schemaType.name, $[10] = t4) : t4 = $[10];
  const compareDraft = t4;
  let t5;
  $[11] !== schemaType.title ? (t5 = {
    schemaType: schemaType.title
  }, $[11] = schemaType.title, $[12] = t5) : t5 = $[12];
  let t6;
  $[13] !== i18nKey || $[14] !== t || $[15] !== t5 ? (t6 = /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: /* @__PURE__ */ jsx(Translate, { t, i18nKey, values: t5 }) }), $[13] = i18nKey, $[14] = t, $[15] = t5, $[16] = t6) : t6 = $[16];
  let t7;
  $[17] !== t ? (t7 = t("banners.obsolete-draft.actions.compare-draft.text"), $[17] = t, $[18] = t7) : t7 = $[18];
  let t8;
  $[19] !== compareDraft || $[20] !== t7 ? (t8 = /* @__PURE__ */ jsx(Button, { text: t7, mode: "ghost", onClick: compareDraft }), $[19] = compareDraft, $[20] = t7, $[21] = t8) : t8 = $[21];
  let t9;
  $[22] !== t ? (t9 = t("banners.obsolete-draft.actions.publish-draft.text"), $[22] = t, $[23] = t9) : t9 = $[23];
  let t10;
  $[24] !== isEditBlocking || $[25] !== t ? (t10 = isEditBlocking ? {
    content: t("banners.live-edit-draft-banner.publish.tooltip")
  } : {}, $[24] = isEditBlocking, $[25] = t, $[26] = t10) : t10 = $[26];
  let t11;
  $[27] !== handlePublish || $[28] !== isPublishing || $[29] !== t10 || $[30] !== t9 ? (t11 = /* @__PURE__ */ jsx(Button, { onClick: handlePublish, text: t9, tooltipProps: t10, loading: isPublishing, tone: "positive" }), $[27] = handlePublish, $[28] = isPublishing, $[29] = t10, $[30] = t9, $[31] = t11) : t11 = $[31];
  let t12;
  $[32] !== t ? (t12 = t("banners.obsolete-draft.actions.discard-draft.text"), $[32] = t, $[33] = t12) : t12 = $[33];
  let t13;
  $[34] !== isEditBlocking || $[35] !== t ? (t13 = isEditBlocking ? {
    content: t("banners.live-edit-draft-banner.discard.tooltip")
  } : {}, $[34] = isEditBlocking, $[35] = t, $[36] = t13) : t13 = $[36];
  let t14;
  $[37] !== handleDiscard || $[38] !== isDiscarding || $[39] !== t12 || $[40] !== t13 ? (t14 = /* @__PURE__ */ jsx(Button, { onClick: handleDiscard, text: t12, tooltipProps: t13, loading: isDiscarding, tone: "caution" }), $[37] = handleDiscard, $[38] = isDiscarding, $[39] = t12, $[40] = t13, $[41] = t14) : t14 = $[41];
  let t15;
  return $[42] !== t11 || $[43] !== t14 || $[44] !== t6 || $[45] !== t8 ? (t15 = /* @__PURE__ */ jsx(Banner, { content: /* @__PURE__ */ jsxs(Flex, { align: "center", justify: "space-between", gap: 2, children: [
    t6,
    t8,
    t11,
    t14
  ] }), "data-testid": "live-edit-type-banner", icon: ErrorOutlineIcon }), $[42] = t11, $[43] = t14, $[44] = t6, $[45] = t8, $[46] = t15) : t15 = $[46], t15;
};
function OpenReleaseToEditBanner(t0) {
  const $ = c(4), {
    documentId,
    isPinnedDraftOrPublished
  } = t0;
  let t1;
  $[0] !== documentId ? (t1 = {
    documentId
  }, $[0] = documentId, $[1] = t1) : t1 = $[1];
  const onlyHasVersions = useOnlyHasVersions(t1);
  if (!isVersionId(documentId) || !onlyHasVersions || !isPinnedDraftOrPublished)
    return null;
  let t2;
  return $[2] !== documentId ? (t2 = /* @__PURE__ */ jsx(OpenReleaseToEditBannerInner, { documentId }), $[2] = documentId, $[3] = t2) : t2 = $[3], t2;
}
function OpenReleaseToEditBannerInner({
  documentId
}) {
  const {
    data: activeReleases
  } = useActiveReleases(), setPerspective = useSetPerspective(), releaseId = getVersionFromId(documentId) ?? "", currentVersion = useMemo(() => activeReleases.find((version) => version._id.includes(releaseId)), [activeReleases, releaseId]), {
    t: tCore
  } = useTranslation(), {
    data: documentVersions
  } = useDocumentVersions({
    documentId
  }), documentVersionsTitleList = useMemo(() => activeReleases.filter((version_0) => documentVersions.find((release) => {
    const r = getVersionFromId(release) ?? "";
    return getReleaseIdFromReleaseDocumentId(version_0._id) === r;
  })).map((version_1) => version_1.metadata.title || tCore("release.placeholder-untitled-release")), [activeReleases, documentVersions, tCore]), tone = currentVersion && getReleaseTone(currentVersion), {
    t
  } = useTranslation(structureLocaleNamespace), handleGoToEdit = useCallback(async () => {
    setPerspective(releaseId);
  }, [releaseId, setPerspective]);
  return /* @__PURE__ */ jsx(Banner, { tone, paddingY: 0, "data-testid": "open-release-to-edit-banner", content: /* @__PURE__ */ jsxs(Flex, { direction: "row", align: "center", justify: "space-between", flex: 1, children: [
    /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Flex, { direction: "row", gap: 1, children: documentVersionsTitleList.length > 1 ? /* @__PURE__ */ jsx(Translate, { t, i18nKey: "banners.release.navigate-to-edit-description-multiple", components: {
      VersionBadge: () => /* @__PURE__ */ jsxs(VersionInlineBadge, { children: [
        " ",
        documentVersionsTitleList[0]
      ] })
    }, values: {
      count: documentVersionsTitleList.length - 1
    } }) : /* @__PURE__ */ jsx(Translate, { t, i18nKey: "banners.release.navigate-to-edit-description-single", components: {
      VersionBadge: () => /* @__PURE__ */ jsxs(VersionInlineBadge, { children: [
        " ",
        documentVersionsTitleList[0]
      ] })
    } }) }) }),
    /* @__PURE__ */ jsx(Button, { text: t("banners.release.action.open-to-edit"), tone, onClick: handleGoToEdit })
  ] }) });
}
function RevisionNotFoundBanner() {
  const $ = c(4), {
    revisionNotFound
  } = useDocumentPane(), {
    t
  } = useTranslation(structureLocaleNamespace);
  if (!revisionNotFound)
    return null;
  let t0;
  $[0] !== t ? (t0 = t("banners.revision-not-found.description"), $[0] = t, $[1] = t0) : t0 = $[1];
  let t1;
  return $[2] !== t0 ? (t1 = /* @__PURE__ */ jsx(Banner, { tone: "caution", "data-test-id": "revision-not-found-banner", icon: WarningOutlineIcon, content: /* @__PURE__ */ jsx(Text, { size: 1, children: t0 }) }), $[2] = t0, $[3] = t1) : t1 = $[3], t1;
}
function ScheduledReleaseBanner(t0) {
  const $ = c(12), {
    currentRelease
  } = t0, t1 = currentRelease ?? LATEST;
  let t2;
  $[0] !== t1 ? (t2 = getReleaseTone(t1), $[0] = t1, $[1] = t2) : t2 = $[1];
  const tone = t2, {
    t: tCore
  } = useTranslation();
  let t3;
  $[2] !== currentRelease ? (t3 = formatRelativeLocalePublishDate(currentRelease), $[2] = currentRelease, $[3] = t3) : t3 = $[3];
  let t4;
  $[4] !== t3 ? (t4 = {
    date: t3
  }, $[4] = t3, $[5] = t4) : t4 = $[5];
  let t5;
  $[6] !== t4 || $[7] !== tCore ? (t5 = /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Translate, { t: tCore, i18nKey: "release.banner.scheduled-for-publishing-on", values: t4 }) }), $[6] = t4, $[7] = tCore, $[8] = t5) : t5 = $[8];
  let t6;
  return $[9] !== t5 || $[10] !== tone ? (t6 = /* @__PURE__ */ jsx(Banner, { tone, icon: LockIcon, content: t5 }), $[9] = t5, $[10] = tone, $[11] = t6) : t6 = $[11], t6;
}
function UnpublishedDocumentBanner() {
  const $ = c(13), {
    value
  } = useDocumentPane(), {
    selectedPerspective
  } = usePerspective(), willBeUnpublished = isGoingToUnpublish(value), {
    t
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation();
  if (isReleaseDocument(selectedPerspective) && willBeUnpublished) {
    let t0;
    $[0] !== selectedPerspective.metadata?.title || $[1] !== tCore ? (t0 = selectedPerspective.metadata?.title || tCore("release.placeholder-untitled-release"), $[0] = selectedPerspective.metadata?.title, $[1] = tCore, $[2] = t0) : t0 = $[2];
    const title = t0;
    let t1;
    $[3] !== title ? (t1 = {
      title
    }, $[3] = title, $[4] = t1) : t1 = $[4];
    let t2;
    $[5] !== selectedPerspective ? (t2 = getVersionInlineBadge(selectedPerspective), $[5] = selectedPerspective, $[6] = t2) : t2 = $[6];
    let t3;
    $[7] !== t2 ? (t3 = {
      VersionBadge: t2
    }, $[7] = t2, $[8] = t3) : t3 = $[8];
    let t4;
    return $[9] !== t || $[10] !== t1 || $[11] !== t3 ? (t4 = /* @__PURE__ */ jsx(Banner, { tone: "critical", content: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Translate, { t, i18nKey: "banners.unpublished-release-banner.text", values: t1, components: t3 }) }), icon: UnpublishIcon }), $[9] = t, $[10] = t1, $[11] = t3, $[12] = t4) : t4 = $[12], t4;
  }
  return null;
}
const TitleContainer = styled(Stack)`
  ${({
  theme
}) => css`
      @supports not (container-type: inline-size) {
        display: none !important;
      }

      container-type: inline-size;

      [data-heading] {
        font-size: ${theme.sanity.fonts.heading.sizes[4].fontSize}px;
        line-height: ${theme.sanity.fonts.heading.sizes[4].lineHeight}px;
        overflow-wrap: break-word;
        text-wrap: pretty;
      }

      @container (max-width: 560px) {
        [data-heading] {
          font-size: ${theme.sanity.fonts.heading.sizes[3].fontSize}px;
          line-height: ${theme.sanity.fonts.heading.sizes[3].lineHeight}px;
        }
      }

      @container (max-width: 420px) {
        [data-heading] {
          font-size: ${theme.sanity.fonts.heading.sizes[2].fontSize}px;
          line-height: ${theme.sanity.fonts.heading.sizes[2].lineHeight}px;
        }
      }
    `}
`, FormHeader = (t0) => {
  const $ = c(14), {
    documentId,
    schemaType,
    title
  } = t0, isSingleton = documentId === schemaType.name, description = schemaType.description, {
    t
  } = useTranslation(structureLocaleNamespace);
  if (schemaType.__experimental_formPreviewTitle === !1)
    return null;
  let t1;
  $[0] !== description || $[1] !== isSingleton || $[2] !== schemaType.name || $[3] !== schemaType.title ? (t1 = !isSingleton && /* @__PURE__ */ jsxs(Inline, { space: 1, children: [
    /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: schemaType.title ?? schemaType.name }),
    description && /* @__PURE__ */ jsx(Tooltip, { content: description, placement: "right", children: /* @__PURE__ */ jsx(InfoOutlineIcon, { "data-testid": "schema-description-icon" }) })
  ] }), $[0] = description, $[1] = isSingleton, $[2] = schemaType.name, $[3] = schemaType.title, $[4] = t1) : t1 = $[4];
  const t2 = !title;
  let t3;
  $[5] !== t || $[6] !== title ? (t3 = title ?? t("document-view.form-view.form-title-fallback"), $[5] = t, $[6] = title, $[7] = t3) : t3 = $[7];
  let t4;
  $[8] !== t2 || $[9] !== t3 ? (t4 = /* @__PURE__ */ jsx(Heading, { as: "h2", "data-heading": !0, muted: t2, "data-testid": "document-panel-document-title", children: t3 }), $[8] = t2, $[9] = t3, $[10] = t4) : t4 = $[10];
  let t5;
  return $[11] !== t1 || $[12] !== t4 ? (t5 = /* @__PURE__ */ jsxs(TitleContainer, { marginBottom: 6, space: 4, children: [
    t1,
    t4
  ] }), $[11] = t1, $[12] = t4, $[13] = t5) : t5 = $[13], t5;
}, preventDefault = (ev) => ev.preventDefault(), FormView = forwardRef(function(props, ref) {
  const $ = c(74), {
    hidden,
    margins
  } = props, {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    editState,
    documentId,
    documentType,
    fieldActions,
    onChange,
    validation,
    ready,
    formState,
    onFocus,
    connectionState,
    onBlur,
    onSetCollapsedPath,
    onPathOpen,
    onSetCollapsedFieldSet,
    onSetActiveFieldGroup,
    openPath
  } = useDocumentPane(), {
    selectedReleaseId
  } = usePerspective(), documentStore = useDocumentStore(), presence = useDocumentPresence(documentId), {
    title
  } = useDocumentTitle(), [patchChannel] = useState(_temp$e), isLocked = editState?.transactionSyncLock?.enabled, {
    t
  } = useTranslation(structureLocaleNamespace);
  let t0, t1;
  $[0] !== t ? (t1 = t("document-view.form-view.sync-lock-toast.title"), $[0] = t, $[1] = t1) : t1 = $[1];
  let t2;
  $[2] !== t ? (t2 = t("document-view.form-view.sync-lock-toast.description"), $[2] = t, $[3] = t2) : t2 = $[3];
  let t3;
  $[4] !== isLocked || $[5] !== t1 || $[6] !== t2 ? (t3 = {
    id: "sync-lock",
    status: "warning",
    enabled: isLocked,
    title: t1,
    description: t2,
    closable: !0
  }, $[4] = isLocked, $[5] = t1, $[6] = t2, $[7] = t3) : t3 = $[7], t0 = t3, useConditionalToast(t0);
  let t4;
  $[8] !== documentId || $[9] !== documentStore.pair || $[10] !== documentType || $[11] !== patchChannel || $[12] !== selectedReleaseId ? (t4 = () => {
    const sub = documentStore.pair.documentEvents(documentId, documentType, selectedReleaseId).pipe(tap((event) => {
      event.type === "mutation" && patchChannel.publish(prepareMutationEvent(event)), event.type === "rebase" && patchChannel.publish(prepareRebaseEvent(event));
    })).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, $[8] = documentId, $[9] = documentStore.pair, $[10] = documentType, $[11] = patchChannel, $[12] = selectedReleaseId, $[13] = t4) : t4 = $[13];
  let t5;
  $[14] !== documentId || $[15] !== documentStore || $[16] !== documentType || $[17] !== patchChannel || $[18] !== selectedReleaseId ? (t5 = [documentId, documentStore, documentType, patchChannel, selectedReleaseId], $[14] = documentId, $[15] = documentStore, $[16] = documentType, $[17] = patchChannel, $[18] = selectedReleaseId, $[19] = t5) : t5 = $[19], useEffect(t4, t5);
  const hasRev = !!value?._rev;
  let t6;
  $[20] !== patchChannel || $[21] !== value ? (t6 = () => {
    patchChannel.publish({
      type: "mutation",
      patches: [],
      snapshot: value
    });
  }, $[20] = patchChannel, $[21] = value, $[22] = t6) : t6 = $[22];
  const handleInitialValue = useEffectEvent(t6);
  let t7;
  $[23] !== handleInitialValue || $[24] !== hasRev ? (t7 = () => {
    hasRev && handleInitialValue();
  }, $[23] = handleInitialValue, $[24] = hasRev, $[25] = t7) : t7 = $[25];
  let t8;
  $[26] !== hasRev ? (t8 = [hasRev], $[26] = hasRev, $[27] = t8) : t8 = $[27], useEffect(t7, t8);
  const [formRef, setFormRef] = useState(null), [focusedFirstDescendant, setFocusedFirstDescendant] = useState(!1);
  let t9;
  $[28] !== focusedFirstDescendant || $[29] !== formRef || $[30] !== formState?.focusPath.length || $[31] !== ready ? (t9 = () => {
    !focusedFirstDescendant && ready && !formState?.focusPath.length && formRef && (setFocusedFirstDescendant(!0), focusFirstDescendant(formRef));
  }, $[28] = focusedFirstDescendant, $[29] = formRef, $[30] = formState?.focusPath.length, $[31] = ready, $[32] = t9) : t9 = $[32];
  const t10 = formState?.focusPath.length;
  let t11;
  $[33] !== focusedFirstDescendant || $[34] !== formRef || $[35] !== ready || $[36] !== t10 ? (t11 = [focusedFirstDescendant, formRef, t10, ready], $[33] = focusedFirstDescendant, $[34] = formRef, $[35] = ready, $[36] = t10, $[37] = t11) : t11 = $[37], useEffect(t9, t11);
  let t12;
  $[38] !== ref ? (t12 = (node) => {
    setFormRef(node), typeof ref == "function" ? ref(node) : ref && (ref.current = node);
  }, $[38] = ref, $[39] = t12) : t12 = $[39];
  const setRef = t12, isReadOnly = connectionState === "reconnecting" || formState?.readOnly || !editState?.ready, t13 = isReadOnly ? "true" : void 0;
  let t14;
  $[40] !== collapsedFieldSets || $[41] !== collapsedPaths || $[42] !== connectionState || $[43] !== documentId || $[44] !== editState?.draft || $[45] !== editState?.published || $[46] !== fieldActions || $[47] !== formState || $[48] !== hidden || $[49] !== isReadOnly || $[50] !== onBlur || $[51] !== onChange || $[52] !== onFocus || $[53] !== onPathOpen || $[54] !== onSetActiveFieldGroup || $[55] !== onSetCollapsedFieldSet || $[56] !== onSetCollapsedPath || $[57] !== openPath || $[58] !== patchChannel || $[59] !== presence || $[60] !== t || $[61] !== title || $[62] !== validation ? (t14 = connectionState === "connecting" && !editState?.draft && !editState?.published ? /* @__PURE__ */ jsx(Delay, { ms: 300, children: /* @__PURE__ */ jsxs(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: [
    /* @__PURE__ */ jsx(Spinner, { muted: !0 }),
    /* @__PURE__ */ jsx(Box, { marginTop: 3, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, size: 1, children: t("document-view.form-view.loading") }) })
  ] }) }) : formState === null || hidden ? /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { children: t("document-view.form-view.form-hidden") }) }) : /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(FormHeader, { documentId, schemaType: formState.schemaType, title }),
    /* @__PURE__ */ jsx(FormBuilder, { __internal_fieldActions: fieldActions, __internal_patchChannel: patchChannel, changed: formState.changed, collapsedFieldSets, collapsedPaths, focused: formState.focused, focusPath: formState.focusPath, groups: formState.groups, id: "root", members: formState.members, onChange, onFieldGroupSelect: onSetActiveFieldGroup, onPathBlur: onBlur, onPathFocus: onFocus, onPathOpen, onSetFieldSetCollapsed: onSetCollapsedFieldSet, onSetPathCollapsed: onSetCollapsedPath, openPath, presence, readOnly: isReadOnly, schemaType: formState.schemaType, validation, value: formState.value })
  ] }), $[40] = collapsedFieldSets, $[41] = collapsedPaths, $[42] = connectionState, $[43] = documentId, $[44] = editState?.draft, $[45] = editState?.published, $[46] = fieldActions, $[47] = formState, $[48] = hidden, $[49] = isReadOnly, $[50] = onBlur, $[51] = onChange, $[52] = onFocus, $[53] = onPathOpen, $[54] = onSetActiveFieldGroup, $[55] = onSetCollapsedFieldSet, $[56] = onSetCollapsedPath, $[57] = openPath, $[58] = patchChannel, $[59] = presence, $[60] = t, $[61] = title, $[62] = validation, $[63] = t14) : t14 = $[63];
  let t15;
  $[64] !== setRef || $[65] !== t13 || $[66] !== t14 ? (t15 = /* @__PURE__ */ jsx(Box, { as: "form", onSubmit: preventDefault, ref: setRef, "data-testid": "form-view", "data-read-only": t13, children: t14 }), $[64] = setRef, $[65] = t13, $[66] = t14, $[67] = t15) : t15 = $[67];
  let t16;
  $[68] !== margins || $[69] !== t15 ? (t16 = /* @__PURE__ */ jsx(PresenceOverlay, { margins, children: t15 }), $[68] = margins, $[69] = t15, $[70] = t16) : t16 = $[70];
  let t17;
  return $[71] !== hidden || $[72] !== t16 ? (t17 = /* @__PURE__ */ jsx(Container$1, { hidden, paddingX: 4, paddingTop: 5, paddingBottom: 9, sizing: "border", width: 1, children: t16 }), $[71] = hidden, $[72] = t16, $[73] = t17) : t17 = $[73], t17;
});
function prepareMutationEvent(event) {
  const patches = event.mutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "mutation",
    snapshot: event.document,
    patches: fromMutationPatches(event.origin, patches)
  };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map((mut) => mut.patch).filter(Boolean), localPatches = event.localMutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "rebase",
    snapshot: event.document,
    patches: fromMutationPatches("remote", remotePatches).concat(fromMutationPatches("local", localPatches))
  };
}
function _temp$e() {
  return createPatchChannel();
}
function DocumentHeaderTabs() {
  const $ = c(11), {
    activeViewId,
    paneKey,
    views
  } = useDocumentPane(), tabPanelId = `${paneKey}tabpanel`;
  let t0;
  if ($[0] !== activeViewId || $[1] !== paneKey || $[2] !== tabPanelId || $[3] !== views) {
    let t12;
    $[5] !== activeViewId || $[6] !== paneKey || $[7] !== tabPanelId ? (t12 = (view, index) => /* @__PURE__ */ jsx(DocumentHeaderTab, { icon: view.icon, id: `${paneKey}tab-${view.id}`, isActive: activeViewId === view.id, label: view.title, tabPanelId, viewId: index === 0 ? null : view.id ?? null }, view.id), $[5] = activeViewId, $[6] = paneKey, $[7] = tabPanelId, $[8] = t12) : t12 = $[8], t0 = views.map(t12), $[0] = activeViewId, $[1] = paneKey, $[2] = tabPanelId, $[3] = views, $[4] = t0;
  } else
    t0 = $[4];
  let t1;
  return $[9] !== t0 ? (t1 = /* @__PURE__ */ jsx(TabList, { space: 1, children: t0 }), $[9] = t0, $[10] = t1) : t1 = $[10], t1;
}
function DocumentHeaderTab(props) {
  const $ = c(20);
  let icon, id, isActive, label, rest, tabPanelId, viewId;
  $[0] !== props ? ({
    icon,
    id,
    isActive,
    label,
    tabPanelId,
    viewId,
    ...rest
  } = props, $[0] = props, $[1] = icon, $[2] = id, $[3] = isActive, $[4] = label, $[5] = rest, $[6] = tabPanelId, $[7] = viewId) : (icon = $[1], id = $[2], isActive = $[3], label = $[4], rest = $[5], tabPanelId = $[6], viewId = $[7]);
  const {
    ready,
    editState
  } = useDocumentPane(), {
    setView
  } = usePaneRouter();
  let t0;
  $[8] !== setView || $[9] !== viewId ? (t0 = () => setView(viewId), $[8] = setView, $[9] = viewId, $[10] = t0) : t0 = $[10];
  const handleClick = t0, t1 = !ready && !editState?.draft && !editState?.published;
  let t2;
  return $[11] !== handleClick || $[12] !== icon || $[13] !== id || $[14] !== isActive || $[15] !== label || $[16] !== rest || $[17] !== t1 || $[18] !== tabPanelId ? (t2 = /* @__PURE__ */ jsx(Tab, { ...rest, "aria-controls": tabPanelId, disabled: t1, icon, id, label, onClick: handleClick, selected: isActive }), $[11] = handleClick, $[12] = icon, $[13] = id, $[14] = isActive, $[15] = label, $[16] = rest, $[17] = t1, $[18] = tabPanelId, $[19] = t2) : t2 = $[19], t2;
}
function DocumentHeaderTitle() {
  const $ = c(22), {
    connectionState,
    schemaType,
    title,
    value: documentValue
  } = useDocumentPane(), subscribed = !!documentValue;
  let t0;
  $[0] !== documentValue || $[1] !== schemaType || $[2] !== subscribed ? (t0 = {
    enabled: subscribed,
    schemaType,
    value: documentValue
  }, $[0] = documentValue, $[1] = schemaType, $[2] = subscribed, $[3] = t0) : t0 = $[3];
  const {
    error,
    value
  } = unstable_useValuePreview(t0), {
    t
  } = useTranslation(structureLocaleNamespace);
  if (connectionState === "connecting" && !subscribed) {
    let t12;
    return $[4] === Symbol.for("react.memo_cache_sentinel") ? (t12 = /* @__PURE__ */ jsx(Fragment, {}), $[4] = t12) : t12 = $[4], t12;
  }
  if (title) {
    let t12;
    return $[5] !== title ? (t12 = /* @__PURE__ */ jsx(Fragment, { children: title }), $[5] = title, $[6] = t12) : t12 = $[6], t12;
  }
  if (!documentValue) {
    const t12 = schemaType?.title || schemaType?.name;
    let t22;
    $[7] !== t || $[8] !== t12 ? (t22 = t("panes.document-header-title.new.text", {
      schemaType: t12
    }), $[7] = t, $[8] = t12, $[9] = t22) : t22 = $[9];
    let t3;
    return $[10] !== t22 ? (t3 = /* @__PURE__ */ jsx(Fragment, { children: t22 }), $[10] = t22, $[11] = t3) : t3 = $[11], t3;
  }
  if (error) {
    let t12;
    $[12] !== error.message || $[13] !== t ? (t12 = t("panes.document-header-title.error.text", {
      error: error.message
    }), $[12] = error.message, $[13] = t, $[14] = t12) : t12 = $[14];
    let t22;
    return $[15] !== t12 ? (t22 = /* @__PURE__ */ jsx(Fragment, { children: t12 }), $[15] = t12, $[16] = t22) : t22 = $[16], t22;
  }
  let t1;
  $[17] !== t || $[18] !== value?.title ? (t1 = value?.title || /* @__PURE__ */ jsx("span", { style: {
    color: "var(--card-muted-fg-color)"
  }, children: t("panes.document-header-title.untitled.text") }), $[17] = t, $[18] = value?.title, $[19] = t1) : t1 = $[19];
  let t2;
  return $[20] !== t1 ? (t2 = /* @__PURE__ */ jsx(Fragment, { children: t1 }), $[20] = t1, $[21] = t2) : t2 = $[21], t2;
}
const FavoriteToggle = (t0) => {
  const $ = c(16);
  let documentExists, props;
  $[0] !== t0 ? ({
    documentExists,
    ...props
  } = t0, $[0] = t0, $[1] = documentExists, $[2] = props) : (documentExists = $[1], props = $[2]);
  const {
    isFavorited,
    isReady,
    favorite,
    unfavorite
  } = useManageFavorite(props), {
    t
  } = useTranslation(structureLocaleNamespace), t1 = isFavorited ? "document.favorites.remove-from-favorites" : "document.favorites.add-to-favorites";
  let t2;
  $[3] !== t || $[4] !== t1 ? (t2 = t(t1), $[3] = t, $[4] = t1, $[5] = t2) : t2 = $[5];
  const description = t2, t3 = isFavorited ? unfavorite : favorite, t4 = !isReady || !documentExists;
  let t5;
  $[6] !== description ? (t5 = {
    content: /* @__PURE__ */ jsx(Text, { size: 1, children: description }),
    placement: "right"
  }, $[6] = description, $[7] = t5) : t5 = $[7];
  let t6;
  $[8] !== isFavorited ? (t6 = /* @__PURE__ */ jsx(Text, { size: 1, children: isFavorited ? /* @__PURE__ */ jsx(StarFilledIcon, {}) : /* @__PURE__ */ jsx(StarIcon, {}) }), $[8] = isFavorited, $[9] = t6) : t6 = $[9];
  let t7;
  return $[10] !== description || $[11] !== t3 || $[12] !== t4 || $[13] !== t5 || $[14] !== t6 ? (t7 = /* @__PURE__ */ jsx(Button, { mode: "bleed", onClick: t3, disabled: t4, "aria-label": description, "aria-live": "assertive", tooltipProps: t5, children: t6 }), $[10] = description, $[11] = t3, $[12] = t4, $[13] = t5, $[14] = t6, $[15] = t7) : t7 = $[15], t7;
}, DocumentPanelSubHeader = memo(function() {
  const $ = c(26), {
    editState,
    connectionState,
    views,
    documentId,
    displayed
  } = useDocumentPane(), {
    features
  } = useStructureTool(), {
    index,
    BackLink: BackLink2
  } = usePaneRouter(), {
    activeWorkspace
  } = useActiveWorkspace();
  let t0;
  $[0] !== documentId ? (t0 = getPublishedId(documentId), $[0] = documentId, $[1] = t0) : t0 = $[1];
  const publishedDocId = t0, showTabs = views.length > 1, {
    collapsed,
    isLast
  } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, showBackButton = features.backButton && index > 0, {
    t
  } = useTranslation(structureLocaleNamespace);
  let t1, t2;
  $[2] === Symbol.for("react.memo_cache_sentinel") ? (t2 = /* @__PURE__ */ jsx(DocumentHeaderTitle, {}), $[2] = t2) : t2 = $[2], t1 = t2;
  const title = t1;
  let t3, t4;
  $[3] !== showTabs ? (t4 = showTabs && /* @__PURE__ */ jsx(DocumentHeaderTabs, {}), $[3] = showTabs, $[4] = t4) : t4 = $[4], t3 = t4;
  const tabs = t3;
  let t5, t6;
  $[5] !== BackLink2 || $[6] !== showBackButton || $[7] !== t ? (t6 = showBackButton && /* @__PURE__ */ jsx(Button, { as: BackLink2, "data-as": "a", icon: ArrowLeftIcon, mode: "bleed", tooltipProps: {
    content: t("pane-header.back-button.text")
  } }), $[5] = BackLink2, $[6] = showBackButton, $[7] = t, $[8] = t6) : t6 = $[8], t5 = t6;
  const backButton = t5, t7 = displayed?._type ?? "";
  let t8;
  $[9] !== activeWorkspace.dataset || $[10] !== activeWorkspace.projectId ? (t8 = [activeWorkspace.projectId, activeWorkspace.dataset], $[9] = activeWorkspace.dataset, $[10] = activeWorkspace.projectId, $[11] = t8) : t8 = $[11];
  const t9 = t8.join("."), t10 = (editState?.ready && (editState.version ?? editState.draft ?? editState.published) !== null) ?? !1;
  let t11;
  $[12] !== activeWorkspace.dataset || $[13] !== activeWorkspace.name || $[14] !== activeWorkspace.projectId || $[15] !== publishedDocId || $[16] !== t10 || $[17] !== t7 || $[18] !== t9 ? (t11 = /* @__PURE__ */ jsx(CapabilityGate, { capability: "comlink", condition: "available", children: /* @__PURE__ */ jsx(FavoriteToggle, { resourceType: "studio", documentId: publishedDocId, documentType: t7, resourceId: t9, schemaName: activeWorkspace.name, projectId: activeWorkspace.projectId, dataset: activeWorkspace.dataset, documentExists: t10 }) }), $[12] = activeWorkspace.dataset, $[13] = activeWorkspace.name, $[14] = activeWorkspace.projectId, $[15] = publishedDocId, $[16] = t10, $[17] = t7, $[18] = t9, $[19] = t11) : t11 = $[19];
  const favoriteToggle = t11, t12 = connectionState === "connecting" && !editState?.draft && !editState?.published;
  let t13;
  return $[20] !== backButton || $[21] !== favoriteToggle || $[22] !== t12 || $[23] !== tabIndex || $[24] !== tabs ? (t13 = /* @__PURE__ */ jsx(PaneHeader$1, { loading: t12, title, tabs, tabIndex, backButton, appendTitle: favoriteToggle }), $[20] = backButton, $[21] = favoriteToggle, $[22] = t12, $[23] = tabIndex, $[24] = tabs, $[25] = t13) : t13 = $[25], t13;
}), DocumentBox = styled(Box)({
  position: "relative"
}), Scroller$4 = styled(ScrollContainer)(({
  $disabled
}) => $disabled ? {
  height: "100%"
} : css`
    height: 100%;
    overflow: auto;
    position: relative;
    scroll-behavior: smooth;
    outline: none;
  `), DocumentPanel = function(props) {
  const $ = c(102), {
    footerHeight,
    headerHeight,
    isInspectOpen,
    rootElement,
    setDocumentPanelPortalElement,
    footer
  } = props, {
    activeViewId,
    displayed,
    documentId,
    editState,
    inspector,
    value,
    views,
    ready,
    schemaType,
    permissions,
    isPermissionsLoading
  } = useDocumentPane();
  let t0;
  if ($[0] !== value) {
    const createLinkMetadata = getSanityCreateLinkMetadata(value);
    t0 = isSanityCreateLinked(createLinkMetadata), $[0] = value, $[1] = t0;
  } else
    t0 = $[1];
  const showCreateBanner = t0, {
    params
  } = usePaneRouter(), {
    collapsed: layoutCollapsed
  } = usePaneLayout(), {
    collapsed
  } = usePane(), parentPortal = usePortal(), {
    features
  } = useStructureTool(), [_portalElement, setPortalElement] = useState(null), [documentScrollElement, setDocumentScrollElement] = useState(null), formContainerElement = useRef(null), workspace = useWorkspace(), requiredPermission = value._createdAt ? "update" : "create";
  let t1, t2;
  $[2] !== activeViewId || $[3] !== views ? (t2 = views.find((view) => view.id === activeViewId) || views[0] || {
    type: "form"
  }, $[2] = activeViewId, $[3] = views, $[4] = t2) : t2 = $[4], t1 = t2;
  const activeView = t1, portalElement = features.splitPanes && _portalElement || parentPortal.element;
  let t3;
  bb0: {
    if (layoutCollapsed) {
      const t43 = headerHeight || 0, t52 = footerHeight ? footerHeight + 2 : 2;
      let t62;
      $[5] !== t43 || $[6] !== t52 ? (t62 = [t43, 0, t52, 0], $[5] = t43, $[6] = t52, $[7] = t62) : t62 = $[7], t3 = t62;
      break bb0;
    }
    let t42;
    $[8] === Symbol.for("react.memo_cache_sentinel") ? (t42 = [0, 0, 2, 0], $[8] = t42) : t42 = $[8], t3 = t42;
  }
  const margins = t3, formViewHidden = activeView.type !== "form";
  let t4;
  $[9] !== activeView.component || $[10] !== activeView.options || $[11] !== activeView.type || $[12] !== displayed || $[13] !== documentId || $[14] !== editState?.draft || $[15] !== editState?.published || $[16] !== schemaType || $[17] !== value ? (t4 = () => {
    if (activeView.type === "component" && activeView.component) {
      const ActiveViewComponent = activeView.component;
      return /* @__PURE__ */ jsx(ActiveViewComponent, { document: {
        draft: editState?.draft || null,
        displayed: displayed || value,
        historical: displayed,
        published: editState?.published || null
      }, documentId, options: activeView.options, schemaType });
    }
    return !1;
  }, $[9] = activeView.component, $[10] = activeView.options, $[11] = activeView.type, $[12] = displayed, $[13] = documentId, $[14] = editState?.draft, $[15] = editState?.published, $[16] = schemaType, $[17] = value, $[18] = t4) : t4 = $[18];
  let t5;
  $[19] !== t4 ? (t5 = t4(), $[19] = t4, $[20] = t5) : t5 = $[20];
  const activeViewNode = t5;
  let t6;
  $[21] !== documentScrollElement ? (t6 = () => {
    documentScrollElement?.scrollTo && documentScrollElement.scrollTo(0, 0);
  }, $[21] = documentScrollElement, $[22] = t6) : t6 = $[22];
  let t7;
  $[23] !== documentId || $[24] !== documentScrollElement ? (t7 = [documentId, documentScrollElement], $[23] = documentId, $[24] = documentScrollElement, $[25] = t7) : t7 = $[25], useEffect(t6, t7);
  let t8, t9;
  $[26] !== portalElement || $[27] !== setDocumentPanelPortalElement ? (t8 = () => {
    portalElement && setDocumentPanelPortalElement(portalElement);
  }, t9 = [portalElement, setDocumentPanelPortalElement], $[26] = portalElement, $[27] = setDocumentPanelPortalElement, $[28] = t8, $[29] = t9) : (t8 = $[28], t9 = $[29]), useEffect(t8, t9);
  let t10, t11;
  $[30] !== displayed || $[31] !== isInspectOpen || $[32] !== value ? (t11 = isInspectOpen ? /* @__PURE__ */ jsx(InspectDialog, { value: displayed || value }) : null, $[30] = displayed, $[31] = isInspectOpen, $[32] = value, $[33] = t11) : t11 = $[33], t10 = t11;
  const inspectDialog = t10, showInspector = !!(!collapsed && inspector), {
    selectedPerspective,
    selectedReleaseId
  } = usePerspective();
  let t12;
  bb1: {
    if (params?.historyVersion) {
      let t133;
      $[34] === Symbol.for("react.memo_cache_sentinel") ? (t133 = /* @__PURE__ */ jsx(ArchivedReleaseDocumentBanner, {}), $[34] = t133) : t133 = $[34], t12 = t133;
      break bb1;
    }
    let t132;
    $[35] !== selectedPerspective ? (t132 = isReleaseDocument(selectedPerspective) && isReleaseScheduledOrScheduling(selectedPerspective), $[35] = selectedPerspective, $[36] = t132) : t132 = $[36];
    const isScheduledRelease = t132, documentInScheduledRelease = !!(isScheduledRelease && displayed?._id && getVersionFromId(displayed?._id) === selectedReleaseId);
    let isSelectedPerspectiveWriteable, t142;
    if ($[37] !== editState || $[38] !== schemaType || $[39] !== selectedPerspective || $[40] !== workspace.document.drafts.enabled ? (isSelectedPerspectiveWriteable = isPerspectiveWriteable({
      selectedPerspective,
      isDraftModelEnabled: workspace.document.drafts.enabled,
      schemaType
    }), t142 = mustChooseNewDocumentDestination({
      isSelectedPerspectiveWriteable,
      editState
    }), $[37] = editState, $[38] = schemaType, $[39] = selectedPerspective, $[40] = workspace.document.drafts.enabled, $[41] = isSelectedPerspectiveWriteable, $[42] = t142) : (isSelectedPerspectiveWriteable = $[41], t142 = $[42]), t142) {
      let t153;
      $[43] !== isSelectedPerspectiveWriteable.reason || $[44] !== isSelectedPerspectiveWriteable.result || $[45] !== schemaType || $[46] !== selectedPerspective ? (t153 = !isSelectedPerspectiveWriteable.result && /* @__PURE__ */ jsx(ChooseNewDocumentDestinationBanner, { schemaType, selectedPerspective, reason: isSelectedPerspectiveWriteable.reason }), $[43] = isSelectedPerspectiveWriteable.reason, $[44] = isSelectedPerspectiveWriteable.result, $[45] = schemaType, $[46] = selectedPerspective, $[47] = t153) : t153 = $[47], t12 = t153;
      break bb1;
    }
    if (documentInScheduledRelease) {
      const t153 = selectedPerspective;
      let t162;
      $[48] !== t153 ? (t162 = /* @__PURE__ */ jsx(ScheduledReleaseBanner, { currentRelease: t153 }), $[48] = t153, $[49] = t162) : t162 = $[49], t12 = t162;
      break bb1;
    }
    let t152;
    $[50] !== selectedPerspective ? (t152 = isSystemBundle(selectedPerspective), $[50] = selectedPerspective, $[51] = t152) : t152 = $[51];
    const isPinnedDraftOrPublish = t152;
    if (displayed?._id && getVersionFromId(displayed._id) !== selectedReleaseId && ready && !isPinnedDraftOrPublish && isNewDocument(editState) === !1) {
      const t162 = selectedPerspective, t172 = displayed || void 0;
      let t182;
      $[52] !== isScheduledRelease || $[53] !== t162 || $[54] !== t172 || $[55] !== value._id ? (t182 = /* @__PURE__ */ jsx(DocumentNotInReleaseBanner, { documentId: value._id, currentRelease: t162, value: t172, isScheduledRelease }), $[52] = isScheduledRelease, $[53] = t162, $[54] = t172, $[55] = value._id, $[56] = t182) : t182 = $[56], t12 = t182;
      break bb1;
    }
    const displayedHasObsoleteDraft = hasObsoleteDraft({
      editState,
      workspace,
      schemaType
    });
    if (activeView.type === "form" && !selectedReleaseId && displayedHasObsoleteDraft.result) {
      if (displayedHasObsoleteDraft.reason === "DRAFT_MODEL_INACTIVE") {
        let t162;
        $[57] !== displayed || $[58] !== documentId || $[59] !== schemaType ? (t162 = /* @__PURE__ */ jsx(ObsoleteDraftBanner, { displayed, documentId, schemaType, i18nKey: "banners.obsolete-draft.draft-model-inactive.text" }), $[57] = displayed, $[58] = documentId, $[59] = schemaType, $[60] = t162) : t162 = $[60], t12 = t162;
        break bb1;
      }
      if (displayedHasObsoleteDraft.reason === "LIVE_EDIT_ACTIVE") {
        let t162;
        $[61] !== displayed || $[62] !== documentId || $[63] !== schemaType ? (t162 = /* @__PURE__ */ jsx(ObsoleteDraftBanner, { displayed, documentId, schemaType, i18nKey: "banners.live-edit-draft-banner.text", isEditBlocking: !0 }), $[61] = displayed, $[62] = documentId, $[63] = schemaType, $[64] = t162) : t162 = $[64], t12 = t162;
        break bb1;
      }
    }
    if (activeView.type !== "form" || isPermissionsLoading) {
      t12 = null;
      break bb1;
    }
    let t16;
    $[65] !== showCreateBanner ? (t16 = showCreateBanner && /* @__PURE__ */ jsx(CreateLinkedBanner, {}), $[65] = showCreateBanner, $[66] = t16) : t16 = $[66];
    let t17;
    $[67] !== permissions?.granted || $[68] !== requiredPermission ? (t17 = !permissions?.granted && /* @__PURE__ */ jsx(InsufficientPermissionBanner, { requiredPermission }), $[67] = permissions?.granted, $[68] = requiredPermission, $[69] = t17) : t17 = $[69];
    let t18, t19, t20, t21, t22, t23;
    $[70] === Symbol.for("react.memo_cache_sentinel") ? (t18 = /* @__PURE__ */ jsx(RevisionNotFoundBanner, {}), t19 = /* @__PURE__ */ jsx(ReferenceChangedBanner, {}), t20 = /* @__PURE__ */ jsx(DeprecatedDocumentTypeBanner, {}), t21 = /* @__PURE__ */ jsx(CanvasLinkedBanner, {}), t22 = /* @__PURE__ */ jsx(DeletedDocumentBanners, {}), t23 = /* @__PURE__ */ jsx(UnpublishedDocumentBanner, {}), $[70] = t18, $[71] = t19, $[72] = t20, $[73] = t21, $[74] = t22, $[75] = t23) : (t18 = $[70], t19 = $[71], t20 = $[72], t21 = $[73], t22 = $[74], t23 = $[75]);
    const t24 = displayed?._id ?? documentId;
    let t25;
    $[76] !== isPinnedDraftOrPublish || $[77] !== t24 ? (t25 = /* @__PURE__ */ jsx(OpenReleaseToEditBanner, { documentId: t24, isPinnedDraftOrPublished: isPinnedDraftOrPublish }), $[76] = isPinnedDraftOrPublish, $[77] = t24, $[78] = t25) : t25 = $[78];
    let t26;
    $[79] !== t16 || $[80] !== t17 || $[81] !== t25 ? (t26 = /* @__PURE__ */ jsxs(Fragment, { children: [
      t16,
      t17,
      t18,
      t19,
      t20,
      t21,
      t22,
      t23,
      t25
    ] }), $[79] = t16, $[80] = t17, $[81] = t25, $[82] = t26) : t26 = $[82], t12 = t26;
  }
  const banners = t12, showFormView = features.resizablePanes || !showInspector;
  let t13;
  $[83] !== activeViewNode || $[84] !== banners || $[85] !== documentScrollElement || $[86] !== footer || $[87] !== formViewHidden || $[88] !== inspectDialog || $[89] !== layoutCollapsed || $[90] !== margins || $[91] !== portalElement || $[92] !== showFormView ? (t13 = showFormView && /* @__PURE__ */ jsxs(Flex, { height: "fill", direction: "column", width: "fill", flex: 2, children: [
    /* @__PURE__ */ jsxs(LegacyLayerProvider, { zOffset: "paneHeader", children: [
      banners,
      /* @__PURE__ */ jsx(DocumentPanelSubHeader, {})
    ] }),
    /* @__PURE__ */ jsx(DocumentBox, { flex: 2, overflow: "hidden", children: /* @__PURE__ */ jsx(PortalProvider, { element: portalElement, __unstable_elements: {
      documentScrollElement
    }, children: /* @__PURE__ */ jsx(BoundaryElementProvider, { element: documentScrollElement, children: /* @__PURE__ */ jsxs(VirtualizerScrollInstanceProvider, { scrollElement: documentScrollElement, containerElement: formContainerElement, children: [
      /* @__PURE__ */ jsxs(Scroller$4, { $disabled: layoutCollapsed || !1, "data-testid": "document-panel-scroller", ref: setDocumentScrollElement, children: [
        /* @__PURE__ */ jsx(FormView, { hidden: formViewHidden, margins, ref: formContainerElement }),
        activeViewNode
      ] }),
      inspectDialog,
      /* @__PURE__ */ jsx("div", { "data-testid": "document-panel-portal", ref: setPortalElement })
    ] }) }) }) }),
    footer
  ] }), $[83] = activeViewNode, $[84] = banners, $[85] = documentScrollElement, $[86] = footer, $[87] = formViewHidden, $[88] = inspectDialog, $[89] = layoutCollapsed, $[90] = margins, $[91] = portalElement, $[92] = showFormView, $[93] = t13) : t13 = $[93];
  let t14;
  $[94] !== documentId || $[95] !== rootElement || $[96] !== schemaType || $[97] !== showInspector ? (t14 = showInspector && /* @__PURE__ */ jsx(BoundaryElementProvider, { element: rootElement, children: /* @__PURE__ */ jsx(DocumentInspectorPanel, { documentId, documentType: schemaType.name, flex: 1 }) }), $[94] = documentId, $[95] = rootElement, $[96] = schemaType, $[97] = showInspector, $[98] = t14) : t14 = $[98];
  let t15;
  return $[99] !== t13 || $[100] !== t14 ? (t15 = /* @__PURE__ */ jsx(PaneContent, { children: /* @__PURE__ */ jsxs(Flex, { height: "fill", children: [
    t13,
    t14
  ] }) }), $[99] = t13, $[100] = t14, $[101] = t15) : t15 = $[101], t15;
};
DocumentPanel.displayName = "DocumentPanel";
const _DEBUG = !1, EMPTY_PARAMS$1 = Object.freeze({}), LOADING_PANE = Symbol("LOADING_PANE"), DOCUMENT_PANEL_PORTAL_ELEMENT = "documentPanelPortalElement", POPOVER_FALLBACK_PLACEMENTS = ["left", "bottom"], DIALOG_WIDTH_TO_UI_WIDTH = {
  small: 0,
  medium: 1,
  large: 2,
  full: "auto"
};
function ConfirmDialog(props) {
  const $ = c(5), {
    dialog,
    referenceElement
  } = props;
  let t0;
  $[0] !== dialog ? (t0 = /* @__PURE__ */ jsx(ConfirmDialogContent, { dialog }), $[0] = dialog, $[1] = t0) : t0 = $[1];
  let t1;
  return $[2] !== referenceElement || $[3] !== t0 ? (t1 = /* @__PURE__ */ jsx(Popover$1, { content: t0, fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS, open: !0, placement: "top", portal: !0, preventOverflow: !0, referenceElement }), $[2] = referenceElement, $[3] = t0, $[4] = t1) : t1 = $[4], t1;
}
function ConfirmDialogContent(props) {
  const $ = c(29), {
    dialog
  } = props, {
    cancelButtonIcon,
    cancelButtonText,
    confirmButtonIcon,
    confirmButtonText,
    message,
    onCancel,
    onConfirm,
    tone
  } = dialog, {
    t
  } = useTranslation(structureLocaleNamespace), {
    isTopLayer
  } = useLayer(), ref = useRef(null);
  let t0;
  $[0] !== isTopLayer || $[1] !== onCancel ? (t0 = (event) => {
    event.key === "Escape" && isTopLayer && onCancel();
  }, $[0] = isTopLayer, $[1] = onCancel, $[2] = t0) : t0 = $[2], useGlobalKeyDown(t0);
  let t1;
  $[3] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => [ref.current], $[3] = t1) : t1 = $[3], useClickOutsideEvent(isTopLayer && onCancel, t1);
  let t2;
  $[4] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {
    minWidth: 304,
    maxWidth: 400
  }, $[4] = t2) : t2 = $[4];
  let t3;
  $[5] !== message ? (t3 = /* @__PURE__ */ jsx(Box, { flex: 1, overflow: "auto", padding: 4, children: /* @__PURE__ */ jsx(Text, { children: message }) }), $[5] = message, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t4 = {
    borderTop: "1px solid var(--card-border-color)"
  }, $[7] = t4) : t4 = $[7];
  let t5;
  $[8] !== cancelButtonText || $[9] !== t ? (t5 = cancelButtonText || t("confirm-dialog.cancel-button.fallback-text"), $[8] = cancelButtonText, $[9] = t, $[10] = t5) : t5 = $[10];
  let t6;
  $[11] !== cancelButtonIcon || $[12] !== onCancel || $[13] !== t5 ? (t6 = /* @__PURE__ */ jsx(Button$1, { "data-testid": "confirm-dialog-cancel-button", icon: cancelButtonIcon, onClick: onCancel, mode: "ghost", text: t5 }), $[11] = cancelButtonIcon, $[12] = onCancel, $[13] = t5, $[14] = t6) : t6 = $[14];
  let t7;
  $[15] !== confirmButtonText || $[16] !== t ? (t7 = confirmButtonText || t("confirm-dialog.confirm-button.fallback-text"), $[15] = confirmButtonText, $[16] = t, $[17] = t7) : t7 = $[17];
  let t8;
  $[18] !== confirmButtonIcon || $[19] !== onConfirm || $[20] !== t7 || $[21] !== tone ? (t8 = /* @__PURE__ */ jsx(Button$1, { "data-testid": "confirm-dialog-confirm-button", icon: confirmButtonIcon, onClick: onConfirm, text: t7, tone }), $[18] = confirmButtonIcon, $[19] = onConfirm, $[20] = t7, $[21] = tone, $[22] = t8) : t8 = $[22];
  let t9;
  $[23] !== t6 || $[24] !== t8 ? (t9 = /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 3, style: t4, children: /* @__PURE__ */ jsxs(Grid$2, { columns: 2, gap: 2, children: [
    t6,
    t8
  ] }) }), $[23] = t6, $[24] = t8, $[25] = t9) : t9 = $[25];
  let t10;
  return $[26] !== t3 || $[27] !== t9 ? (t10 = /* @__PURE__ */ jsxs(Flex, { direction: "column", ref, style: t2, children: [
    t3,
    t9
  ] }), $[26] = t3, $[27] = t9, $[28] = t10) : t10 = $[28], t10;
}
function ModalDialog(props) {
  const $ = c(12), {
    dialog
  } = props, dialogId = useId();
  let t0;
  $[0] !== dialog.footer ? (t0 = dialog.footer && /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 3, children: dialog.footer }), $[0] = dialog.footer, $[1] = t0) : t0 = $[1];
  const footer = t0, t1 = dialog.showCloseButton === !1, t2 = dialog.width === void 0 ? 1 : DIALOG_WIDTH_TO_UI_WIDTH[dialog.width];
  let t3;
  $[2] !== dialog.content ? (t3 = /* @__PURE__ */ jsx(Box, { padding: 4, children: dialog.content }), $[2] = dialog.content, $[3] = t3) : t3 = $[3];
  let t4;
  return $[4] !== dialog.header || $[5] !== dialog.onClose || $[6] !== dialogId || $[7] !== footer || $[8] !== t1 || $[9] !== t2 || $[10] !== t3 ? (t4 = /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "fullscreen", children: /* @__PURE__ */ jsx(Dialog$1, { animate: !0, __unstable_hideCloseButton: t1, footer, header: dialog.header, id: dialogId, onClose: dialog.onClose, onClickOutside: dialog.onClose, width: t2, children: t3 }) }), $[4] = dialog.header, $[5] = dialog.onClose, $[6] = dialogId, $[7] = footer, $[8] = t1, $[9] = t2, $[10] = t3, $[11] = t4) : t4 = $[11], t4;
}
function PopoverDialog(props) {
  const $ = c(5), {
    dialog,
    referenceElement
  } = props;
  let t0;
  $[0] !== dialog ? (t0 = /* @__PURE__ */ jsx(PopoverDialogContent, { dialog }), $[0] = dialog, $[1] = t0) : t0 = $[1];
  let t1;
  return $[2] !== referenceElement || $[3] !== t0 ? (t1 = /* @__PURE__ */ jsx(Popover$1, { content: t0, fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS, open: !0, placement: "top", portal: !0, preventOverflow: !0, referenceElement }), $[2] = referenceElement, $[3] = t0, $[4] = t1) : t1 = $[4], t1;
}
function PopoverDialogContent(props) {
  const $ = c(6), {
    dialog
  } = props, {
    content,
    onClose
  } = dialog, {
    isTopLayer
  } = useLayer(), ref = useRef(null);
  let t0;
  $[0] !== isTopLayer || $[1] !== onClose ? (t0 = (event) => {
    event.key === "Escape" && isTopLayer && onClose();
  }, $[0] = isTopLayer, $[1] = onClose, $[2] = t0) : t0 = $[2], useGlobalKeyDown(t0);
  let t1;
  $[3] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => [ref.current], $[3] = t1) : t1 = $[3], useClickOutsideEvent(isTopLayer && onClose, t1);
  let t2;
  return $[4] !== content ? (t2 = /* @__PURE__ */ jsx("div", { ref, children: content }), $[4] = content, $[5] = t2) : t2 = $[5], t2;
}
function DocumentActionPortalProvider(props) {
  const $ = c(3), {
    children
  } = props, {
    element,
    elements
  } = usePortal(), portalElement = elements?.[DOCUMENT_PANEL_PORTAL_ELEMENT] || element;
  let t0;
  return $[0] !== children || $[1] !== portalElement ? (t0 = /* @__PURE__ */ jsx(PortalProvider, { element: portalElement, children }), $[0] = children, $[1] = portalElement, $[2] = t0) : t0 = $[2], t0;
}
function ActionStateDialog(props) {
  const $ = c(17), {
    dialog,
    referenceElement: t0
  } = props, referenceElement = t0 === void 0 ? null : t0, modalId = useId();
  if (dialog.type === "confirm") {
    let t12;
    return $[0] !== dialog || $[1] !== referenceElement ? (t12 = /* @__PURE__ */ jsx(ConfirmDialog, { dialog, referenceElement }), $[0] = dialog, $[1] = referenceElement, $[2] = t12) : t12 = $[2], t12;
  }
  if (dialog.type === "popover") {
    let t12;
    return $[3] !== dialog || $[4] !== referenceElement ? (t12 = /* @__PURE__ */ jsx(PopoverDialog, { dialog, referenceElement }), $[3] = dialog, $[4] = referenceElement, $[5] = t12) : t12 = $[5], t12;
  }
  if (dialog.type === "dialog" || !dialog.type) {
    let t12;
    return $[6] !== dialog ? (t12 = /* @__PURE__ */ jsx(DocumentActionPortalProvider, { children: /* @__PURE__ */ jsx(ModalDialog, { dialog }) }), $[6] = dialog, $[7] = t12) : t12 = $[7], t12;
  }
  if (dialog.type === "custom") {
    const t12 = dialog?.component;
    let t22;
    return $[8] !== t12 ? (t22 = /* @__PURE__ */ jsx(DocumentActionPortalProvider, { children: t12 }), $[8] = t12, $[9] = t22) : t22 = $[9], t22;
  }
  const unknownModal = dialog;
  console.warn(`Unsupported modal type ${unknownModal.type}`);
  let t1;
  $[10] !== unknownModal.content || $[11] !== unknownModal.type ? (t1 = unknownModal.content || /* @__PURE__ */ jsxs(Text, { size: 1, children: [
    "Unexpected modal type (",
    /* @__PURE__ */ jsx("code", { children: unknownModal.type }),
    ")"
  ] }), $[10] = unknownModal.content, $[11] = unknownModal.type, $[12] = t1) : t1 = $[12];
  let t2;
  return $[13] !== modalId || $[14] !== t1 || $[15] !== unknownModal.onClose ? (t2 = /* @__PURE__ */ jsx(Dialog, { id: modalId, onClose: unknownModal.onClose, onClickOutside: unknownModal.onClose, width: 1, children: t1 }), $[13] = modalId, $[14] = t1, $[15] = unknownModal.onClose, $[16] = t2) : t2 = $[16], t2;
}
const ActionDialogWrapper = memo(function(t0) {
  const $ = c(9), {
    actionStates,
    children,
    referenceElement
  } = t0, [actionIndex, setActionIndex] = useState(-1);
  let t1;
  t1 = actionStates[actionIndex];
  const currentAction = t1;
  let t2;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t2 = (idx) => {
    setActionIndex(idx);
  }, $[0] = t2) : t2 = $[0];
  const handleAction = t2;
  let t3, t4;
  $[1] !== children ? (t4 = children({
    handleAction
  }), $[1] = children, $[2] = t4) : t4 = $[2], t3 = t4;
  const result = t3;
  let t5;
  $[3] !== currentAction || $[4] !== referenceElement ? (t5 = currentAction && currentAction.dialog && /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsx(ActionStateDialog, { dialog: currentAction.dialog, referenceElement }) }), $[3] = currentAction, $[4] = referenceElement, $[5] = t5) : t5 = $[5];
  let t6;
  return $[6] !== result || $[7] !== t5 ? (t6 = /* @__PURE__ */ jsxs(Fragment, { children: [
    t5,
    result
  ] }), $[6] = result, $[7] = t5, $[8] = t6) : t6 = $[8], t6;
});
function ActionMenuButton(props) {
  const $ = c(10), {
    actionStates,
    disabled
  } = props, idPrefix = useId(), [referenceElement, setReferenceElement] = useState(null);
  let t0, t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = {
    placement: "top-end",
    portal: !0,
    preventOverflow: !0
  }, $[0] = t1) : t1 = $[0], t0 = t1;
  const popoverProps = t0, {
    t
  } = useTranslation(structureLocaleNamespace);
  let t2;
  $[1] !== actionStates || $[2] !== disabled || $[3] !== idPrefix || $[4] !== t ? (t2 = (t32) => {
    const {
      handleAction
    } = t32;
    return /* @__PURE__ */ jsx(MenuButton, { id: `${idPrefix}-action-menu`, button: /* @__PURE__ */ jsx(ContextMenuButton, { "aria-label": t("buttons.action-menu-button.aria-label"), disabled, "data-testid": "action-menu-button", tooltipProps: {
      content: t("buttons.action-menu-button.tooltip")
    } }), menu: /* @__PURE__ */ jsx(Menu, { padding: 1, children: actionStates.map((actionState, idx) => /* @__PURE__ */ jsx(ActionMenuListItem, { actionState, disabled, index: idx, onAction: handleAction }, idx)) }), popover: popoverProps, ref: setReferenceElement });
  }, $[1] = actionStates, $[2] = disabled, $[3] = idPrefix, $[4] = t, $[5] = t2) : t2 = $[5];
  const renderActionDialog = t2;
  let t3;
  return $[6] !== actionStates || $[7] !== referenceElement || $[8] !== renderActionDialog ? (t3 = /* @__PURE__ */ jsx(ActionDialogWrapper, { actionStates, referenceElement, children: renderActionDialog }), $[6] = actionStates, $[7] = referenceElement, $[8] = renderActionDialog, $[9] = t3) : t3 = $[9], t3;
}
function ActionMenuListItem(props) {
  const $ = c(18), {
    actionState,
    disabled,
    index,
    onAction
  } = props, {
    onHandle
  } = actionState;
  let t0;
  $[0] !== index || $[1] !== onAction || $[2] !== onHandle ? (t0 = () => {
    onAction(index), onHandle && onHandle();
  }, $[0] = index, $[1] = onAction, $[2] = onHandle, $[3] = t0) : t0 = $[3];
  const handleClick = t0;
  let t1, t2;
  $[4] !== actionState.shortcut ? (t2 = actionState.shortcut ? String(actionState.shortcut).split("+").map(_temp$d) : void 0, $[4] = actionState.shortcut, $[5] = t2) : t2 = $[5], t1 = t2;
  const hotkeys = t1, t3 = `action-${actionState.label.replace(" ", "")}`, t4 = disabled || !!actionState.disabled;
  let t5;
  $[6] !== actionState.disabled || $[7] !== actionState.title ? (t5 = actionState.disabled && {
    tooltipProps: {
      content: actionState.title
    }
  }, $[6] = actionState.disabled, $[7] = actionState.title, $[8] = t5) : t5 = $[8];
  let t6;
  return $[9] !== actionState.icon || $[10] !== actionState.label || $[11] !== actionState.tone || $[12] !== handleClick || $[13] !== hotkeys || $[14] !== t3 || $[15] !== t4 || $[16] !== t5 ? (t6 = /* @__PURE__ */ jsx(MenuItem, { "data-testid": t3, disabled: t4, hotkeys, icon: actionState.icon, onClick: handleClick, text: actionState.label, tone: actionState.tone, ...t5 }), $[9] = actionState.icon, $[10] = actionState.label, $[11] = actionState.tone, $[12] = handleClick, $[13] = hotkeys, $[14] = t3, $[15] = t4, $[16] = t5, $[17] = t6) : t6 = $[17], t6;
}
function _temp$d(s) {
  return s.slice(0, 1).toUpperCase() + s.slice(1);
}
const DISABLED_REASON_TITLE_KEY$1 = {
  NOTHING_TO_DELETE: "action.delete.disabled.nothing-to-delete",
  NOT_READY: "action.delete.disabled.not-ready"
}, DeleteAction = (t0) => {
  const $ = c(36), {
    id,
    type,
    draft,
    onComplete,
    release
  } = t0, {
    setIsDeleting: paneSetIsDeleting
  } = useDocumentPane(), {
    delete: deleteOp
  } = useDocumentOperation(id, type, release), [isDeleting, setIsDeleting] = useState(!1), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), {
    t
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== onComplete ? (t1 = () => {
    setConfirmDialogOpen(!1), onComplete();
  }, $[0] = onComplete, $[1] = t1) : t1 = $[1];
  const handleCancel = t1;
  let t2;
  $[2] !== deleteOp || $[3] !== onComplete || $[4] !== paneSetIsDeleting ? (t2 = () => {
    setIsDeleting(!0), setConfirmDialogOpen(!1), paneSetIsDeleting(!0), deleteOp.execute(), onComplete();
  }, $[2] = deleteOp, $[3] = onComplete, $[4] = paneSetIsDeleting, $[5] = t2) : t2 = $[5];
  const handleConfirm = t2;
  let t3;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => {
    setConfirmDialogOpen(!0);
  }, $[6] = t3) : t3 = $[6];
  const handle = t3;
  let t4;
  $[7] !== id || $[8] !== release || $[9] !== type ? (t4 = {
    id,
    type,
    version: release,
    permission: "delete"
  }, $[7] = id, $[8] = release, $[9] = type, $[10] = t4) : t4 = $[10];
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions(t4), currentUser = useCurrentUser();
  let t5;
  bb0: {
    if (!isPermissionsLoading && !permissions?.granted) {
      let t62;
      $[11] !== t ? (t62 = t("action.delete.label"), $[11] = t, $[12] = t62) : t62 = $[12];
      let t72;
      $[13] !== currentUser ? (t72 = /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "delete-document", currentUser }), $[13] = currentUser, $[14] = t72) : t72 = $[14];
      let t82;
      $[15] !== t62 || $[16] !== t72 ? (t82 = {
        tone: "critical",
        icon: TrashIcon,
        disabled: !0,
        label: t62,
        title: t72
      }, $[15] = t62, $[16] = t72, $[17] = t82) : t82 = $[17], t5 = t82;
      break bb0;
    }
    const t6 = isDeleting || !!deleteOp.disabled || isPermissionsLoading;
    let t7;
    $[18] !== deleteOp.disabled || $[19] !== t ? (t7 = deleteOp.disabled && t(DISABLED_REASON_TITLE_KEY$1[deleteOp.disabled]) || "", $[18] = deleteOp.disabled, $[19] = t, $[20] = t7) : t7 = $[20];
    let t8;
    $[21] !== isDeleting || $[22] !== t ? (t8 = t(isDeleting ? "action.delete.running.label" : "action.delete.label"), $[21] = isDeleting, $[22] = t, $[23] = t8) : t8 = $[23];
    let t9;
    $[24] !== draft?._id || $[25] !== handleCancel || $[26] !== handleConfirm || $[27] !== id || $[28] !== isConfirmDialogOpen || $[29] !== type ? (t9 = isConfirmDialogOpen && {
      type: "custom",
      component: /* @__PURE__ */ jsx(ConfirmDeleteDialogContainer, { action: "delete", id: draft?._id || id, type, onCancel: handleCancel, onConfirm: handleConfirm })
    }, $[24] = draft?._id, $[25] = handleCancel, $[26] = handleConfirm, $[27] = id, $[28] = isConfirmDialogOpen, $[29] = type, $[30] = t9) : t9 = $[30];
    let t10;
    $[31] !== t6 || $[32] !== t7 || $[33] !== t8 || $[34] !== t9 ? (t10 = {
      tone: "critical",
      icon: TrashIcon,
      disabled: t6,
      title: t7,
      label: t8,
      shortcut: "Ctrl+Alt+D",
      onHandle: handle,
      dialog: t9
    }, $[31] = t6, $[32] = t7, $[33] = t8, $[34] = t9, $[35] = t10) : t10 = $[35], t5 = t10;
  }
  return t5;
};
DeleteAction.action = "delete";
DeleteAction.displayName = "DeleteAction";
const DISABLED_REASON_KEY$2 = {
  NO_CHANGES: "action.discard-changes.disabled.no-change",
  NOT_PUBLISHED: "action.discard-changes.disabled.not-published",
  NOT_READY: "action.discard-changes.disabled.not-ready"
}, DiscardChangesAction = ({
  id,
  type,
  published,
  liveEdit,
  onComplete,
  release
}) => {
  const {
    discardChanges
  } = useDocumentOperation(id, type, release), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    version: release,
    permission: "discardDraft"
  }), currentUser = useCurrentUser(), {
    displayed
  } = useDocumentPane(), {
    t
  } = useTranslation(structureLocaleNamespace), isPublished = displayed?._id && isPublishedId(displayed?._id), handleConfirm = useCallback(() => {
    discardChanges.execute(), onComplete();
  }, [discardChanges, onComplete]), handle = useCallback(() => {
    setConfirmDialogOpen(!0);
  }, []), dialog = useMemo(() => isConfirmDialogOpen && {
    type: "confirm",
    tone: "critical",
    onCancel: onComplete,
    onConfirm: handleConfirm,
    message: t("action.discard-changes.confirm-dialog.confirm-discard-changes")
  }, [handleConfirm, isConfirmDialogOpen, onComplete, t]);
  return useMemo(() => !published || liveEdit || isPublished ? null : !isPermissionsLoading && !permissions?.granted ? {
    tone: "critical",
    icon: ResetIcon,
    disabled: !0,
    label: t("action.discard-changes.label"),
    title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "discard-changes", currentUser })
  } : {
    tone: "critical",
    icon: ResetIcon,
    disabled: !!discardChanges.disabled || isPermissionsLoading,
    title: t(discardChanges.disabled && DISABLED_REASON_KEY$2[discardChanges.disabled] || ""),
    label: t("action.discard-changes.label"),
    onHandle: handle,
    dialog
  }, [currentUser, dialog, discardChanges.disabled, handle, isPermissionsLoading, isPublished, liveEdit, permissions?.granted, published, t]);
};
DiscardChangesAction.action = "discardChanges";
DiscardChangesAction.displayName = "DiscardChangesAction";
const DISABLED_REASON_KEY$1 = {
  NOTHING_TO_DUPLICATE: "action.duplicate.disabled.nothing-to-duplicate",
  NOT_READY: "action.duplicate.disabled.not-ready"
}, DuplicateAction = ({
  id,
  type,
  onComplete,
  release,
  mapDocument
}) => {
  const documentStore = useDocumentStore(), {
    duplicate
  } = useDocumentOperation(id, type, release), {
    navigateIntent
  } = useRouter(), [isDuplicating, setDuplicating] = useState(!1), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    version: release,
    permission: "duplicate"
  }), {
    t
  } = useTranslation(structureLocaleNamespace), currentUser = useCurrentUser(), handle = useCallback(async () => {
    const dupeId = uuid();
    setDuplicating(!0);
    const duplicateSuccess = firstValueFrom(documentStore.pair.operationEvents(id, type).pipe(filter((e) => e.op === "duplicate" && e.type === "success")));
    duplicate.execute(dupeId, {
      mapDocument
    }), await duplicateSuccess, navigateIntent("edit", {
      id: dupeId,
      type
    }), onComplete();
  }, [documentStore.pair, duplicate, id, mapDocument, navigateIntent, onComplete, type]);
  return useMemo(() => !isPermissionsLoading && !permissions?.granted ? {
    icon: CopyIcon,
    disabled: !0,
    label: t("action.duplicate.label"),
    title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "duplicate-document", currentUser })
  } : {
    icon: CopyIcon,
    disabled: isDuplicating || !!duplicate.disabled || isPermissionsLoading,
    label: t(isDuplicating ? "action.duplicate.running.label" : "action.duplicate.label"),
    title: duplicate.disabled ? t(DISABLED_REASON_KEY$1[duplicate.disabled]) : "",
    onHandle: handle
  }, [currentUser, duplicate.disabled, handle, isDuplicating, isPermissionsLoading, permissions?.granted, t]);
};
DuplicateAction.action = "duplicate";
DuplicateAction.displayName = "DuplicateAction";
const HistoryRestoreAction = (t0) => {
  const $ = c(27), {
    id,
    type,
    revision,
    onComplete,
    release
  } = t0, {
    restore
  } = useDocumentOperation(id, type, release), {
    revisionNotFound
  } = useDocumentPane(), event = useDocumentOperationEvent(id, type), {
    navigateIntent
  } = useRouter(), prevEvent = useRef(event), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), {
    t
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== onComplete || $[1] !== restore || $[2] !== revision ? (t1 = () => {
    restore.execute(revision), onComplete();
  }, $[0] = onComplete, $[1] = restore, $[2] = revision, $[3] = t1) : t1 = $[3];
  const handleConfirm = t1;
  let t2, t3;
  $[4] !== event || $[5] !== id || $[6] !== navigateIntent || $[7] !== type ? (t2 = () => {
    !event || event === prevEvent.current || (event.type === "success" && event.op === "restore" && navigateIntent("edit", {
      id,
      type
    }), prevEvent.current = event);
  }, t3 = [event, id, navigateIntent, type], $[4] = event, $[5] = id, $[6] = navigateIntent, $[7] = type, $[8] = t2, $[9] = t3) : (t2 = $[8], t3 = $[9]), useEffect(t2, t3);
  let t4;
  $[10] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => {
    setConfirmDialogOpen(!0);
  }, $[10] = t4) : t4 = $[10];
  const handle = t4;
  let t5;
  bb0: {
    if (isConfirmDialogOpen) {
      let t62;
      $[11] !== t ? (t62 = t("action.restore.confirm.message"), $[11] = t, $[12] = t62) : t62 = $[12];
      let t7;
      $[13] !== handleConfirm || $[14] !== onComplete || $[15] !== t62 ? (t7 = {
        type: "confirm",
        tone: "critical",
        onCancel: onComplete,
        onConfirm: handleConfirm,
        message: t62
      }, $[13] = handleConfirm, $[14] = onComplete, $[15] = t62, $[16] = t7) : t7 = $[16], t5 = t7;
      break bb0;
    }
    t5 = null;
  }
  const dialog = t5, isRevisionInitial = revision === "@initial", isRevisionLatest = revision === void 0;
  let t6;
  bb1: {
    if (isRevisionLatest || revisionNotFound) {
      t6 = null;
      break bb1;
    }
    let t7;
    $[17] !== t ? (t7 = t("action.restore.label"), $[17] = t, $[18] = t7) : t7 = $[18];
    const t8 = isRevisionInitial ? "action.restore.disabled.cannot-restore-initial" : "action.restore.tooltip";
    let t9;
    $[19] !== t || $[20] !== t8 ? (t9 = t(t8), $[19] = t, $[20] = t8, $[21] = t9) : t9 = $[21];
    let t10;
    $[22] !== dialog || $[23] !== isRevisionInitial || $[24] !== t7 || $[25] !== t9 ? (t10 = {
      label: t7,
      tone: "caution",
      onHandle: handle,
      title: t9,
      icon: RevertIcon,
      dialog,
      disabled: isRevisionInitial
    }, $[22] = dialog, $[23] = isRevisionInitial, $[24] = t7, $[25] = t9, $[26] = t10) : t10 = $[26], t6 = t10;
  }
  return t6;
};
HistoryRestoreAction.action = "restore";
HistoryRestoreAction.displayName = "HistoryRestoreAction";
const DocumentPublished = defineEvent({
  name: "Document Published",
  version: 1,
  description: 'User clicked the "Publish" button in the document pane'
}), DISABLED_REASON_TITLE_KEY = {
  LIVE_EDIT_ENABLED: "action.publish.live-edit.publish-disabled",
  ALREADY_PUBLISHED: "action.publish.already-published.no-time-ago.tooltip",
  NO_CHANGES: "action.publish.no-changes.tooltip",
  NOT_READY: "action.publish.disabled.not-ready"
};
function getDisabledReason(reason, publishedAt, t) {
  return reason === "ALREADY_PUBLISHED" && publishedAt ? /* @__PURE__ */ jsx(AlreadyPublished, { publishedAt }) : t(DISABLED_REASON_TITLE_KEY[reason]);
}
function AlreadyPublished(t0) {
  const $ = c(6), {
    publishedAt
  } = t0, {
    t
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = {
    useTemporalPhrase: !0
  }, $[0] = t1) : t1 = $[0];
  const timeSincePublished = useRelativeTime(publishedAt, t1);
  let t2;
  $[1] !== t || $[2] !== timeSincePublished ? (t2 = t("action.publish.already-published.tooltip", {
    timeSincePublished
  }), $[1] = t, $[2] = timeSincePublished, $[3] = t2) : t2 = $[3];
  let t3;
  return $[4] !== t2 ? (t3 = /* @__PURE__ */ jsx("span", { children: t2 }), $[4] = t2, $[5] = t3) : t3 = $[5], t3;
}
const PublishAction = (props) => {
  const $ = c(78), {
    id,
    type,
    liveEdit,
    draft,
    published,
    release
  } = props, [publishState, setPublishState] = useState(null), {
    publish
  } = useDocumentOperation(id, type), validationStatus = useValidationStatus(id, type), syncState = useSyncState(id, type), {
    changesOpen,
    documentId,
    documentType,
    value
  } = useDocumentPane(), editState = useEditState(documentId, documentType), {
    t
  } = useTranslation(structureLocaleNamespace);
  let t0;
  $[0] !== editState?.draft || $[1] !== editState?.published ? (t0 = editState?.draft || editState?.published || {}, $[0] = editState?.draft, $[1] = editState?.published, $[2] = t0) : t0 = $[2];
  const revision = t0._rev;
  let t1;
  $[3] !== validationStatus.validation ? (t1 = validationStatus.validation.some(isValidationErrorMarker), $[3] = validationStatus.validation, $[4] = t1) : t1 = $[4];
  const hasValidationErrors = t1, [publishScheduled, setPublishScheduled] = useState(!1), isSyncing = syncState.isSyncing, isValidating = validationStatus.isValidating;
  let t2;
  $[5] !== id || $[6] !== type ? (t2 = {
    id,
    type,
    permission: "publish"
  }, $[5] = id, $[6] = type, $[7] = t2) : t2 = $[7];
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions(t2), currentUser = useCurrentUser();
  let t3;
  $[8] !== hasValidationErrors || $[9] !== publish.disabled || $[10] !== published || $[11] !== t ? (t3 = publish.disabled ? getDisabledReason(publish.disabled, (published || {})._updatedAt, t) || "" : hasValidationErrors ? t("action.publish.validation-issues.tooltip") : "", $[8] = hasValidationErrors, $[9] = publish.disabled, $[10] = published, $[11] = t, $[12] = t3) : t3 = $[12];
  const title = t3, hasDraft = !!draft;
  let t4;
  $[13] !== publish ? (t4 = () => {
    publish.execute(), setPublishState("publishing");
  }, $[13] = publish, $[14] = t4) : t4 = $[14];
  const doPublish = t4;
  let t5;
  $[15] !== doPublish || $[16] !== hasValidationErrors || $[17] !== isSyncing || $[18] !== publishScheduled || $[19] !== revision || $[20] !== validationStatus.isValidating || $[21] !== validationStatus.revision ? (t5 = () => {
    const validationComplete = validationStatus.isValidating === !1 && validationStatus.revision !== revision;
    !publishScheduled || isSyncing || !validationComplete || (hasValidationErrors || doPublish(), setPublishScheduled(!1));
  }, $[15] = doPublish, $[16] = hasValidationErrors, $[17] = isSyncing, $[18] = publishScheduled, $[19] = revision, $[20] = validationStatus.isValidating, $[21] = validationStatus.revision, $[22] = t5) : t5 = $[22];
  let t6;
  $[23] !== doPublish || $[24] !== hasValidationErrors || $[25] !== isSyncing || $[26] !== isValidating || $[27] !== publishScheduled || $[28] !== revision || $[29] !== validationStatus.isValidating || $[30] !== validationStatus.revision ? (t6 = [isSyncing, doPublish, hasValidationErrors, publishScheduled, validationStatus.revision, revision, isValidating, validationStatus.isValidating], $[23] = doPublish, $[24] = hasValidationErrors, $[25] = isSyncing, $[26] = isValidating, $[27] = publishScheduled, $[28] = revision, $[29] = validationStatus.isValidating, $[30] = validationStatus.revision, $[31] = t6) : t6 = $[31], useEffect(t5, t6);
  let t7;
  $[32] !== hasDraft || $[33] !== publishState ? (t7 = () => {
    const didPublish = publishState === "publishing" && !hasDraft, nextState = didPublish ? "published" : null, timer2 = setTimeout(() => {
      setPublishState(nextState);
    }, didPublish ? 200 : 4e3);
    return () => clearTimeout(timer2);
  }, $[32] = hasDraft, $[33] = publishState, $[34] = t7) : t7 = $[34];
  let t8;
  $[35] !== changesOpen || $[36] !== hasDraft || $[37] !== publishState ? (t8 = [changesOpen, publishState, hasDraft], $[35] = changesOpen, $[36] = hasDraft, $[37] = publishState, $[38] = t8) : t8 = $[38], useEffect(t7, t8);
  const telemetry = useTelemetry();
  let t9;
  $[39] !== doPublish || $[40] !== draft?._createdAt || $[41] !== published || $[42] !== revision || $[43] !== syncState.isSyncing || $[44] !== telemetry || $[45] !== validationStatus.isValidating || $[46] !== validationStatus.revision ? (t9 = () => {
    telemetry.log(DocumentPublished, {
      publishedImmediately: !draft?._createdAt,
      previouslyPublished: !!published
    }), syncState.isSyncing || validationStatus.isValidating || validationStatus.revision !== revision ? setPublishScheduled(!0) : doPublish();
  }, $[39] = doPublish, $[40] = draft?._createdAt, $[41] = published, $[42] = revision, $[43] = syncState.isSyncing, $[44] = telemetry, $[45] = validationStatus.isValidating, $[46] = validationStatus.revision, $[47] = t9) : t9 = $[47];
  const handle = t9;
  let t10;
  bb0: {
    if (release) {
      t10 = null;
      break bb0;
    }
    if (liveEdit) {
      t10 = null;
      break bb0;
    }
    if (isPublishedId(value._id) && draft !== null) {
      let t112;
      $[48] !== t ? (t112 = t("action.publish.label"), $[48] = t, $[49] = t112) : t112 = $[49];
      const t122 = published?._updatedAt;
      let t132;
      $[50] !== t || $[51] !== t122 ? (t132 = getDisabledReason("ALREADY_PUBLISHED", t122, t), $[50] = t, $[51] = t122, $[52] = t132) : t132 = $[52];
      let t142;
      $[53] !== t112 || $[54] !== t132 ? (t142 = {
        tone: "default",
        icon: PublishIcon,
        label: t112,
        title: t132,
        disabled: !0
      }, $[53] = t112, $[54] = t132, $[55] = t142) : t142 = $[55], t10 = t142;
      break bb0;
    }
    if (!isPermissionsLoading && !permissions?.granted) {
      let t112;
      $[56] !== t ? (t112 = t("action.publish.label"), $[56] = t, $[57] = t112) : t112 = $[57];
      let t122;
      $[58] !== currentUser ? (t122 = /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "publish-document", currentUser }), $[58] = currentUser, $[59] = t122) : t122 = $[59];
      let t132;
      $[60] !== t112 || $[61] !== t122 ? (t132 = {
        tone: "default",
        icon: PublishIcon,
        label: t112,
        title: t122,
        disabled: !0
      }, $[60] = t112, $[61] = t122, $[62] = t132) : t132 = $[62], t10 = t132;
      break bb0;
    }
    const disabled = !!(publishScheduled || editState?.transactionSyncLock?.enabled || publishState === "publishing" || publishState === "published" || hasValidationErrors || publish.disabled), t11 = disabled || isPermissionsLoading;
    let t12;
    $[63] !== publishScheduled || $[64] !== publishState || $[65] !== t ? (t12 = t(publishState === "published" ? "action.publish.published.label" : publishScheduled || publishState === "publishing" ? "action.publish.running.label" : "action.publish.draft.label"), $[63] = publishScheduled, $[64] = publishState, $[65] = t, $[66] = t12) : t12 = $[66];
    let t13;
    $[67] !== publishScheduled || $[68] !== publishState || $[69] !== t || $[70] !== title ? (t13 = publishScheduled ? t("action.publish.waiting") : publishState === "published" || publishState === "publishing" ? null : title, $[67] = publishScheduled, $[68] = publishState, $[69] = t, $[70] = title, $[71] = t13) : t13 = $[71];
    const t14 = disabled || publishScheduled ? null : "Ctrl+Alt+P";
    let t15;
    $[72] !== handle || $[73] !== t11 || $[74] !== t12 || $[75] !== t13 || $[76] !== t14 ? (t15 = {
      disabled: t11,
      tone: "default",
      label: t12,
      icon: PublishIcon,
      title: t13,
      shortcut: t14,
      onHandle: handle
    }, $[72] = handle, $[73] = t11, $[74] = t12, $[75] = t13, $[76] = t14, $[77] = t15) : t15 = $[77], t10 = t15;
  }
  return t10;
};
PublishAction.action = "publish";
PublishAction.displayName = "PublishAction";
const DISABLED_REASON_KEY = {
  NOT_PUBLISHED: "action.unpublish.disabled.not-published",
  NOT_READY: "action.unpublish.disabled.not-ready",
  LIVE_EDIT_ENABLED: "action.unpublish.disabled.live-edit-enabled"
}, UnpublishAction = ({
  id,
  type,
  draft,
  onComplete,
  liveEdit,
  release
}) => {
  const {
    unpublish
  } = useDocumentOperation(id, type), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "unpublish"
  }), currentUser = useCurrentUser(), {
    displayed
  } = useDocumentPane(), {
    t
  } = useTranslation(structureLocaleNamespace), isDraft = displayed?._id && isDraftId(displayed?._id), handleCancel = useCallback(() => {
    setConfirmDialogOpen(!1), onComplete();
  }, [onComplete]), handleConfirm = useCallback(() => {
    setConfirmDialogOpen(!1), unpublish.execute(), onComplete();
  }, [onComplete, unpublish]), dialog = useMemo(() => isConfirmDialogOpen ? {
    type: "dialog",
    onClose: onComplete,
    content: /* @__PURE__ */ jsx(
      ConfirmDeleteDialogContainer,
      {
        id: draft?._id || id,
        type,
        action: "unpublish",
        onCancel: handleCancel,
        onConfirm: handleConfirm
      }
    )
  } : null, [draft, id, handleCancel, handleConfirm, isConfirmDialogOpen, onComplete, type]);
  return useMemo(() => release || isDraft || liveEdit ? null : !isPermissionsLoading && !permissions?.granted ? {
    tone: "critical",
    icon: UnpublishIcon,
    label: "Unpublish",
    title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "unpublish-document", currentUser }),
    disabled: !0
  } : {
    tone: "critical",
    icon: UnpublishIcon,
    disabled: !!unpublish.disabled || isPermissionsLoading,
    label: t("action.unpublish.label"),
    title: unpublish.disabled ? t(DISABLED_REASON_KEY[unpublish.disabled]) : "",
    onHandle: () => setConfirmDialogOpen(!0),
    dialog
  }, [release, isDraft, liveEdit, isPermissionsLoading, permissions?.granted, unpublish.disabled, t, dialog, currentUser]);
};
UnpublishAction.action = "unpublish";
UnpublishAction.displayName = "UnpublishAction";
const DocumentStatusBarActionsInner = memo(function(props) {
  const $ = c(33), {
    disabled,
    showMenu,
    states
  } = props, {
    __internal_tasks
  } = useSource(), {
    editState
  } = useDocumentPane(), {
    selectedReleaseId
  } = usePerspective();
  let firstActionState, menuActionStates;
  $[0] !== states ? ([firstActionState, ...menuActionStates] = states, $[0] = states, $[1] = firstActionState, $[2] = menuActionStates) : (firstActionState = $[1], menuActionStates = $[2]);
  const [buttonElement, setButtonElement] = useState(null);
  let t0;
  bb0: {
    if (!firstActionState || !firstActionState.title && !firstActionState.shortcut) {
      t0 = null;
      break bb0;
    }
    let t12;
    $[3] === Symbol.for("react.memo_cache_sentinel") ? (t12 = {
      maxWidth: 300
    }, $[3] = t12) : t12 = $[3];
    let t22;
    $[4] !== firstActionState.title ? (t22 = firstActionState.title && /* @__PURE__ */ jsx(Text, { size: 1, children: firstActionState.title }), $[4] = firstActionState.title, $[5] = t22) : t22 = $[5];
    let t32;
    $[6] !== firstActionState.shortcut ? (t32 = firstActionState.shortcut && /* @__PURE__ */ jsx(Hotkeys, { "data-testid": "document-status-bar-hotkeys", fontSize: 1, style: {
      marginTop: -4,
      marginBottom: -4
    }, keys: String(firstActionState.shortcut).split("+").map(_temp$c) }), $[6] = firstActionState.shortcut, $[7] = t32) : t32 = $[7];
    let t42;
    $[8] !== t22 || $[9] !== t32 ? (t42 = /* @__PURE__ */ jsxs(Flex, { style: t12, align: "center", gap: 3, children: [
      t22,
      t32
    ] }), $[8] = t22, $[9] = t32, $[10] = t42) : t42 = $[10], t0 = t42;
  }
  const tooltipContent = t0, showFirstActionButton = selectedReleaseId ? firstActionState && !isSanityDefinedAction(firstActionState) : firstActionState && !editState?.liveEdit;
  let t1, t2;
  $[11] !== firstActionState || $[12] !== menuActionStates || $[13] !== showFirstActionButton ? (t2 = showFirstActionButton ? menuActionStates : [firstActionState, ...menuActionStates], $[11] = firstActionState, $[12] = menuActionStates, $[13] = showFirstActionButton, $[14] = t2) : t2 = $[14], t1 = t2;
  const sideMenuItems = t1, t3 = __internal_tasks && __internal_tasks.footerAction;
  let t4;
  $[15] !== disabled || $[16] !== firstActionState || $[17] !== showFirstActionButton || $[18] !== tooltipContent ? (t4 = showFirstActionButton && /* @__PURE__ */ jsx(LayerProvider, { zOffset: 200, children: /* @__PURE__ */ jsx(Tooltip, { disabled: !tooltipContent, content: tooltipContent, placement: "top", children: /* @__PURE__ */ jsx(Stack, { children: /* @__PURE__ */ jsx(Button, { "data-testid": `action-${toLowerCaseNoSpaces(firstActionState.label)}`, disabled: disabled || !!firstActionState.disabled, icon: firstActionState.icon, onClick: firstActionState.onHandle, ref: setButtonElement, text: firstActionState.label, tone: firstActionState.tone || "primary" }) }) }) }), $[15] = disabled, $[16] = firstActionState, $[17] = showFirstActionButton, $[18] = tooltipContent, $[19] = t4) : t4 = $[19];
  let t5;
  $[20] !== disabled || $[21] !== menuActionStates || $[22] !== showMenu || $[23] !== sideMenuItems ? (t5 = showMenu && menuActionStates.length > 0 && /* @__PURE__ */ jsx(ActionMenuButton, { actionStates: sideMenuItems, disabled }), $[20] = disabled, $[21] = menuActionStates, $[22] = showMenu, $[23] = sideMenuItems, $[24] = t5) : t5 = $[24];
  let t6;
  $[25] !== buttonElement || $[26] !== firstActionState ? (t6 = firstActionState && firstActionState.dialog && /* @__PURE__ */ jsx(ActionStateDialog, { dialog: firstActionState.dialog, referenceElement: buttonElement }), $[25] = buttonElement, $[26] = firstActionState, $[27] = t6) : t6 = $[27];
  let t7;
  return $[28] !== t3 || $[29] !== t4 || $[30] !== t5 || $[31] !== t6 ? (t7 = /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, children: [
    t3,
    t4,
    t5,
    t6
  ] }), $[28] = t3, $[29] = t4, $[30] = t5, $[31] = t6, $[32] = t7) : t7 = $[32], t7;
}), DocumentStatusBarActions = memo(function() {
  const $ = c(15), {
    actions: allActions,
    connectionState,
    documentId,
    editState,
    isInitialValueLoading
  } = useDocumentPane();
  let t0, t1;
  $[0] !== allActions ? (t1 = allActions ?? [], $[0] = allActions, $[1] = t1) : t1 = $[1];
  let t2;
  $[2] !== t1 ? (t2 = t1.filter(_temp2$4), $[2] = t1, $[3] = t2) : t2 = $[3], t0 = t2;
  const actions = t0;
  let t3, t4;
  $[4] !== editState || $[5] !== isInitialValueLoading ? (t4 = editState ? {
    ...editState,
    initialValueResolved: !isInitialValueLoading
  } : null, $[4] = editState, $[5] = isInitialValueLoading, $[6] = t4) : t4 = $[6], t3 = t4;
  const actionProps = t3;
  let t5;
  $[7] !== actions.length || $[8] !== connectionState || $[9] !== documentId ? (t5 = (t62) => {
    const {
      states
    } = t62;
    return /* @__PURE__ */ jsx(DocumentStatusBarActionsInner, { disabled: connectionState !== "connected", showMenu: actions.length > 1, states }, documentId);
  }, $[7] = actions.length, $[8] = connectionState, $[9] = documentId, $[10] = t5) : t5 = $[10];
  const renderDocumentStatusBarActions = t5;
  if (actions.length === 0 || !actionProps)
    return null;
  let t6;
  return $[11] !== actionProps || $[12] !== actions || $[13] !== renderDocumentStatusBarActions ? (t6 = /* @__PURE__ */ jsx(RenderActionCollectionState, { actions, actionProps, group: "default", children: renderDocumentStatusBarActions }), $[11] = actionProps, $[12] = actions, $[13] = renderDocumentStatusBarActions, $[14] = t6) : t6 = $[14], t6;
}), HistoryStatusBarActions = memo(function() {
  const $ = c(15), {
    actions,
    connectionState,
    editState,
    revisionId: revision,
    isInitialValueLoading
  } = useDocumentPane(), disabled = (editState?.draft || editState?.published || {})._rev === revision;
  let t0, t1;
  $[0] !== editState || $[1] !== isInitialValueLoading || $[2] !== revision ? (t1 = editState ? {
    ...editState,
    revision: revision || void 0,
    initialValueResolved: !isInitialValueLoading
  } : null, $[0] = editState, $[1] = isInitialValueLoading, $[2] = revision, $[3] = t1) : t1 = $[3], t0 = t1;
  const actionProps = t0;
  let t2, t3;
  $[4] !== actions ? (t3 = actions ?? [], $[4] = actions, $[5] = t3) : t3 = $[5];
  let t4;
  $[6] !== t3 ? (t4 = t3.filter(isRestoreAction).slice(-1), $[6] = t3, $[7] = t4) : t4 = $[7], t2 = t4;
  const historyActions = t2;
  let t5;
  $[8] !== connectionState || $[9] !== disabled ? (t5 = (t62) => {
    const {
      states
    } = t62;
    return /* @__PURE__ */ jsx(DocumentStatusBarActionsInner, { disabled: connectionState !== "connected" || !!disabled, showMenu: !1, states });
  }, $[8] = connectionState, $[9] = disabled, $[10] = t5) : t5 = $[10];
  const renderDocumentStatusBarActions = t5;
  if (!actionProps)
    return null;
  let t6;
  return $[11] !== actionProps || $[12] !== historyActions || $[13] !== renderDocumentStatusBarActions ? (t6 = /* @__PURE__ */ jsx(RenderActionCollectionState, { actions: historyActions, actionProps, group: "default", children: renderDocumentStatusBarActions }), $[11] = actionProps, $[12] = historyActions, $[13] = renderDocumentStatusBarActions, $[14] = t6) : t6 = $[14], t6;
});
function isRestoreAction(action) {
  return action.action === HistoryRestoreAction.action;
}
function _temp$c(s) {
  return s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase();
}
function _temp2$4(action) {
  return !isRestoreAction(action);
}
function useChipScrollPosition(containerRef) {
  const $ = c(4), [showGradient, setShowGradient] = useState(!1);
  let t0;
  $[0] !== containerRef.current ? (t0 = () => {
    const checkOverflow = () => {
      const container = containerRef.current;
      if (!container)
        return;
      const {
        scrollWidth,
        clientWidth
      } = container;
      if (!(scrollWidth > clientWidth)) {
        setShowGradient(!1);
        return;
      }
      const {
        scrollLeft
      } = container, isAtEnd = scrollLeft + clientWidth >= scrollWidth;
      setShowGradient(!isAtEnd);
    }, setupObservers = function() {
      checkOverflow();
      const container_0 = containerRef.current;
      if (!container_0)
        return {
          intersectionObserver: null,
          mutationObserver: null
        };
      const intersectionObserver = new IntersectionObserver((entries) => {
        const entry = entries[0];
        entry && setShowGradient(!entry.isIntersecting);
      }), updateLastChipObserver = () => {
        intersectionObserver.disconnect();
        const lastChip = container_0.children[container_0.children.length - 1];
        intersectionObserver.observe(lastChip);
      };
      updateLastChipObserver();
      const mutationObserver = new MutationObserver(() => {
        updateLastChipObserver(), checkOverflow();
      });
      return mutationObserver.observe(container_0, {
        childList: !0,
        subtree: !1
      }), {
        intersectionObserver,
        mutationObserver
      };
    }, {
      intersectionObserver: intersectionObserver_0,
      mutationObserver: mutationObserver_0
    } = setupObservers();
    return () => {
      intersectionObserver_0?.disconnect(), mutationObserver_0?.disconnect();
    };
  }, $[0] = containerRef.current, $[1] = t0) : t0 = $[1];
  let t1;
  return $[2] !== containerRef ? (t1 = [containerRef], $[2] = containerRef, $[3] = t1) : t1 = $[3], useEffect(t0, t1), showGradient;
}
const TooltipContent$1 = (t0) => {
  const $ = c(16), {
    release
  } = t0, {
    t
  } = useTranslation();
  if (release.state === "archived") {
    let t1;
    $[0] !== t ? (t1 = t("release.chip.tooltip.archived"), $[0] = t, $[1] = t1) : t1 = $[1];
    let t2;
    return $[2] !== t1 ? (t2 = /* @__PURE__ */ jsx(Text, { size: 1, children: t1 }), $[2] = t1, $[3] = t2) : t2 = $[3], t2;
  }
  if (release.metadata.releaseType === "asap") {
    let t1;
    $[4] !== t ? (t1 = t("release.type.asap"), $[4] = t, $[5] = t1) : t1 = $[5];
    let t2;
    return $[6] !== t1 ? (t2 = /* @__PURE__ */ jsx(Text, { size: 1, children: t1 }), $[6] = t1, $[7] = t2) : t2 = $[7], t2;
  }
  if (release.metadata.releaseType === "scheduled") {
    const isActive = release.state === "active";
    let t1;
    return $[8] !== isActive || $[9] !== release || $[10] !== t ? (t1 = release.metadata.intendedPublishAt && /* @__PURE__ */ jsx(Text, { size: 1, children: isActive ? /* @__PURE__ */ jsx(Translate, { t, i18nKey: "release.chip.tooltip.intended-for-date", values: {
      date: formatRelativeLocalePublishDate(release)
    } }) : /* @__PURE__ */ jsx(Translate, { t, i18nKey: "release.chip.tooltip.scheduled-for-date", values: {
      date: formatRelativeLocalePublishDate(release)
    } }) }), $[8] = isActive, $[9] = release, $[10] = t, $[11] = t1) : t1 = $[11], t1;
  }
  if (release.metadata.releaseType === "undecided") {
    let t1;
    $[12] !== t ? (t1 = t("release.type.undecided"), $[12] = t, $[13] = t1) : t1 = $[13];
    let t2;
    return $[14] !== t1 ? (t2 = /* @__PURE__ */ jsx(Text, { size: 1, children: t1 }), $[14] = t1, $[15] = t2) : t2 = $[15], t2;
  }
  return null;
}, DATE_TIME_FORMAT = {
  dateStyle: "medium",
  timeStyle: "short"
}, DocumentPerspectiveList = memo(function() {
  const {
    selectedReleaseId,
    selectedPerspectiveName
  } = usePerspective(), {
    t
  } = useTranslation(), setPerspective = useSetPerspective(), {
    params,
    setParams
  } = usePaneRouter(), dateTimeFormat = useDateTimeFormat(DATE_TIME_FORMAT), {
    loading
  } = useActiveReleases(), schema = useSchema(), {
    editState,
    displayed,
    documentType,
    documentId
  } = useDocumentPane(), isCreatingDocument = displayed && !displayed._createdAt, filteredReleases = useFilteredReleases({
    displayed,
    documentId
  }), onlyHasVersions = useOnlyHasVersions({
    documentId
  }), workspace = useWorkspace(), handlePerspectiveChange = useCallback((perspective) => () => {
    perspective === "published" && params?.historyVersion && setParams({
      ...params,
      rev: params?.historyEvent || void 0,
      since: void 0,
      historyVersion: void 0
    }), setPerspective(perspective);
  }, [setPerspective, setParams, params]), schemaType = schema.get(documentType), isLiveEdit = schemaType ? isLiveEditEnabled(schemaType) : !1, isPublishedChipDisabled = useMemo(() => isLiveEdit && !selectedReleaseId ? !1 : !editState?.published, [isLiveEdit, selectedReleaseId, editState?.published]), getReleaseChipState = useCallback((release) => {
    if (!params?.historyVersion) return {
      selected: getReleaseIdFromReleaseDocumentId(release._id) === getVersionFromId(displayed?._id || "")
    };
    const isReleaseHistoryMatch = getReleaseIdFromReleaseDocumentId(release._id) === params.historyVersion;
    return {
      selected: isReleaseHistoryMatch,
      disabled: isReleaseHistoryMatch
    };
  }, [displayed?._id, params?.historyVersion]), isPublishSelected = useMemo(() => !!(isLiveEdit && !editState?.draft?._id && !selectedReleaseId || isPublishedId(displayed?._id || "") && isPublishedPerspective(selectedPerspectiveName || "")), [displayed?._id, editState?.draft?._id, isLiveEdit, selectedPerspectiveName, selectedReleaseId]), isDraftSelected = useMemo(() => {
    const displayedId = displayed?._id || "";
    return isPublishSelected || params?.historyVersion || selectedPerspectiveName || isVersionId(displayedId) ? !1 : isDraftId(displayedId) ? !0 : !(isPublishedId(displayedId) && editState?.published && isPublishedPerspective(selectedPerspectiveName || ""));
  }, [displayed?._id, editState?.published, isPublishSelected, params?.historyVersion, selectedPerspectiveName]), isDraftDisabled = useMemo(() => onlyHasVersions || isCreatingDocument && selectedReleaseId ? !0 : !editState?.draft && !isLiveEdit ? !1 : !!(isCreatingDocument && selectedReleaseId || isLiveEdit), [editState?.draft, isCreatingDocument, isLiveEdit, onlyHasVersions, selectedReleaseId]), isDraftModelEnabled = workspace.document.drafts?.enabled;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(VersionChip, { tooltipContent: /* @__PURE__ */ jsx(Text, { size: 1, children: editState?.published && editState?.published?._updatedAt ? /* @__PURE__ */ jsx(Translate, { t, i18nKey: "release.chip.tooltip.published-date", values: {
      date: dateTimeFormat.format(new Date(editState?.published._updatedAt))
    } }) : /* @__PURE__ */ jsx(Fragment, { children: t("release.chip.tooltip.not-published") }) }), disabled: isPublishedChipDisabled, onClick: handlePerspectiveChange("published"), selected: isPublishSelected, text: t("release.chip.published"), tone: "positive", contextValues: {
      documentId: editState?.published?._id || editState?.id || "",
      menuReleaseId: editState?.published?._id || editState?.id || "",
      releases: filteredReleases.notCurrentReleases,
      releasesLoading: loading,
      documentType,
      fromRelease: "published",
      isVersion: !1,
      disabled: !editState?.published
    } }),
    isDraftModelEnabled && /* @__PURE__ */ jsx(VersionChip, { tooltipContent: /* @__PURE__ */ jsx(Text, { size: 1, children: editState?.draft ? /* @__PURE__ */ jsx(Fragment, { children: editState?.draft._updatedAt ? /* @__PURE__ */ jsx(Translate, { t, i18nKey: "release.chip.tooltip.edited-date", values: {
      date: dateTimeFormat.format(new Date(editState?.draft._updatedAt))
    } }) : /* @__PURE__ */ jsx(Translate, { t, i18nKey: "release.chip.tooltip.created-date", values: {
      date: dateTimeFormat.format(new Date(editState?.draft._createdAt))
    } }) }) : /* @__PURE__ */ jsx(Fragment, { children: t(isLiveEdit ? "release.chip.tooltip.draft-disabled.live-edit" : "release.chip.tooltip.no-edits") }) }), selected: isDraftSelected, disabled: isDraftDisabled, text: t("release.chip.draft"), tone: editState?.draft ? "caution" : "neutral", onClick: handlePerspectiveChange("drafts"), contextValues: {
      documentId: editState?.draft?._id || editState?.published?._id || editState?.id || "",
      menuReleaseId: editState?.draft?._id || editState?.published?._id || editState?.id || "",
      releases: filteredReleases.notCurrentReleases,
      releasesLoading: loading,
      documentType,
      fromRelease: "draft",
      isVersion: !1,
      disabled: !editState?.draft
    } }),
    filteredReleases.inCreation && /* @__PURE__ */ jsx(VersionChip, { tooltipContent: /* @__PURE__ */ jsx(TooltipContent$1, { release: filteredReleases.inCreation }), selected: !0, onClick: () => {
    }, locked: !1, tone: getReleaseTone(filteredReleases.inCreation), text: filteredReleases.inCreation.metadata.title || t("release.placeholder-untitled-release"), contextValues: {
      disabled: !0,
      // disable the chip context menu, this one is in creation
      documentId: displayed?._id || "",
      menuReleaseId: filteredReleases.inCreation._id,
      releases: filteredReleases.notCurrentReleases,
      releasesLoading: loading,
      documentType,
      fromRelease: getReleaseIdFromReleaseDocumentId(filteredReleases.inCreation._id),
      releaseState: filteredReleases.inCreation.state,
      isVersion: !0
    } }),
    displayed && filteredReleases.currentReleases?.map((release_0) => /* @__PURE__ */ jsx(VersionChip, { tooltipContent: /* @__PURE__ */ jsx(TooltipContent$1, { release: release_0 }), ...getReleaseChipState(release_0), onClick: handlePerspectiveChange(getReleaseIdFromReleaseDocumentId(release_0._id)), text: release_0.metadata.title || t("release.placeholder-untitled-release"), tone: getReleaseTone(release_0), locked: isReleaseScheduledOrScheduling(release_0), contextValues: {
      documentId: displayed?._id || "",
      menuReleaseId: release_0._id,
      releases: filteredReleases.notCurrentReleases,
      releasesLoading: loading,
      documentType,
      fromRelease: getReleaseIdFromReleaseDocumentId(release_0._id),
      releaseState: release_0.state,
      isVersion: !0
    } }, release_0._id))
  ] });
}), HorizontalScroller = styled(Card)((props) => {
  const theme = getTheme_v2(props.theme);
  return css`
    scrollbar-width: none;
    z-index: 1;
    flex: 1;
    position: relative;
    > div {
      &::-webkit-scrollbar {
        width: 0;
        height: 0;
      }
    }

    ${props.$showGradient && css`
      &::after {
        content: '';
        display: block;
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 150px;
        background: linear-gradient(to right, ${rgba(theme.color.bg, 0)}, var(--card-bg-color));
        transition: 'opacity 300ms ease-out';
        pointer-events: none;
      }
    `}
  `;
}), DocumentPanelHeader = memo(forwardRef(function(_props, ref) {
  const {
    menuItems
  } = _props, {
    actions: allActions,
    editState,
    onMenuAction,
    isInitialValueLoading,
    onPaneClose,
    onPaneSplit,
    menuItemGroups,
    schemaType,
    connectionState,
    views,
    unstable_languageFilter
  } = useDocumentPane(), {
    features
  } = useStructureTool(), {
    index,
    BackLink: BackLink2,
    hasGroupSiblings
  } = usePaneRouter(), {
    actions: fieldActions
  } = useFieldActions(), [referenceElement, setReferenceElement] = useState(null), scrollContainerRef = useRef(null), showGradient = useChipScrollPosition(scrollContainerRef), actions = useMemo(() => (allActions ?? []).filter((action) => !isRestoreAction(action)), [allActions]), menuNodes = useMemo(() => resolveMenuNodes({
    actionHandler: onMenuAction,
    fieldActions,
    menuItems,
    menuItemGroups
  }), [onMenuAction, fieldActions, menuItemGroups, menuItems]), menuButtonNodes = useMemo(() => menuNodes.filter(isMenuNodeButton), [menuNodes]), contextMenuNodes = useMemo(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]), {
    collapsed,
    isLast
  } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, showSplitPaneButton = features.splitViews && onPaneSplit && views.length > 1, showSplitPaneCloseButton = showSplitPaneButton && hasGroupSiblings, showBackButton = features.backButton && index > 0, showPaneGroupCloseButton = !showSplitPaneCloseButton && !showBackButton && !!BackLink2, {
    t
  } = useTranslation(structureLocaleNamespace), renderPaneActions = useCallback(({
    states
  }) => /* @__PURE__ */ jsx(DocumentPanelHeaderActionDialogDeferred, { contextMenuNodes, setReferenceElement, referenceElement, states }), [contextMenuNodes, referenceElement]), title = useMemo(() => /* @__PURE__ */ jsx(DocumentHeaderTitle, {}), []), backButton = useMemo(() => showBackButton && /* @__PURE__ */ jsx(Button, { as: BackLink2, "data-as": "a", icon: ArrowLeftIcon, mode: "bleed", tooltipProps: {
    content: t("pane-header.back-button.text")
  } }), [BackLink2, showBackButton, t]), renderedActions = useMemo(() => /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, children: [
    unstable_languageFilter.length > 0 && /* @__PURE__ */ jsx(Fragment, { children: unstable_languageFilter.map((LanguageFilterComponent, idx) => /* @__PURE__ */ jsx(
      LanguageFilterComponent,
      {
        schemaType
      },
      `language-filter-${idx}`
    )) }),
    menuButtonNodes.map((item) => /* @__PURE__ */ jsx(PaneHeaderActionButton, { node: item }, item.key)),
    editState && /* @__PURE__ */ jsx(RenderActionCollectionState, { actions, actionProps: {
      ...editState,
      initialValueResolved: !isInitialValueLoading
    }, group: "paneActions", children: renderPaneActions }),
    showSplitPaneButton && /* @__PURE__ */ jsx(Button, { "aria-label": t("buttons.split-pane-button.aria-label"), icon: SplitVerticalIcon, mode: "bleed", onClick: onPaneSplit, tooltipProps: {
      content: t("buttons.split-pane-button.tooltip")
    } }, "split-pane-button"),
    showSplitPaneCloseButton && /* @__PURE__ */ jsx(Button, { icon: CloseIcon, mode: "bleed", onClick: onPaneClose, tooltipProps: {
      content: t("buttons.split-pane-close-button.title")
    } }, "close-view-button"),
    showPaneGroupCloseButton && /* @__PURE__ */ jsx(Button, { icon: CloseIcon, mode: "bleed", tooltipProps: {
      content: t("buttons.split-pane-close-group-button.title")
    }, as: BackLink2 }, "close-view-button")
  ] }), [BackLink2, actions, editState, isInitialValueLoading, menuButtonNodes, onPaneClose, onPaneSplit, renderPaneActions, schemaType, showPaneGroupCloseButton, showSplitPaneButton, showSplitPaneCloseButton, t, unstable_languageFilter]);
  return /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: collapsed ? /* @__PURE__ */ jsx(PaneHeader$1, { border: !0, ref, loading: connectionState === "connecting" && !editState?.draft && !editState?.published, title, tabIndex, backButton }) : /* @__PURE__ */ jsx(Card, { hidden: collapsed, style: {
    lineHeight: 0
  }, borderBottom: !0, children: /* @__PURE__ */ jsxs(Flex, { gap: 3, paddingY: 3, children: [
    /* @__PURE__ */ jsx(HorizontalScroller, { $showGradient: showGradient, children: /* @__PURE__ */ jsx(Flex, { flex: 1, gap: 1, overflow: "auto", paddingX: 3, "data-testid": "document-perspective-list", ref: scrollContainerRef, children: /* @__PURE__ */ jsx(DocumentPerspectiveList, {}) }) }),
    /* @__PURE__ */ jsx(Box, { flex: "none", paddingRight: 3, children: renderedActions })
  ] }) }) });
})), DocumentPanelHeaderActionDialogDeferred = memo(function(props) {
  const $ = c(5), {
    setReferenceElement,
    referenceElement,
    contextMenuNodes
  } = props, states = useDeferredValue(props.states);
  let t0;
  return $[0] !== contextMenuNodes || $[1] !== referenceElement || $[2] !== setReferenceElement || $[3] !== states ? (t0 = /* @__PURE__ */ jsx(DocumentPanelHeaderActionDialog, { setReferenceElement, referenceElement, contextMenuNodes, states }), $[0] = contextMenuNodes, $[1] = referenceElement, $[2] = setReferenceElement, $[3] = states, $[4] = t0) : t0 = $[4], t0;
}), DocumentPanelHeaderActionDialog = memo(function(props) {
  const $ = c(8), {
    states,
    setReferenceElement,
    contextMenuNodes,
    referenceElement
  } = props;
  let t0;
  $[0] !== contextMenuNodes || $[1] !== setReferenceElement || $[2] !== states ? (t0 = (t12) => {
    const {
      handleAction
    } = t12;
    return /* @__PURE__ */ jsx("div", { ref: setReferenceElement, children: /* @__PURE__ */ jsx(PaneContextMenuButton, { nodes: contextMenuNodes, actionsNodes: states.length > 0 ? states.map((actionState, actionIndex) => /* @__PURE__ */ jsx(ActionMenuListItem, { actionState, disabled: !!actionState.disabled, index: actionIndex, onAction: handleAction }, actionState.label)) : void 0 }, "context-menu") });
  }, $[0] = contextMenuNodes, $[1] = setReferenceElement, $[2] = states, $[3] = t0) : t0 = $[3];
  const renderActionDialog = t0;
  let t1;
  return $[4] !== referenceElement || $[5] !== renderActionDialog || $[6] !== states ? (t1 = /* @__PURE__ */ jsx(ActionDialogWrapper, { actionStates: states, referenceElement, children: renderActionDialog }), $[4] = referenceElement, $[5] = renderActionDialog, $[6] = states, $[7] = t1) : t1 = $[7], t1;
});
function SpacerButton(t0) {
  const $ = c(3), {
    size
  } = t0;
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = {
    pointerEvents: "none",
    visibility: "hidden",
    width: 0
  }, $[0] = t1) : t1 = $[0];
  let t2;
  return $[1] !== size ? (t2 = /* @__PURE__ */ jsx(Button, { "aria-hidden": !0, disabled: !0, size, style: t1, text: "-" }), $[1] = size, $[2] = t2) : t2 = $[2], t2;
}
const BADGE_TONES = {
  primary: "primary",
  success: "positive",
  warning: "caution",
  danger: "critical"
}, DocumentBadgesInner = memo(function(t0) {
  const $ = c(4), {
    states
  } = t0;
  if (states.length === 0)
    return null;
  let t1;
  $[0] !== states ? (t1 = states.map(_temp$b), $[0] = states, $[1] = t1) : t1 = $[1];
  let t2;
  return $[2] !== t1 ? (t2 = /* @__PURE__ */ jsx(Inline, { space: 1, children: t1 }), $[2] = t1, $[3] = t2) : t2 = $[3], t2;
}), DocumentBadgesDeferred = memo(function(props) {
  const $ = c(2), states = useDeferredValue(props.states);
  let t0;
  return $[0] !== states ? (t0 = /* @__PURE__ */ jsx(DocumentBadgesInner, { states }), $[0] = states, $[1] = t0) : t0 = $[1], t0;
});
function DocumentBadges() {
  const $ = c(3), {
    badges,
    editState
  } = useDocumentPane(), renderDocumentBadges = _temp2$3;
  if (!editState || !badges)
    return null;
  let t0;
  return $[0] !== badges || $[1] !== editState ? (t0 = /* @__PURE__ */ jsx(RenderBadgeCollectionState, { badges, badgeProps: editState, children: renderDocumentBadges }), $[0] = badges, $[1] = editState, $[2] = t0) : t0 = $[2], t0;
}
function _temp2$3(t0) {
  const {
    states
  } = t0;
  return /* @__PURE__ */ jsx(DocumentBadgesDeferred, { states });
}
function _temp$b(badge, index) {
  return /* @__PURE__ */ jsx(Tooltip, { content: badge.title, disabled: !badge.title, placement: "top", portal: !0, children: /* @__PURE__ */ jsx(Badge, { fontSize: 1, mode: "outline", paddingX: 2, paddingY: 1, radius: 4, tone: badge.color ? BADGE_TONES[badge.color] : void 0, style: {
    whiteSpace: "nowrap"
  }, children: badge.label }) }, `${badge.label}-${index}`);
}
const TIMELINE_ICON_COMPONENTS = {
  create: AddIcon,
  delete: TrashIcon,
  discardDraft: CloseIcon,
  initial: AddIcon,
  editDraft: EditIcon,
  editLive: EditIcon,
  publish: PublishIcon,
  unpublish: UnpublishIcon
};
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
function hideScrollbarOnExpand(isExpanded2) {
  if (isExpanded2) return;
  const listWrapper = document.getElementById(TIMELINE_LIST_WRAPPER_ID$1);
  if (listWrapper) {
    const firstChildren = listWrapper.children[0];
    if (!(firstChildren.scrollHeight > firstChildren.clientHeight)) {
      const currentStyle = getComputedStyle(firstChildren).overflowY;
      firstChildren.style.overflowY = "hidden", setTimeout(() => {
        firstChildren.style.overflowY = currentStyle;
      }, 0);
    }
  }
}
const FlipIcon = styled(ChevronLeftIcon)`
  transition: transform 200ms;
  &[data-expanded='true'] {
    transform: rotate(-90deg);
  }
`;
function ExpandableTimelineItemButton(t0) {
  const $ = c(14), {
    isExpanded: isExpanded2,
    onExpand
  } = t0, {
    t
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== isExpanded2 || $[1] !== onExpand ? (t1 = (e) => {
    e.stopPropagation(), hideScrollbarOnExpand(isExpanded2), onExpand();
  }, $[0] = isExpanded2, $[1] = onExpand, $[2] = t1) : t1 = $[2];
  const handleExpandClick = t1;
  let t2;
  $[3] !== isExpanded2 ? (t2 = /* @__PURE__ */ jsx(FlipIcon, { "data-expanded": isExpanded2 }), $[3] = isExpanded2, $[4] = t2) : t2 = $[4];
  let t3;
  $[5] !== isExpanded2 || $[6] !== t ? (t3 = t(isExpanded2 ? "timeline-item.menu.action-collapse" : "timeline-item.menu.action-expand"), $[5] = isExpanded2, $[6] = t, $[7] = t3) : t3 = $[7];
  let t4;
  $[8] !== t3 ? (t4 = {
    content: t3
  }, $[8] = t3, $[9] = t4) : t4 = $[9];
  let t5;
  return $[10] !== handleExpandClick || $[11] !== t2 || $[12] !== t4 ? (t5 = /* @__PURE__ */ jsx(Button, { mode: "bleed", icon: t2, tooltipProps: t4, onClick: handleExpandClick }), $[10] = handleExpandClick, $[11] = t2, $[12] = t4, $[13] = t5) : t5 = $[13], t5;
}
const StackWrapper = styled(Stack)`
  max-width: 200px;
`, ListWrapper = styled(Flex)`
  max-height: ${(props) => props.$maxHeight};
  min-width: 244px;
`, Root$2 = styled(Box)(({
  $visible
}) => css`
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;

    ${$visible && css`
      opacity: 1;
      pointer-events: auto;
    `}
  `), TIMELINE_ITEM_I18N_KEY_MAPPING = {
  initial: "timeline.operation.created-initial",
  create: "timeline.operation.created",
  publish: "timeline.operation.published",
  editLive: "timeline.operation.edited-live",
  editDraft: "timeline.operation.edited-draft",
  unpublish: "timeline.operation.unpublished",
  discardDraft: "timeline.operation.draft-discarded",
  delete: "timeline.operation.deleted"
};
function UserAvatarStack(t0) {
  const $ = c(9), {
    maxLength,
    userIds,
    size,
    withTooltip: t1
  } = t0, withTooltip = t1 === void 0 ? !0 : t1;
  let t2;
  if ($[0] !== userIds || $[1] !== withTooltip) {
    let t32;
    $[3] !== withTooltip ? (t32 = (userId) => /* @__PURE__ */ jsx(UserAvatar, { user: userId, withTooltip }, userId), $[3] = withTooltip, $[4] = t32) : t32 = $[4], t2 = userIds.map(t32), $[0] = userIds, $[1] = withTooltip, $[2] = t2;
  } else
    t2 = $[2];
  let t3;
  return $[5] !== maxLength || $[6] !== size || $[7] !== t2 ? (t3 = /* @__PURE__ */ jsx(AvatarStack, { maxLength, size, children: t2 }), $[5] = maxLength, $[6] = size, $[7] = t2, $[8] = t3) : t3 = $[8], t3;
}
const IconBox = styled(Flex)((props) => {
  const theme = getTheme_v2(props.theme), color = props.$color;
  return css`
    --card-icon-color: ${theme.color.avatar[color].fg};
    background-color: ${theme.color.avatar[color].bg};
    box-shadow: 0 0 0 1px var(--card-bg-color);

    position: absolute;
    width: ${theme.avatar.sizes[0].size}px;
    height: ${theme.avatar.sizes[0].size}px;
    right: -3px;
    bottom: -3px;
    border-radius: 50%;
  `;
}), TIMELINE_ITEM_EVENT_TONE = {
  initial: "blue",
  create: "blue",
  publish: "green",
  editLive: "green",
  editDraft: "yellow",
  unpublish: "orange",
  discardDraft: "orange",
  delete: "red",
  withinSelection: "magenta"
}, RELATIVE_TIME_OPTIONS$1 = {
  minimal: !0,
  useTemporalPhrase: !0
}, NameSkeleton = styled(Skeleton)((props) => {
  const theme = getTheme_v2(props.theme);
  return css`
    width: 6ch;
    height: ${theme.font.text.sizes[0].lineHeight}px;
  `;
}), UserLine = (t0) => {
  const $ = c(10), {
    userId
  } = t0, [user, loading] = useUser(userId);
  let t1;
  $[0] !== loading || $[1] !== user ? (t1 = /* @__PURE__ */ jsx(Box, { children: loading || !user ? /* @__PURE__ */ jsx(AvatarSkeleton, { animated: !0 }) : /* @__PURE__ */ jsx(UserAvatar, { user }) }), $[0] = loading, $[1] = user, $[2] = t1) : t1 = $[2];
  let t2;
  $[3] !== loading || $[4] !== user ? (t2 = /* @__PURE__ */ jsx(Box, { children: loading || !user?.displayName ? /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(NameSkeleton, { animated: !0 }) }) : /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: user.displayName }) }), $[3] = loading, $[4] = user, $[5] = t2) : t2 = $[5];
  let t3;
  return $[6] !== t1 || $[7] !== t2 || $[8] !== userId ? (t3 = /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, padding: 1, children: [
    t1,
    t2
  ] }, userId), $[6] = t1, $[7] = t2, $[8] = userId, $[9] = t3) : t3 = $[9], t3;
}, TooltipContent = (t0) => {
  const $ = c(9), {
    collaborators
  } = t0, {
    t
  } = useTranslation("studio");
  let t1;
  $[0] !== t ? (t1 = t("timeline.changes.title"), $[0] = t, $[1] = t1) : t1 = $[1];
  let t2;
  $[2] !== t1 ? (t2 = /* @__PURE__ */ jsx(Box, { padding: 1, paddingBottom: 2, children: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t1 }) }), $[2] = t1, $[3] = t2) : t2 = $[3];
  let t3;
  $[4] !== collaborators ? (t3 = collaborators.map(_temp$a), $[4] = collaborators, $[5] = t3) : t3 = $[5];
  let t4;
  return $[6] !== t2 || $[7] !== t3 ? (t4 = /* @__PURE__ */ jsxs(Stack, { paddingBottom: 1, children: [
    t2,
    t3
  ] }), $[6] = t2, $[7] = t3, $[8] = t4) : t4 = $[8], t4;
};
function TimelineItem(t0) {
  const $ = c(55), {
    chunk,
    isSelected,
    onSelect,
    collaborators,
    optionsMenu
  } = t0, {
    t
  } = useTranslation("studio"), {
    type,
    endTimestamp: timestamp
  } = chunk;
  let t1;
  $[0] !== type ? (t1 = getTimelineEventIconComponent(type), $[0] = type, $[1] = t1) : t1 = $[1];
  const IconComponent = t1;
  let t2;
  $[2] !== chunk.authors ? (t2 = Array.from(chunk.authors), $[2] = chunk.authors, $[3] = t2) : t2 = $[3];
  const authorUserIds = t2;
  let t3;
  $[4] !== collaborators ? (t3 = collaborators ? Array.from(collaborators) : [], $[4] = collaborators, $[5] = t3) : t3 = $[5];
  const collaboratorsUsersIds = t3, isSelectable = type !== "delete";
  let t4;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t4 = {
    dateStyle: "medium",
    timeStyle: "short"
  }, $[6] = t4) : t4 = $[6];
  const dateFormat = useDateTimeFormat(t4);
  let t5;
  $[7] !== timestamp ? (t5 = new Date(timestamp), $[7] = timestamp, $[8] = t5) : t5 = $[8];
  const updatedTimeAgo = useRelativeTime(t5 || "", RELATIVE_TIME_OPTIONS$1);
  let t6, t7;
  if ($[9] !== dateFormat || $[10] !== timestamp) {
    const parsedDate = new Date(timestamp);
    t7 = dateFormat.format(parsedDate), $[9] = dateFormat, $[10] = timestamp, $[11] = t7;
  } else
    t7 = $[11];
  t6 = t7;
  const formattedTimestamp = t6;
  let t8;
  $[12] !== chunk || $[13] !== isSelectable || $[14] !== onSelect ? (t8 = (evt) => {
    evt.preventDefault(), evt.stopPropagation(), isSelectable && onSelect(chunk);
  }, $[12] = chunk, $[13] = isSelectable, $[14] = onSelect, $[15] = t8) : t8 = $[15];
  const handleClick = t8;
  let t9;
  $[16] === Symbol.for("react.memo_cache_sentinel") ? (t9 = {
    position: "relative"
  }, $[16] = t9) : t9 = $[16];
  let t10;
  $[17] !== authorUserIds ? (t10 = /* @__PURE__ */ jsx(UserAvatarStack, { maxLength: 3, userIds: authorUserIds, size: 2 }), $[17] = authorUserIds, $[18] = t10) : t10 = $[18];
  const t11 = TIMELINE_ITEM_EVENT_TONE[type];
  let t12;
  $[19] !== IconComponent ? (t12 = IconComponent && /* @__PURE__ */ jsx(IconComponent, {}), $[19] = IconComponent, $[20] = t12) : t12 = $[20];
  let t13;
  $[21] !== t12 ? (t13 = /* @__PURE__ */ jsx(Text, { size: 0, children: t12 }), $[21] = t12, $[22] = t13) : t13 = $[22];
  let t14;
  $[23] !== t11 || $[24] !== t13 ? (t14 = /* @__PURE__ */ jsx(IconBox, { align: "center", justify: "center", $color: t11, children: t13 }), $[23] = t11, $[24] = t13, $[25] = t14) : t14 = $[25];
  let t15;
  $[26] !== t10 || $[27] !== t14 ? (t15 = /* @__PURE__ */ jsxs("div", { style: t9, children: [
    t10,
    t14
  ] }), $[26] = t10, $[27] = t14, $[28] = t15) : t15 = $[28];
  let t16;
  $[29] !== t || $[30] !== type ? (t16 = t(TIMELINE_ITEM_I18N_KEY_MAPPING[type]) || /* @__PURE__ */ jsx("code", { children: type }), $[29] = t, $[30] = type, $[31] = t16) : t16 = $[31];
  let t17;
  $[32] !== t16 ? (t17 = /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t16 }), $[32] = t16, $[33] = t17) : t17 = $[33];
  let t18;
  $[34] !== formattedTimestamp || $[35] !== timestamp || $[36] !== updatedTimeAgo ? (t18 = /* @__PURE__ */ jsx(Text, { as: "time", size: 1, muted: !0, dateTime: timestamp, title: formattedTimestamp, children: updatedTimeAgo }), $[34] = formattedTimestamp, $[35] = timestamp, $[36] = updatedTimeAgo, $[37] = t18) : t18 = $[37];
  let t19;
  $[38] !== t17 || $[39] !== t18 ? (t19 = /* @__PURE__ */ jsxs(Stack, { space: 2, children: [
    t17,
    t18
  ] }), $[38] = t17, $[39] = t18, $[40] = t19) : t19 = $[40];
  let t20;
  $[41] !== collaboratorsUsersIds ? (t20 = collaboratorsUsersIds.length > 0 && /* @__PURE__ */ jsx(Flex, { flex: 1, justify: "flex-end", align: "center", children: /* @__PURE__ */ jsx(Tooltip, { placement: "top", content: /* @__PURE__ */ jsx(TooltipContent, { collaborators: collaboratorsUsersIds }), portal: !0, children: /* @__PURE__ */ jsx(Box, { paddingLeft: 2, paddingY: 2, children: /* @__PURE__ */ jsx(UserAvatarStack, { maxLength: 3, userIds: collaboratorsUsersIds, size: 0, withTooltip: !1 }) }) }) }), $[41] = collaboratorsUsersIds, $[42] = t20) : t20 = $[42];
  let t21;
  $[43] !== t15 || $[44] !== t19 || $[45] !== t20 ? (t21 = /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
    t15,
    t19,
    t20
  ] }), $[43] = t15, $[44] = t19, $[45] = t20, $[46] = t21) : t21 = $[46];
  let t22;
  $[47] !== chunk.id || $[48] !== handleClick || $[49] !== isSelected || $[50] !== t21 ? (t22 = /* @__PURE__ */ jsx(Card, { as: "button", onClick: handleClick, padding: 2, pressed: isSelected, radius: 2, "data-ui": "timelineItem", "data-testid": "timeline-item-button", "data-chunk-id": chunk.id, children: t21 }), $[47] = chunk.id, $[48] = handleClick, $[49] = isSelected, $[50] = t21, $[51] = t22) : t22 = $[51];
  let t23;
  return $[52] !== optionsMenu || $[53] !== t22 ? (t23 = /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, children: [
    t22,
    optionsMenu
  ] }), $[52] = optionsMenu, $[53] = t22, $[54] = t23) : t23 = $[54], t23;
}
function _temp$a(userId) {
  return /* @__PURE__ */ jsx(UserLine, { userId }, userId);
}
const isNonPublishChunk = (chunk) => chunk.type !== "publish", isPublishChunk = (chunk) => chunk.type === "publish";
function getPreviousPublishAction(chunks) {
  let previousPublish = null;
  for (let index = chunks.length - 1; index >= 0; index--) {
    const chunk = chunks[index];
    if (isPublishChunk(chunk)) {
      previousPublish = chunk;
      break;
    }
    if (chunk.type !== "editDraft")
      break;
  }
  return previousPublish;
}
function addChunksMetadata(chunks) {
  const result = [];
  for (const chunk of chunks) {
    if (isPublishChunk(chunk)) {
      result.push({
        ...chunk,
        type: "publish",
        children: [],
        collaborators: /* @__PURE__ */ new Set()
        // Initialize the collaborators array
      });
      continue;
    }
    if (isNonPublishChunk(chunk)) {
      const previousPublish = getPreviousPublishAction(result);
      if (chunk.type === "editDraft" && previousPublish?.type === "publish") {
        Array.from(chunk.authors).forEach((id) => {
          previousPublish.collaborators.add(id);
        }), previousPublish.children.push(chunk.id), result.push({
          ...chunk,
          parentId: previousPublish.id
        });
        continue;
      }
    }
    isNonPublishChunk(chunk) && result.push(chunk);
  }
  return result;
}
const TIMELINE_LIST_WRAPPER_ID$1 = "timeline-list-wrapper", Timeline = ({
  chunks,
  hasMoreChunks,
  lastChunk: selectedChunk,
  onLoadMore,
  onSelect,
  listMaxHeight = "calc(100vh - 280px)"
}) => {
  const [mounted, setMounted] = useState(!1), {
    t
  } = useTranslation("studio"), selectedChunkId = selectedChunk?.id, chunksWithMetadata = useMemo(() => addChunksMetadata(chunks), [chunks]), [expandedParents, setExpandedParents] = useState(() => {
    if (selectedChunkId) {
      const selected = chunksWithMetadata.find((chunk) => chunk.id === selectedChunkId);
      if (selected && isNonPublishChunk(selected) && selected.parentId)
        return /* @__PURE__ */ new Set([selected.parentId]);
    }
    return /* @__PURE__ */ new Set();
  });
  useEffect(() => {
    if (selectedChunkId) {
      const selected_0 = chunksWithMetadata.find((chunk_0) => chunk_0.id === selectedChunkId);
      if (selected_0 && isNonPublishChunk(selected_0) && selected_0.parentId) {
        const parentId = selected_0.parentId;
        setExpandedParents((prev) => {
          if (prev.has(parentId)) return prev;
          const next = new Set(prev);
          return next.add(parentId), next;
        });
      }
    }
  }, [chunksWithMetadata, selectedChunkId]);
  const filteredChunks = useMemo(() => chunksWithMetadata.filter((chunk_1) => isPublishChunk(chunk_1) || !chunk_1.parentId ? !0 : expandedParents.has(chunk_1.parentId)), [chunksWithMetadata, expandedParents]);
  useEffect(() => {
    filteredChunks.length < 16 && hasMoreChunks && onLoadMore();
  }, [filteredChunks, hasMoreChunks, onLoadMore]);
  const handleExpandParent = useCallback((parentId_0) => () => setExpandedParents((prev_0) => {
    const next_0 = new Set(prev_0);
    return prev_0.has(parentId_0) ? next_0.delete(parentId_0) : next_0.add(parentId_0), next_0;
  }), []), selectedIndex = useMemo(() => selectedChunkId ? filteredChunks.findIndex((chunk_2) => chunk_2.id === selectedChunkId) : -1, [selectedChunkId, filteredChunks]), handleSelectChunk = useCallback((chunk_3) => {
    const timelineChunk = chunks.find((c2) => c2.id === chunk_3.id);
    timelineChunk ? onSelect(timelineChunk) : (console.error("TimelineItem: chunk not found"), onSelect(chunk_3));
  }, [chunks, onSelect]), renderItem = useCallback((chunk_4, {
    activeIndex
  }) => /* @__PURE__ */ jsxs(Box, { paddingBottom: 1, paddingTop: activeIndex === 0 ? 1 : 0, paddingRight: 1, paddingLeft: isNonPublishChunk(chunk_4) && chunk_4.parentId ? 4 : 1, children: [
    /* @__PURE__ */ jsx(TimelineItem, { chunk: chunk_4, isSelected: selectedChunkId === chunk_4.id, onSelect: handleSelectChunk, collaborators: isPublishChunk(chunk_4) ? chunk_4.collaborators : void 0, optionsMenu: isPublishChunk(chunk_4) && chunk_4.children.length > 0 ? /* @__PURE__ */ jsx(ExpandableTimelineItemButton, { isExpanded: expandedParents.has(chunk_4.id), onExpand: handleExpandParent(chunk_4.id) }) : null }),
    activeIndex === filteredChunks.length - 1 && hasMoreChunks && /* @__PURE__ */ jsx(LoadingBlock, {})
  ] }), [expandedParents, filteredChunks.length, handleExpandParent, handleSelectChunk, hasMoreChunks, selectedChunkId]);
  return useEffect(() => setMounted(!0), []), /* @__PURE__ */ jsxs(
    Root$2,
    {
      $visible: !selectedIndex || mounted,
      "data-ui": "timeline",
      children: [
        filteredChunks.length === 0 && /* @__PURE__ */ jsxs(StackWrapper, { padding: 3, space: 3, children: [
          /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t("timeline.error.no-document-history-title") }),
          /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("timeline.error.no-document-history-description") })
        ] }),
        filteredChunks.length > 0 && /* @__PURE__ */ jsx(ListWrapper, { direction: "column", $maxHeight: listMaxHeight, id: TIMELINE_LIST_WRAPPER_ID$1, children: /* @__PURE__ */ jsx(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t("timeline.list.aria-label"), autoFocus: "list", initialIndex: selectedIndex, initialScrollAlign: "center", itemHeight: 57, items: filteredChunks, onEndReached: onLoadMore, onEndReachedIndexOffset: 20, overscan: 5, renderItem, wrapAround: !1 }) })
      ]
    }
  );
};
Timeline.displayName = "Timeline";
function TimelineError(t0) {
  const $ = c(14), {
    versionError
  } = t0, {
    t
  } = useTranslation("studio");
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = /* @__PURE__ */ jsx(TextWithTone, { tone: "critical", children: /* @__PURE__ */ jsx(ErrorOutlineIcon, {}) }), $[0] = t1) : t1 = $[0];
  let t2;
  $[1] !== t || $[2] !== versionError ? (t2 = t(versionError ? "timeline.error.load-document-changes-version-title" : "timeline.error.load-document-changes-title"), $[1] = t, $[2] = versionError, $[3] = t2) : t2 = $[3];
  let t3;
  $[4] !== t2 ? (t3 = /* @__PURE__ */ jsx(TextWithTone, { size: 1, tone: "critical", weight: "medium", children: t2 }), $[4] = t2, $[5] = t3) : t3 = $[5];
  let t4;
  $[6] !== t || $[7] !== versionError ? (t4 = t(versionError ? "timeline.error.load-document-changes-version-description" : "timeline.error.load-document-changes-description"), $[6] = t, $[7] = versionError, $[8] = t4) : t4 = $[8];
  let t5;
  $[9] !== t4 ? (t5 = /* @__PURE__ */ jsx(TextWithTone, { size: 1, tone: "critical", children: t4 }), $[9] = t4, $[10] = t5) : t5 = $[10];
  let t6;
  return $[11] !== t3 || $[12] !== t5 ? (t6 = /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 3, padding: 4, children: [
    t1,
    /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
      t3,
      t5
    ] })
  ] }), $[11] = t3, $[12] = t5, $[13] = t6) : t6 = $[13], t6;
}
const Root$1 = styled(Popover)`
  overflow: hidden;
  overflow: clip;
`, TIMELINE_MENU_PORTAL$1 = "timeline-menu";
function TimelineMenu({
  chunk,
  mode,
  placement
}) {
  const {
    setTimelineRange,
    timelineError,
    ready,
    timelineStore
  } = useDocumentPane(), [open, setOpen] = useState(!1), [button, setButton] = useState(null), [popoverRef, setPopoverRef] = useState(null), toast = useToast(), chunks = useTimelineSelector(timelineStore, (state2) => state2.chunks), loading = useTimelineSelector(timelineStore, (state_0) => state_0.isLoading), hasMoreChunks = useTimelineSelector(timelineStore, (state_1) => state_1.hasMoreChunks), realRevChunk = useTimelineSelector(timelineStore, (state_2) => state_2.realRevChunk), sinceTime = useTimelineSelector(timelineStore, (state_3) => state_3.sinceTime), {
    t
  } = useTranslation("studio"), handleOpen = useCallback(() => {
    setOpen(!0);
  }, []), handleClose = useCallback(() => {
    setOpen(!1);
  }, []), handleGlobalKeyDown = useCallback((event) => {
    open && (event.key === "Escape" || event.key === "Tab") && (handleClose(), button?.focus());
  }, [button, handleClose, open]);
  useGlobalKeyDown(handleGlobalKeyDown), useClickOutsideEvent(open && handleClose, () => [button, popoverRef]);
  const selectRev = useCallback((revChunk) => {
    try {
      const [sinceId, revId] = timelineStore?.findRangeForRev(revChunk) || [null, null];
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({
        closable: !0,
        description: err.message,
        status: "error",
        title: t("timeline.error.unable-to-load-revision")
      });
    }
  }, [setTimelineRange, t, timelineStore, toast]), selectSince = useCallback((sinceChunk) => {
    try {
      const [sinceId_0, revId_0] = timelineStore?.findRangeForSince(sinceChunk) || [null, null];
      setTimelineRange(sinceId_0, revId_0);
    } catch (err_0) {
      toast.push({
        closable: !0,
        description: err_0.message,
        status: "error",
        title: t("timeline.error.unable-to-load-revision")
      });
    }
  }, [setTimelineRange, t, timelineStore, toast]), handleLoadMore = useCallback(() => {
    loading || timelineStore?.loadMore();
  }, [loading, timelineStore]), content = useMemo(() => {
    if (timelineError) return /* @__PURE__ */ jsx(TimelineError, {});
    if (mode === "rev")
      return /* @__PURE__ */ jsx(Timeline, { chunks, hasMoreChunks, lastChunk: realRevChunk, onLoadMore: handleLoadMore, onSelect: selectRev });
    const filteredChunks = realRevChunk ? chunks.filter((c2) => c2.index < realRevChunk.index) : chunks;
    return /* @__PURE__ */ jsx(Timeline, { chunks: filteredChunks, hasMoreChunks, lastChunk: sinceTime, onLoadMore: handleLoadMore, onSelect: selectSince });
  }, [chunks, handleLoadMore, hasMoreChunks, mode, realRevChunk, selectRev, selectSince, sinceTime, timelineError]), formatParams2 = {
    timestamp: {
      dateStyle: "medium",
      timeStyle: "short"
    }
  }, revLabel = chunk ? t(TIMELINE_ITEM_I18N_KEY_MAPPING[chunk.type], {
    context: "timestamp",
    timestamp: new Date(chunk?.endTimestamp),
    formatParams: formatParams2
  }) : t("timeline.latest-revision"), sinceLabel = chunk ? t("timeline.since", {
    timestamp: new Date(chunk?.endTimestamp),
    formatParams: formatParams2
  }) : t("timeline.since-version-missing"), buttonLabel = mode === "rev" ? revLabel : sinceLabel;
  return /* @__PURE__ */ jsx(PortalProvider, { __unstable_elements: {
    [TIMELINE_MENU_PORTAL$1]: popoverRef
  }, children: /* @__PURE__ */ jsx(Root$1, { "data-testid": "timeline-menu", constrainSize: !0, content: open && content, "data-ui": "versionMenu", open, placement, matchReferenceWidth: !0, portal: !0, ref: setPopoverRef, children: /* @__PURE__ */ jsx(Flex, { width: "fill", children: /* @__PURE__ */ jsx(Button, { "data-testid": open ? "timeline-menu-close-button" : "timeline-menu-open-button", disabled: !ready, mode: "ghost", onClick: open ? handleClose : handleOpen, ref: setButton, selected: open, width: "fill", tooltipProps: null, justify: "space-between", style: {
    maxWidth: "100%"
  }, iconRight: ChevronDownIcon, text: ready ? buttonLabel : t("timeline.loading-history") }) }) }) });
}
const StyledMotionPath = styled(motion.path)`
  transform-origin: center;
`, Circle = (props) => {
  const $ = c(2);
  let t0;
  return $[0] !== props ? (t0 = /* @__PURE__ */ jsx(motion.circle, { fill: "none", r: "8", cx: "12.5", cy: "12.5", strokeWidth: "1.2", ...props }), $[0] = props, $[1] = t0) : t0 = $[1], t0;
}, Arrows = (props) => {
  const $ = c(2);
  let t0;
  return $[0] !== props ? (t0 = /* @__PURE__ */ jsx(StyledMotionPath, { fill: "none", d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811", ...props }), $[0] = props, $[1] = t0) : t0 = $[1], t0;
}, Checkmark = (props) => {
  const $ = c(2);
  let t0;
  return $[0] !== props ? (t0 = /* @__PURE__ */ jsx(motion.path, { d: "M9.5 12.1316L11.7414 14.5L16 10", ...props }), $[0] = props, $[1] = t0) : t0 = $[1], t0;
}, rotateAnimation = keyframes`
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(360deg);
  }
`, RotateGroup = styled.g`
  transform-origin: center;

  &[data-rotate] {
    animation: ${rotateAnimation} 1s ease-in-out infinite;
  }
`, root = {
  syncing: {
    scale: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    scale: [1, 0.8, 1.2, 0.9, 1.1, 0.95, 1.05, 0.99, 1],
    transition: {
      duration: 0.5,
      delay: 0.2
    }
  },
  changes: {
    transition: {
      duration: 0
    }
  }
}, circle = {
  syncing: {
    strokeDasharray: "0, 0, 23, 3, 23, 3",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    strokeDasharray: "0, 0, 23, 0, 23, 0",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    strokeDasharray: "0, 60, 23, 0, 23, 0",
    strokeDashoffset: 0,
    opacity: 0,
    transition: {
      duration: 0.5
    }
  }
}, arrows = {
  syncing: {
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    opacity: 0,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    opacity: 0
  }
}, checkmark = {
  syncing: {
    pathLength: 0,
    transition: {
      duration: 0
    }
  },
  saved: {
    pathLength: 1,
    transition: {
      delay: 0.4,
      duration: 0.3
    }
  },
  changes: {
    pathLength: 0,
    transition: {
      duration: 0.2
    }
  }
};
function AnimatedStatusIcon(props) {
  const $ = c(13), {
    status
  } = props;
  if (!status)
    return null;
  const t0 = status === "changes" ? void 0 : "";
  let t1, t2;
  $[0] !== status ? (t1 = /* @__PURE__ */ jsx(Arrows, { variants: arrows, initial: status, animate: status }), t2 = /* @__PURE__ */ jsx(Circle, { variants: circle, initial: status, animate: status }), $[0] = status, $[1] = t1, $[2] = t2) : (t1 = $[1], t2 = $[2]);
  let t3;
  $[3] !== t0 || $[4] !== t1 || $[5] !== t2 ? (t3 = /* @__PURE__ */ jsxs(RotateGroup, { "data-rotate": t0, children: [
    t1,
    t2
  ] }), $[3] = t0, $[4] = t1, $[5] = t2, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== status ? (t4 = /* @__PURE__ */ jsx(Checkmark, { variants: checkmark, initial: status, animate: status }), $[7] = status, $[8] = t4) : t4 = $[8];
  let t5;
  return $[9] !== status || $[10] !== t3 || $[11] !== t4 ? (t5 = /* @__PURE__ */ jsx("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", stroke: "currentColor", strokeWidth: "1.2", "data-sanity-icon": "animated-status-icon", children: /* @__PURE__ */ jsxs(motion.g, { variants: root, initial: status, animate: status, children: [
    t3,
    t4
  ] }) }), $[9] = status, $[10] = t3, $[11] = t4, $[12] = t5) : t5 = $[12], t5;
}
const STATUS_DICTIONARY = {
  saved: {
    i18nKey: "status-bar.document-status-pulse.status.saved.text",
    tone: "positive"
  },
  syncing: {
    i18nKey: "status-bar.document-status-pulse.status.syncing.text",
    tone: "default"
  }
}, DocumentStatusPulse = (props) => {
  const $ = c(13), {
    status
  } = props, {
    t
  } = useTranslation(structureLocaleNamespace);
  if (status !== "saved" && status !== "syncing")
    return null;
  const currentStatus = STATUS_DICTIONARY[status];
  let t0;
  $[0] !== status ? (t0 = /* @__PURE__ */ jsx(AnimatedStatusIcon, { status }), $[0] = status, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== currentStatus.tone || $[3] !== t0 ? (t1 = /* @__PURE__ */ jsx(TextWithTone, { size: 1, tone: currentStatus.tone, children: t0 }), $[2] = currentStatus.tone, $[3] = t0, $[4] = t1) : t1 = $[4];
  let t2;
  $[5] !== currentStatus.i18nKey || $[6] !== t ? (t2 = t(currentStatus.i18nKey), $[5] = currentStatus.i18nKey, $[6] = t, $[7] = t2) : t2 = $[7];
  let t3;
  $[8] !== t2 ? (t3 = /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t2 }), $[8] = t2, $[9] = t3) : t3 = $[9];
  let t4;
  return $[10] !== t1 || $[11] !== t3 ? (t4 = /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, "data-testid": "pane-footer-document-status-pulse", children: [
    t1,
    t3
  ] }), $[10] = t1, $[11] = t3, $[12] = t4) : t4 = $[12], t4;
}, RELATIVE_TIME_OPTIONS = {
  minimal: !0,
  useTemporalPhrase: !0
}, MotionButton = motion.create(Button$1), MotionBox = motion.create(Box), ButtonSkeleton = () => {
  const $ = c(2);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ jsx("div", { style: {
    margin: -5
  }, children: /* @__PURE__ */ jsx(AvatarSkeleton, { $size: 0, animated: !0 }) }), $[0] = t0) : t0 = $[0];
  let t1;
  return $[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, paddingLeft: 1, paddingRight: 2, paddingY: 2, children: [
    t0,
    /* @__PURE__ */ jsx(Skeleton, { animated: !0, style: {
      width: "80px",
      height: "15px"
    }, radius: 2 })
  ] }), $[1] = t1) : t1 = $[1], t1;
}, DocumentStatusButton = (t0) => {
  const $ = c(17), {
    author,
    translationKey,
    timestamp: t1
  } = t0, timestamp = t1 === void 0 ? "" : t1, {
    onHistoryOpen,
    inspector,
    onHistoryClose
  } = useDocumentPane(), {
    t
  } = useTranslation(), relativeTime = useRelativeTime(timestamp, RELATIVE_TIME_OPTIONS);
  let t2, t3, t4;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {
    opacity: 1
  }, t3 = {
    opacity: 0
  }, t4 = {
    opacity: 0
  }, $[0] = t2, $[1] = t3, $[2] = t4) : (t2 = $[0], t3 = $[1], t4 = $[2]);
  const t5 = inspector?.name === HISTORY_INSPECTOR_NAME ? onHistoryClose : onHistoryOpen;
  let t6;
  $[3] !== author ? (t6 = author && /* @__PURE__ */ jsx("div", { style: {
    margin: -5
  }, children: /* @__PURE__ */ jsx(UserAvatar, { user: author, size: 0 }) }), $[3] = author, $[4] = t6) : t6 = $[4];
  let t7;
  $[5] !== t || $[6] !== translationKey ? (t7 = t(translationKey), $[5] = t, $[6] = translationKey, $[7] = t7) : t7 = $[7];
  let t8;
  $[8] !== relativeTime || $[9] !== t7 ? (t8 = /* @__PURE__ */ jsxs(Text, { muted: !0, size: 1, children: [
    t7,
    " ",
    relativeTime
  ] }), $[8] = relativeTime, $[9] = t7, $[10] = t8) : t8 = $[10];
  let t9;
  $[11] !== t6 || $[12] !== t8 ? (t9 = /* @__PURE__ */ jsxs(Flex, { align: "center", flex: "none", gap: 3, children: [
    t6,
    t8
  ] }), $[11] = t6, $[12] = t8, $[13] = t9) : t9 = $[13];
  let t10;
  return $[14] !== t5 || $[15] !== t9 ? (t10 = /* @__PURE__ */ jsx(MotionButton, { "data-testid": "pane-footer-document-status", animate: t2, initial: t3, exit: t4, mode: "bleed", onClick: t5, padding: 2, muted: !0, children: t9 }), $[14] = t5, $[15] = t9, $[16] = t10) : t10 = $[16], t10;
}, FallbackStatus = () => {
  const {
    editState
  } = useDocumentPane(), {
    selectedPerspective
  } = usePerspective(), status = useMemo(() => isPublishedPerspective(selectedPerspective) && editState?.published?._updatedAt ? {
    translationKey: TIMELINE_ITEM_I18N_KEY_MAPPING$1.published.createDocumentVersion,
    timestamp: editState.published._updatedAt
  } : editState?.version?._updatedAt ? {
    translationKey: editState?.version?._updatedAt === editState?.version?._createdAt ? TIMELINE_ITEM_I18N_KEY_MAPPING$1.version.createDocumentVersion : TIMELINE_ITEM_I18N_KEY_MAPPING$1.version.editDocumentVersion,
    timestamp: editState.version._updatedAt
  } : editState?.draft?._updatedAt ? {
    translationKey: editState?.draft?._updatedAt === editState?.draft?._createdAt ? TIMELINE_ITEM_I18N_KEY_MAPPING$1.draft.createDocumentVersion : TIMELINE_ITEM_I18N_KEY_MAPPING$1.draft.editDocumentVersion,
    timestamp: editState.draft._updatedAt
  } : null, [selectedPerspective, editState?.published?._updatedAt, editState?.version?._updatedAt, editState?.version?._createdAt, editState?.draft?._updatedAt, editState?.draft?._createdAt]);
  return status ? /* @__PURE__ */ jsx(DocumentStatusButton, { author: "", translationKey: status.translationKey, timestamp: status.timestamp }) : null;
}, EventsStatus = () => {
  const $ = c(6), {
    events,
    loading
  } = useEvents(), event = events?.[0];
  if (!event && loading) {
    let t02;
    return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t02 = /* @__PURE__ */ jsx(ButtonSkeleton, {}), $[0] = t02) : t02 = $[0], t02;
  }
  if (!event) {
    let t02;
    return $[1] === Symbol.for("react.memo_cache_sentinel") ? (t02 = /* @__PURE__ */ jsx(FallbackStatus, {}), $[1] = t02) : t02 = $[1], t02;
  }
  const t0 = TIMELINE_ITEM_I18N_KEY_MAPPING$1[event.documentVariantType][event.type];
  let t1;
  return $[2] !== event.author || $[3] !== event.timestamp || $[4] !== t0 ? (t1 = /* @__PURE__ */ jsx(DocumentStatusButton, { author: event.author, translationKey: t0, timestamp: event.timestamp }), $[2] = event.author, $[3] = event.timestamp, $[4] = t0, $[5] = t1) : t1 = $[5], t1;
}, TimelineStatus = () => {
  const $ = c(8), {
    timelineStore
  } = useDocumentPane(), chunks = useTimelineSelector(timelineStore, _temp$9), loading = useTimelineSelector(timelineStore, _temp2$2), event = chunks?.[0];
  if (!event && loading) {
    let t02;
    return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t02 = /* @__PURE__ */ jsx(ButtonSkeleton, {}), $[0] = t02) : t02 = $[0], t02;
  }
  if (!event) {
    let t02;
    return $[1] === Symbol.for("react.memo_cache_sentinel") ? (t02 = /* @__PURE__ */ jsx(FallbackStatus, {}), $[1] = t02) : t02 = $[1], t02;
  }
  let t0;
  $[2] !== event.authors ? (t0 = Array.from(event.authors), $[2] = event.authors, $[3] = t0) : t0 = $[3];
  const author = t0[0], t1 = TIMELINE_ITEM_I18N_KEY_MAPPING[event.type];
  let t2;
  return $[4] !== author || $[5] !== event.endTimestamp || $[6] !== t1 ? (t2 = /* @__PURE__ */ jsx(DocumentStatusButton, { author, translationKey: t1, timestamp: event.endTimestamp }), $[4] = author, $[5] = event.endTimestamp, $[6] = t1, $[7] = t2) : t2 = $[7], t2;
}, SYNCING_TIMEOUT = 1e3, SAVED_TIMEOUT = 3e3;
function DocumentStatusLine() {
  const $ = c(18), {
    documentId,
    documentType,
    editState,
    value
  } = useDocumentPane(), [status, setStatus] = useState(null), eventsEnabled = useSource().beta?.eventsAPI?.documents, syncState = useSyncState(documentId, documentType, editState?.release), lastUpdated = value?._updatedAt;
  let t0;
  $[0] !== status || $[1] !== syncState.isSyncing ? (t0 = () => {
    if (status === "syncing" && !syncState.isSyncing) {
      const timerId = setTimeout(() => setStatus("saved"), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }
    if (status === "saved") {
      const timerId_0 = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId_0);
    }
  }, $[0] = status, $[1] = syncState.isSyncing, $[2] = t0) : t0 = $[2];
  let t1;
  $[3] !== lastUpdated || $[4] !== status || $[5] !== syncState.isSyncing ? (t1 = [status, lastUpdated, syncState.isSyncing], $[3] = lastUpdated, $[4] = status, $[5] = syncState.isSyncing, $[6] = t1) : t1 = $[6], useEffect(t0, t1);
  let t2;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t2 = () => {
    setStatus(null);
  }, $[7] = t2) : t2 = $[7];
  let t3;
  $[8] !== documentId ? (t3 = [documentId], $[8] = documentId, $[9] = t3) : t3 = $[9], useLayoutEffect(t2, t3);
  let t4;
  $[10] !== syncState.isSyncing ? (t4 = () => {
    syncState.isSyncing && setStatus("syncing");
  }, $[10] = syncState.isSyncing, $[11] = t4) : t4 = $[11];
  let t5;
  $[12] !== lastUpdated || $[13] !== syncState.isSyncing ? (t5 = [syncState.isSyncing, lastUpdated], $[12] = lastUpdated, $[13] = syncState.isSyncing, $[14] = t5) : t5 = $[14], useLayoutEffect(t4, t5);
  let t6;
  return $[15] !== eventsEnabled || $[16] !== status ? (t6 = /* @__PURE__ */ jsx(AnimatePresence, { children: status ? /* @__PURE__ */ jsx(MotionBox, { paddingLeft: 2, animate: {
    opacity: 1
  }, initial: {
    opacity: 0
  }, exit: {
    opacity: 0
  }, children: /* @__PURE__ */ jsx(DocumentStatusPulse, { status: status || void 0 }) }) : /* @__PURE__ */ jsx(Fragment, { children: eventsEnabled ? /* @__PURE__ */ jsx(EventsStatus, {}) : /* @__PURE__ */ jsx(TimelineStatus, {}) }) }), $[15] = eventsEnabled, $[16] = status, $[17] = t6) : t6 = $[17], t6;
}
function _temp$9(state2) {
  return state2.chunks;
}
function _temp2$2(state_0) {
  return state_0.isLoading;
}
const StatusText = styled(Text)`
  color: var(--card-muted-fg-color);

  em {
    color: var(--card-fg-color);
    font-weight: 500;
    font-style: normal;
  }
`;
function RevisionStatusLine() {
  const $ = c(12), {
    displayed,
    revisionNotFound
  } = useDocumentPane(), {
    t
  } = useTranslation(), date = displayed?._updatedAt || displayed?._createdAt;
  let t0;
  $[0] !== date || $[1] !== t ? (t0 = date ? /* @__PURE__ */ jsx(Translate, { t, i18nKey: "document-status.revision-from", values: {
    date: format(new Date(date), "MMM d, yyyy '@' pp")
  } }) : null, $[0] = date, $[1] = t, $[2] = t0) : t0 = $[2];
  let t1;
  $[3] !== t0 ? (t1 = {
    name: "revision",
    text: t0,
    tone: "caution"
  }, $[3] = t0, $[4] = t1) : t1 = $[4];
  const message = t1;
  let t2;
  $[5] === Symbol.for("react.memo_cache_sentinel") ? (t2 = /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(RestoreIcon, {}) }) }), $[5] = t2) : t2 = $[5];
  let t3;
  $[6] !== message || $[7] !== revisionNotFound || $[8] !== t ? (t3 = revisionNotFound ? /* @__PURE__ */ jsx(Translate, { t, i18nKey: "document-status.revision-not-found" }) : message.text, $[6] = message, $[7] = revisionNotFound, $[8] = t, $[9] = t3) : t3 = $[9];
  let t4;
  return $[10] !== t3 ? (t4 = /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsxs(Flex, { flex: 1, gap: 3, padding: 2, children: [
    t2,
    /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(StatusText, { size: 1, textOverflow: "ellipsis", children: t3 }) })
  ] }) }), $[10] = t3, $[11] = t4) : t4 = $[11], t4;
}
function useResizeObserver(t0) {
  const $ = c(4), {
    element,
    onResize
  } = t0;
  let t1, t2;
  $[0] !== element || $[1] !== onResize ? (t1 = () => (element && resizeObserver.observe(element, onResize), () => {
    element && resizeObserver.unobserve(element);
  }), t2 = [element, onResize], $[0] = element, $[1] = onResize, $[2] = t1, $[3] = t2) : (t1 = $[2], t2 = $[3]), useLayoutEffect(t1, t2);
}
const CONTAINER_BREAKPOINT = 480, AnimatedCard = motion.create(Card);
function DocumentStatusBar(props) {
  const $ = c(22), {
    actionsBoxRef,
    createLinkMetadata
  } = props, {
    editState,
    onChange: onDocumentChange,
    revisionNotFound
  } = useDocumentPane(), {
    params: t0
  } = usePaneRouter(), params = t0 === void 0 ? EMPTY_PARAMS$2 : t0, {
    selectedPerspective
  } = usePerspective(), {
    title
  } = useDocumentTitle(), CreateLinkedActions = useSanityCreateConfig().components?.documentLinkedActions, showingRevision = !!params.rev, [collapsed, setCollapsed] = useState(null), [rootElement, setRootElement] = useState(null);
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = (event) => {
    setCollapsed(event.contentRect.width < CONTAINER_BREAKPOINT);
  }, $[0] = t1) : t1 = $[0];
  const handleResize = t1;
  let t2;
  $[1] !== rootElement ? (t2 = {
    element: rootElement,
    onResize: handleResize
  }, $[1] = rootElement, $[2] = t2) : t2 = $[2], useResizeObserver(t2);
  let t3;
  bb0: {
    const isReady = !!(editState?.ready && typeof collapsed == "boolean");
    if (selectedPerspective) {
      if (isPublishedPerspective(selectedPerspective)) {
        t3 = isReady && !!editState?.published;
        break bb0;
      }
      if (isReleaseDocument(selectedPerspective)) {
        t3 = isReady && !!editState?.version;
        break bb0;
      }
    }
    t3 = isReady;
  }
  const shouldRender = t3;
  let actions;
  if (createLinkMetadata && isSanityCreateLinked(createLinkMetadata) && CreateLinkedActions) {
    let t42;
    $[3] !== CreateLinkedActions || $[4] !== createLinkMetadata || $[5] !== onDocumentChange || $[6] !== title ? (t42 = /* @__PURE__ */ jsx(CreateLinkedActions, { metadata: createLinkMetadata, panelPortalElementId: DOCUMENT_PANEL_PORTAL_ELEMENT, onDocumentChange, documentTitle: title }), $[3] = CreateLinkedActions, $[4] = createLinkMetadata, $[5] = onDocumentChange, $[6] = title, $[7] = t42) : t42 = $[7], actions = t42;
  } else if (showingRevision) {
    let t42;
    $[8] === Symbol.for("react.memo_cache_sentinel") ? (t42 = /* @__PURE__ */ jsx(HistoryStatusBarActions, {}), $[8] = t42) : t42 = $[8], actions = t42;
  } else {
    let t42;
    $[9] === Symbol.for("react.memo_cache_sentinel") ? (t42 = /* @__PURE__ */ jsx(DocumentStatusBarActions, {}), $[9] = t42) : t42 = $[9], actions = t42;
  }
  if (showingRevision && revisionNotFound)
    return null;
  const t4 = showingRevision ? "revision" : "published";
  let t5;
  $[10] === Symbol.for("react.memo_cache_sentinel") ? (t5 = {
    opacity: 0.2
  }, $[10] = t5) : t5 = $[10];
  let t6;
  $[11] === Symbol.for("react.memo_cache_sentinel") ? (t6 = {
    opacity: 1,
    transition: {
      duration: 0.3
    }
  }, $[11] = t6) : t6 = $[11];
  const t7 = showingRevision ? "caution" : void 0;
  let t8;
  $[12] !== actions || $[13] !== actionsBoxRef || $[14] !== collapsed || $[15] !== shouldRender || $[16] !== showingRevision ? (t8 = shouldRender && /* @__PURE__ */ jsxs(Flex, { align: "stretch", gap: 1, justify: "space-between", paddingLeft: showingRevision ? 0 : 1, paddingRight: showingRevision ? 0 : 1, children: [
    /* @__PURE__ */ jsxs(Flex, { align: "center", flex: 1, gap: collapsed ? 2 : 3, wrap: "wrap", paddingRight: 3, children: [
      /* @__PURE__ */ jsxs(Flex, { align: "center", children: [
        showingRevision ? /* @__PURE__ */ jsx(RevisionStatusLine, {}) : /* @__PURE__ */ jsx(DocumentStatusLine, {}),
        /* @__PURE__ */ jsx(SpacerButton, {})
      ] }),
      /* @__PURE__ */ jsx(DocumentBadges, {})
    ] }),
    /* @__PURE__ */ jsxs(Flex, { align: "flex-start", justify: "flex-end", ref: actionsBoxRef, style: {
      flexShrink: 0,
      marginLeft: "auto"
    }, children: [
      /* @__PURE__ */ jsx(SpacerButton, {}),
      actions
    ] })
  ] }), $[12] = actions, $[13] = actionsBoxRef, $[14] = collapsed, $[15] = shouldRender, $[16] = showingRevision, $[17] = t8) : t8 = $[17];
  let t9;
  return $[18] !== t4 || $[19] !== t7 || $[20] !== t8 ? (t9 = /* @__PURE__ */ jsx(AnimatedCard, { initial: t5, animate: t6, tone: t7, radius: 3, ref: setRootElement, sizing: "border", padding: 2, children: t8 }, t4), $[18] = t4, $[19] = t7, $[20] = t8, $[21] = t9) : t9 = $[21], t9;
}
const KeyboardShortcutResponder = memo(function(props) {
  const $ = c(26);
  let actionsBoxElement, activeIndex, children, id, onActionStart, onKeyDown, rest, rootRef, states, t0;
  $[0] !== props ? ({
    actionsBoxElement,
    activeIndex,
    as: t0,
    children,
    id,
    onActionStart,
    onKeyDown,
    rootRef,
    states,
    ...rest
  } = props, $[0] = props, $[1] = actionsBoxElement, $[2] = activeIndex, $[3] = children, $[4] = id, $[5] = onActionStart, $[6] = onKeyDown, $[7] = rest, $[8] = rootRef, $[9] = states, $[10] = t0) : (actionsBoxElement = $[1], activeIndex = $[2], children = $[3], id = $[4], onActionStart = $[5], onKeyDown = $[6], rest = $[7], rootRef = $[8], states = $[9], t0 = $[10]);
  const As = t0 === void 0 ? "div" : t0, activeAction = states[activeIndex];
  let t1;
  $[11] !== onActionStart || $[12] !== onKeyDown || $[13] !== states ? (t1 = (event) => {
    const matchingStates = states.filter((state2) => state2.shortcut && isHotkey(state2.shortcut, event)), matchingState = matchingStates[0];
    if (matchingStates.length > 1 && console.warn(`Keyboard shortcut conflict: More than one document action matches the shortcut "${matchingState.shortcut}"`), matchingState && !matchingState.disabled && matchingState.onHandle) {
      event.preventDefault(), matchingState.onHandle(), onActionStart(states.indexOf(matchingState));
      return;
    }
    onKeyDown && onKeyDown(event);
  }, $[11] = onActionStart, $[12] = onKeyDown, $[13] = states, $[14] = t1) : t1 = $[14];
  const handleKeyDown = t1;
  let t2;
  $[15] !== actionsBoxElement || $[16] !== activeAction ? (t2 = activeAction && activeAction.dialog && /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsx(ActionStateDialog, { dialog: activeAction.dialog, referenceElement: actionsBoxElement }) }), $[15] = actionsBoxElement, $[16] = activeAction, $[17] = t2) : t2 = $[17];
  let t3;
  return $[18] !== As || $[19] !== children || $[20] !== handleKeyDown || $[21] !== id || $[22] !== rest || $[23] !== rootRef || $[24] !== t2 ? (t3 = /* @__PURE__ */ jsxs(As, { id, onKeyDown: handleKeyDown, tabIndex: -1, ...rest, ref: rootRef, children: [
    children,
    t2
  ] }), $[18] = As, $[19] = children, $[20] = handleKeyDown, $[21] = id, $[22] = rest, $[23] = rootRef, $[24] = t2, $[25] = t3) : t3 = $[25], t3;
}), DocumentActionShortcuts = memo((props) => {
  const $ = c(20);
  let actionsBoxElement, children, rest, t0;
  $[0] !== props ? ({
    actionsBoxElement,
    as: t0,
    children,
    ...rest
  } = props, $[0] = props, $[1] = actionsBoxElement, $[2] = children, $[3] = rest, $[4] = t0) : (actionsBoxElement = $[1], children = $[2], rest = $[3], t0 = $[4]);
  const as = t0 === void 0 ? "div" : t0, {
    actions,
    editState,
    isInitialValueLoading,
    revisionId
  } = useDocumentPane(), [activeIndex, setActiveIndex] = useState(-1);
  let t1;
  $[5] === Symbol.for("react.memo_cache_sentinel") ? (t1 = (idx) => {
    setActiveIndex(idx);
  }, $[5] = t1) : t1 = $[5];
  const onActionStart = t1;
  let t2, t3;
  $[6] !== editState || $[7] !== isInitialValueLoading || $[8] !== revisionId ? (t3 = editState && {
    ...editState,
    onComplete: _temp$8,
    revision: revisionId || void 0,
    initialValueResolved: !isInitialValueLoading
  }, $[6] = editState, $[7] = isInitialValueLoading, $[8] = revisionId, $[9] = t3) : t3 = $[9], t2 = t3;
  const actionProps = t2;
  let t4;
  $[10] !== actionsBoxElement || $[11] !== activeIndex || $[12] !== as || $[13] !== children || $[14] !== rest ? (t4 = (t52) => {
    const {
      states
    } = t52;
    return /* @__PURE__ */ jsx(KeyboardShortcutResponder, { ...rest, activeIndex, actionsBoxElement, as, onActionStart, states, children });
  }, $[10] = actionsBoxElement, $[11] = activeIndex, $[12] = as, $[13] = children, $[14] = rest, $[15] = t4) : t4 = $[15];
  const renderDocumentActionShortcuts = t4;
  if (!actionProps || !actions)
    return null;
  let t5;
  return $[16] !== actionProps || $[17] !== actions || $[18] !== renderDocumentActionShortcuts ? (t5 = /* @__PURE__ */ jsx(RenderActionCollectionState, { actionProps, actions, children: renderDocumentActionShortcuts }), $[16] = actionProps, $[17] = actions, $[18] = renderDocumentActionShortcuts, $[19] = t5) : t5 = $[19], t5;
});
DocumentActionShortcuts.displayName = "Memo(DocumentActionShortcuts)";
function _temp$8() {
}
function getInspectorItems({
  currentInspector,
  hasValue,
  inspectors: inspectors2,
  inspectorMenuItems
}) {
  return inspectors2.map((inspector, index) => {
    const menuItem = inspectorMenuItems[index];
    return !menuItem || menuItem.hidden ? null : {
      action: `${INSPECT_ACTION_PREFIX}${inspector.name}`,
      group: menuItem.showAsAction ? void 0 : "inspectors",
      icon: menuItem.icon,
      disabled: !hasValue,
      selected: currentInspector?.name === inspector.name,
      shortcut: menuItem.hotkeys?.join("+"),
      showAsAction: menuItem.showAsAction,
      title: menuItem.title,
      tone: menuItem.tone
    };
  }).filter(Boolean);
}
function getInspectItem({
  hasValue,
  t
}) {
  return {
    action: "inspect",
    group: "inspectors",
    title: t("document-inspector.menu-item.title"),
    icon: JsonIcon,
    disabled: !hasValue,
    shortcut: "Ctrl+Alt+I"
  };
}
function getCompareVersionsItem({
  documentIdStack,
  t
}) {
  const disabled = typeof documentIdStack?.previousId > "u" && {
    reason: t("compare-versions.menu-item.disabled-reason")
  };
  return {
    action: "compareVersions",
    group: "inspectors",
    title: t("compare-versions.menu-item.title"),
    icon: TransferIcon,
    disabled
  };
}
function getProductionPreviewItem({
  previewUrl,
  t
}) {
  return previewUrl ? {
    action: "production-preview",
    group: "links",
    title: t("production-preview.menu-item.title"),
    icon: EarthAmericasIcon,
    shortcut: "Ctrl+Alt+O"
  } : null;
}
function getMenuItems(params) {
  const inspectorItems = getInspectorItems(params), items = [
    // Get production preview item
    getProductionPreviewItem(params),
    getCompareVersionsItem(params)
  ].filter(Boolean);
  return [
    // Always present document menu item to copy current url to clipboard
    {
      action: "copy-document-url",
      showAsAction: !0,
      title: params.t("action.copy-document-url.label"),
      icon: LinkIcon
    },
    ...inspectorItems,
    // TODO: convert to inspector or document view?
    getInspectItem(params),
    ...items
  ];
}
function DocumentLayoutError(props) {
  const $ = c(23), {
    documentType,
    value,
    currentMinWidth,
    paneKey,
    minWidth
  } = props, {
    t
  } = useTranslation();
  let t0;
  $[0] !== documentType ? (t0 = {
    documentType
  }, $[0] = documentType, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== t || $[3] !== t0 ? (t1 = /* @__PURE__ */ jsx(Translate, { t, i18nKey: "panes.document-pane.document-unknown-type.title", values: t0 }), $[2] = t, $[3] = t0, $[4] = t1) : t1 = $[4];
  let t2;
  $[5] !== documentType || $[6] !== t ? (t2 = documentType && /* @__PURE__ */ jsx(Text, { as: "p", children: /* @__PURE__ */ jsx(Translate, { t, i18nKey: "panes.document-pane.document-unknown-type.text", values: {
    documentType
  } }) }), $[5] = documentType, $[6] = t, $[7] = t2) : t2 = $[7];
  let t3;
  $[8] !== documentType || $[9] !== t ? (t3 = !documentType && /* @__PURE__ */ jsx(Text, { as: "p", children: t("panes.document-pane.document-unknown-type.without-schema.text") }), $[8] = documentType, $[9] = t, $[10] = t3) : t3 = $[10];
  let t4;
  $[11] !== value ? (t4 = isDev && value && /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Text, { as: "p", children: "Here is the JSON representation of the document:" }),
    /* @__PURE__ */ jsx(Card, { padding: 3, overflow: "auto", radius: 2, shadow: 1, tone: "inherit", children: /* @__PURE__ */ jsx(Code, { language: "json", size: [1, 1, 2], children: JSON.stringify(value, null, 2) }) })
  ] }), $[11] = value, $[12] = t4) : t4 = $[12];
  let t5;
  $[13] !== t2 || $[14] !== t3 || $[15] !== t4 ? (t5 = /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
    t2,
    t3,
    t4
  ] }), $[13] = t2, $[14] = t3, $[15] = t4, $[16] = t5) : t5 = $[16];
  let t6;
  return $[17] !== currentMinWidth || $[18] !== minWidth || $[19] !== paneKey || $[20] !== t1 || $[21] !== t5 ? (t6 = /* @__PURE__ */ jsx(ErrorPane, { currentMinWidth, flex: 2.5, minWidth, paneKey, title: t1, tone: "caution", children: t5 }), $[17] = currentMinWidth, $[18] = minWidth, $[19] = paneKey, $[20] = t1, $[21] = t5, $[22] = t6) : t6 = $[22], t6;
}
const DIALOG_PROVIDER_POSITION$1 = [
  // We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
  "fixed",
  "fixed",
  // And we use the `position: absolute` strategy (within panes) on wide screens.
  "absolute"
];
function DocumentLayoutFooter(t0) {
  const $ = c(16), {
    documentPanelPortalElement,
    setFooterElement,
    setActionsBoxElement
  } = t0, zOffsets = useZIndex(), {
    value
  } = useDocumentPane();
  let t1, t2;
  $[0] !== documentPanelPortalElement ? (t2 = {
    [DOCUMENT_PANEL_PORTAL_ELEMENT]: documentPanelPortalElement
  }, $[0] = documentPanelPortalElement, $[1] = t2) : t2 = $[1], t1 = t2;
  const portalElements = t1;
  let t3;
  $[2] !== value ? (t3 = getSanityCreateLinkMetadata(value), $[2] = value, $[3] = t3) : t3 = $[3];
  const createLinkMetadata = t3;
  let t4;
  $[4] !== createLinkMetadata || $[5] !== setActionsBoxElement ? (t4 = /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsx(DocumentStatusBar, { actionsBoxRef: setActionsBoxElement, createLinkMetadata }) }), $[4] = createLinkMetadata, $[5] = setActionsBoxElement, $[6] = t4) : t4 = $[6];
  let t5;
  $[7] !== setFooterElement || $[8] !== t4 ? (t5 = /* @__PURE__ */ jsx(PaneFooter, { ref: setFooterElement, padding: 1, children: t4 }), $[7] = setFooterElement, $[8] = t4, $[9] = t5) : t5 = $[9];
  let t6;
  $[10] !== t5 || $[11] !== zOffsets.portal ? (t6 = /* @__PURE__ */ jsx(DialogProvider, { position: DIALOG_PROVIDER_POSITION$1, zOffset: zOffsets.portal, children: t5 }), $[10] = t5, $[11] = zOffsets.portal, $[12] = t6) : t6 = $[12];
  let t7;
  return $[13] !== portalElements || $[14] !== t6 ? (t7 = /* @__PURE__ */ jsx(PortalProvider, { __unstable_elements: portalElements, children: t6 }), $[13] = portalElements, $[14] = t6, $[15] = t7) : t7 = $[15], t7;
}
const EMPTY_ARRAY = [], DIALOG_PROVIDER_POSITION = [
  // We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
  "fixed",
  "fixed",
  // And we use the `position: absolute` strategy (within panes) on wide screens.
  "absolute"
], StyledChangeConnectorRoot = styled(ChangeConnectorRoot)`
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  min-width: 0;
`;
function DocumentLayout() {
  const {
    changesOpen,
    displayed,
    documentId,
    documentType,
    editState,
    fieldActions,
    focusPath,
    inspectOpen,
    inspector,
    inspectors: inspectors2,
    onFocus,
    onHistoryOpen,
    onMenuAction,
    onPathOpen,
    paneKey,
    schemaType,
    value,
    previewUrl
  } = useDocumentPane(), {
    params: paneParams
  } = usePaneRouter(), {
    features
  } = useStructureTool(), {
    t
  } = useTranslation(structureLocaleNamespace), {
    collapsed: layoutCollapsed
  } = usePaneLayout(), zOffsets = useZIndex(), [rootElement, setRootElement] = useState(null), [footerElement, setFooterElement] = useState(null), [headerElement, setHeaderElement] = useState(null), [actionsBoxElement, setActionsBoxElement] = useState(null), [documentPanelPortalElement, setDocumentPanelPortalElement] = useState(null);
  useGlobalCopyPasteElementHandler({
    element: rootElement,
    focusPath,
    value
  });
  const [inspectorMenuItems, setInspectorMenuItems] = useState([]), [rootFieldActionNodes, setRootFieldActionNodes] = useState([]), footerRect = useElementRect(footerElement), headerRect = useElementRect(headerElement), footerHeight = footerRect?.height, headerHeight = headerRect?.height, currentMinWidth = DOCUMENT_PANEL_INITIAL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0), minWidth = DOCUMENT_PANEL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0), currentInspector = useMemo(() => inspectors2?.find((i) => i.name === inspector?.name), [inspectors2, inspector?.name]), documentIdStack = useDocumentIdStack({
    displayed,
    documentId,
    editState
  }), hasValue = !!value, menuItems = useMemo(() => getMenuItems({
    currentInspector,
    features,
    hasValue,
    inspectorMenuItems,
    inspectors: inspectors2,
    previewUrl,
    documentIdStack,
    t
  }), [currentInspector, documentIdStack, features, hasValue, inspectorMenuItems, inspectors2, previewUrl, t]), handleKeyUp = useCallback((event) => {
    for (const item of menuItems)
      if (item.shortcut && isHotkey(item.shortcut, event)) {
        event.preventDefault(), event.stopPropagation(), onMenuAction(item);
        return;
      }
  }, [onMenuAction, menuItems]), onConnectorSetFocus = useCallback((path) => {
    onPathOpen(path), onFocus(path);
  }, [onPathOpen, onFocus]);
  return schemaType ? /* @__PURE__ */ jsxs(GetFormValueProvider, { value, children: [
    inspectors2.length > 0 && /* @__PURE__ */ jsx(DocumentInspectorMenuItemsResolver, { documentId, documentType, inspectors: inspectors2, onMenuItems: setInspectorMenuItems }),
    fieldActions.length > 0 && schemaType && /* @__PURE__ */ jsx(FieldActionsResolver, { actions: fieldActions, documentId, documentType, onActions: setRootFieldActionNodes, path: EMPTY_ARRAY, schemaType }),
    /* @__PURE__ */ jsx(FieldActionsProvider, { actions: rootFieldActionNodes, path: EMPTY_ARRAY, children: /* @__PURE__ */ jsxs(DocumentActionShortcuts, { actionsBoxElement, as: Pane, currentMinWidth, "data-testid": "document-pane", flex: 2.5, id: paneKey, minWidth, onKeyUp: handleKeyUp, rootRef: setRootElement, children: [
      /* @__PURE__ */ jsx(DocumentPanelHeader, { ref: setHeaderElement, menuItems }),
      /* @__PURE__ */ jsx(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.paneDialog, children: /* @__PURE__ */ jsx(Flex, { direction: "column", flex: 1, height: layoutCollapsed ? void 0 : "fill", children: /* @__PURE__ */ jsx(StyledChangeConnectorRoot, { "data-testid": "change-connector-root", isReviewChangesOpen: changesOpen && paneParams?.changesInspectorTab === "review", onOpenReviewChanges: onHistoryOpen, onSetFocus: onConnectorSetFocus, children: /* @__PURE__ */ jsx(DocumentPanel, { footerHeight: footerHeight || null, headerHeight: headerHeight || null, isInspectOpen: inspectOpen, rootElement, setDocumentPanelPortalElement, footer: /* @__PURE__ */ jsx(DocumentLayoutFooter, { documentPanelPortalElement, setFooterElement, setActionsBoxElement }) }) }) }) }),
      /* @__PURE__ */ jsx(DocumentOperationResults, {})
    ] }) })
  ] }) : /* @__PURE__ */ jsx(DocumentLayoutError, { currentMinWidth, documentType, minWidth, paneKey, value });
}
function useDocumentLayoutComponent() {
  const $ = c(1);
  let t0;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    pick: pickDocumentLayoutComponent,
    defaultComponent: DocumentLayout
  }, $[0] = t0) : t0 = $[0], useMiddlewareComponents(t0);
}
const DocumentURLCopied = defineEvent({
  name: "DocumentURLCopied",
  version: 1,
  description: "User copied document URL to clipboard"
});
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {}, structureNodeTemplate = opts.templateName;
  opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate && console.warn(`Conflicting templates: URL says "${opts.urlTemplate}", structure node says "${structureNodeTemplate}". Using "${structureNodeTemplate}".`);
  const template = structureNodeTemplate || opts.urlTemplate, typeTemplates = templates.filter((t) => t.schemaType === opts.documentType), templateParams = {
    ...opts.templateParams,
    ...typeof payload == "object" ? payload || {} : {}
  };
  let templateName = template;
  return !template && typeTemplates.length === 1 && (templateName = typeTemplates[0].id), {
    templateName,
    templateParams
  };
}
const useDocumentPaneInitialValue = (t0) => {
  const $ = c(13), {
    paneOptions,
    documentType,
    documentId,
    params
  } = t0, templates = useTemplates(), paneRouter = usePaneRouter(), panePayload = useUnique(paneRouter.payload);
  let t1, t2;
  $[0] !== documentType || $[1] !== paneOptions.template || $[2] !== paneOptions.templateParameters || $[3] !== panePayload || $[4] !== params.template || $[5] !== templates ? (t2 = getInitialValueTemplateOpts(templates, {
    documentType,
    templateName: paneOptions.template,
    templateParams: paneOptions.templateParameters,
    panePayload,
    urlTemplate: params.template
  }), $[0] = documentType, $[1] = paneOptions.template, $[2] = paneOptions.templateParameters, $[3] = panePayload, $[4] = params.template, $[5] = templates, $[6] = t2) : t2 = $[6], t1 = t2;
  const {
    templateName,
    templateParams
  } = t1;
  let t3;
  $[7] !== documentId || $[8] !== documentType || $[9] !== params.version || $[10] !== templateName || $[11] !== templateParams ? (t3 = {
    documentId,
    documentType,
    templateName,
    templateParams,
    version: params.version
  }, $[7] = documentId, $[8] = documentType, $[9] = params.version, $[10] = templateName, $[11] = templateParams, $[12] = t3) : t3 = $[12];
  const initialValueRaw = useInitialValue(t3);
  return useUnique(initialValueRaw);
};
function useDocumentPaneInspector({
  documentId,
  documentType,
  params,
  setParams
}) {
  const {
    features
  } = useStructureTool(), inspectorsResolver = useSource().document.inspectors, inspectors2 = useMemo(() => inspectorsResolver({
    documentId,
    documentType
  }), [documentId, documentType, inspectorsResolver]), [inspectorName, setInspectorName] = useState(() => params.inspect || null), inspectParamRef = useRef(params.inspect);
  useEffect(() => {
    inspectParamRef.current !== params.inspect && (inspectParamRef.current = params.inspect, setInspectorName(params.inspect || null));
  }, [params.inspect]);
  const currentInspector = useMemo(() => inspectors2?.find((i) => i.name === inspectorName), [inspectors2, inspectorName]), historyInspector = useMemo(() => inspectors2.find((i_0) => i_0.name === HISTORY_INSPECTOR_NAME), [inspectors2]), changesOpen = currentInspector?.name === HISTORY_INSPECTOR_NAME, closeInspector = useCallback((closeInspectorName) => {
    const inspector = closeInspectorName && inspectors2.find((i_1) => i_1.name === closeInspectorName);
    if (closeInspectorName && !inspector) {
      console.warn(`No inspector named "${closeInspectorName}"`);
      return;
    }
    if (currentInspector) {
      if (inspector) {
        const result = inspector.onClose?.({
          params
        }) ?? {
          params
        };
        setInspectorName(null), inspectParamRef.current = void 0, setParams({
          ...result.params,
          inspect: void 0
        });
        return;
      }
      if (currentInspector) {
        const result_0 = currentInspector.onClose?.({
          params
        }) ?? {
          params
        };
        setInspectorName(null), inspectParamRef.current = void 0, setParams({
          ...result_0.params,
          inspect: void 0
        });
      }
    }
  }, [currentInspector, inspectors2, params, setParams]), openInspector = useCallback((nextInspectorName, paneParams) => {
    const nextInspector = inspectors2.find((i_2) => i_2.name === nextInspectorName);
    if (!nextInspector) {
      console.warn(`No inspector named "${nextInspectorName}"`);
      return;
    }
    if (currentInspector?.name === nextInspector.name) {
      setParams({
        ...params,
        ...paneParams,
        inspect: nextInspector.name
      });
      return;
    }
    let currentParams = params;
    currentInspector && (currentParams = (nextInspector.onClose?.({
      params: currentParams
    }) ?? {
      params: currentParams
    }).params);
    const result_1 = nextInspector.onOpen?.({
      params: currentParams
    }) ?? {
      params: currentParams
    };
    setInspectorName(nextInspector.name), inspectParamRef.current = nextInspector.name, setParams({
      ...result_1.params,
      ...paneParams,
      inspect: nextInspector.name
    });
  }, [currentInspector, inspectors2, params, setParams]), handleHistoryClose = useCallback(() => {
    historyInspector && closeInspector(historyInspector.name);
  }, [closeInspector, historyInspector]), handleHistoryOpen = useCallback(() => {
    features.reviewChanges && historyInspector && openInspector(historyInspector.name, {
      changesInspectorTab: "review"
    });
  }, [features.reviewChanges, openInspector, historyInspector]), inspectOpen = params.inspect === "on", toggleLegacyInspect = useCallback((toggle = !inspectOpen) => {
    setParams(toggle ? {
      ...params,
      inspect: "on"
    } : omit(params, "inspect"));
  }, [inspectOpen, params, setParams]), handleLegacyInspectClose = useCallback(() => toggleLegacyInspect(!1), [toggleLegacyInspect]), handleInspectorAction = useCallback((item) => {
    if (item.action === "inspect")
      return toggleLegacyInspect(!0), !0;
    if (typeof item.action != "string") return !1;
    const nextInspectorName_0 = item.action.slice(INSPECT_ACTION_PREFIX.length), nextInspector_0 = inspectors2.find((i_3) => i_3.name === nextInspectorName_0);
    return nextInspector_0 ? (nextInspector_0.name === inspectorName ? closeInspector(nextInspector_0.name) : openInspector(nextInspector_0.name), !0) : !1;
  }, [closeInspector, inspectorName, inspectors2, openInspector, toggleLegacyInspect]);
  return {
    changesOpen,
    currentInspector,
    inspectors: inspectors2,
    closeInspector,
    openInspector,
    handleHistoryClose,
    handleHistoryOpen,
    handleInspectorAction,
    // TODO: Deprecate this legacy inspect toggle it's used to render the <InspectDialog /> component
    handleLegacyInspectClose,
    inspectOpen
  };
}
const isSanityDocument = (value) => isRecord(value) && typeof value._id == "string" && typeof value._type == "string";
function usePreviewUrl(value) {
  const $ = c(6), {
    resolveProductionUrl
  } = useSource().document;
  let t0, t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = new BehaviorSubject(void 0), $[0] = t1) : t1 = $[0], t0 = t1;
  const subject = t0;
  let t2, t3;
  $[1] !== value ? (t2 = () => {
    subject.next(value);
  }, t3 = [subject, value], $[1] = value, $[2] = t2, $[3] = t3) : (t2 = $[2], t3 = $[3]), useEffect(t2, t3);
  let t4, t5;
  return $[4] !== resolveProductionUrl ? (t5 = subject.asObservable().pipe(distinctUntilChanged(), debounceTime(500), switchMap((document2) => isSanityDocument(document2) ? from(resolveProductionUrl({
    document: document2
  })) : of(void 0)), distinctUntilChanged(), catchError(_temp$7)), $[4] = resolveProductionUrl, $[5] = t5) : t5 = $[5], t4 = t5, useObservable(t4);
}
function _temp$7(err) {
  const message = isRecord(err) && typeof err.message == "string" ? err.message : "Unknown error";
  throw new Error(`An error was thrown while trying to get your preview url: ${message}`);
}
const DocumentPaneProvider = memo((props) => {
  const {
    children,
    index,
    pane: pane2,
    paneKey,
    onFocusPath,
    forcedVersion,
    historyStore
  } = props, {
    store: timelineStore,
    error: timelineError,
    ready: timelineReady,
    revisionDocument,
    onOlderRevision,
    sinceDocument,
    isPristine,
    revisionId,
    lastNonDeletedRevId
  } = historyStore, schema = useSchema(), {
    setDocumentMeta
  } = useCopyPaste(), {
    document: {
      actions: documentActions2,
      badges: documentBadges2,
      unstable_fieldActions: fieldActionsResolver,
      unstable_languageFilter: languageFilterResolver,
      drafts: {
        enabled: draftsEnabled
      }
    }
  } = useSource(), telemetry = useTelemetry(), paneRouter = usePaneRouter(), setPaneParams = paneRouter.setParams, {
    push: pushToast
  } = useToast(), {
    options,
    menuItemGroups = DEFAULT_MENU_ITEM_GROUPS,
    title = null,
    views: viewsProp = []
  } = pane2, paneOptions = useUnique(options), documentIdRaw = paneOptions.id, documentId = getPublishedId(documentIdRaw), documentType = options.type, params = useUnique(paneRouter.params) || EMPTY_PARAMS$2, {
    buildStudioUrl
  } = useStudioUrl(), perspective = usePerspective(), {
    document: {
      drafts: {
        enabled: isDraftModelEnabled
      }
    }
  } = useWorkspace(), {
    selectedReleaseId,
    selectedPerspectiveName
  } = useMemo(() => forcedVersion || {
    selectedPerspectiveName: perspective.selectedPerspectiveName,
    selectedReleaseId: perspective.selectedReleaseId
  }, [forcedVersion, perspective.selectedPerspectiveName, perspective.selectedReleaseId]), diffViewRouter = useDiffViewRouter(), initialValue = useDocumentPaneInitialValue({
    paneOptions,
    documentId,
    documentType,
    params
  }), isInitialValueLoading = initialValue.loading, {
    changesOpen,
    currentInspector,
    inspectors: inspectors2,
    closeInspector,
    openInspector,
    handleHistoryClose,
    handleHistoryOpen,
    handleInspectorAction,
    inspectOpen,
    handleLegacyInspectClose
  } = useDocumentPaneInspector({
    documentId,
    documentType,
    params,
    setParams: setPaneParams
  }), [isDeleting, setIsDeleting] = useState(!1), getIsDeleted = useCallback((editState) => timelineReady ? !editState?.draft && !editState?.published && !editState?.version && !isPristine : !1, [timelineReady, isPristine]), getComparisonValue = useCallback((editState_0) => changesOpen ? sinceDocument || editState_0?.published : editState_0?.published || null, [changesOpen, sinceDocument]), schemaType = schema.get(documentType), getIsReadOnly = useCallback((editState_1) => {
    const isDeleted = getIsDeleted(editState_1);
    return !!params.rev || isDeleting || isDeleted || !isPerspectiveWriteable({
      selectedPerspective: perspective.selectedPerspective,
      isDraftModelEnabled,
      schemaType
    }).result;
  }, [getIsDeleted, isDeleting, isDraftModelEnabled, params.rev, perspective.selectedPerspective, schemaType]), getDisplayed = useCallback((value) => onOlderRevision ? revisionDocument || {
    _id: value._id,
    _type: value._type
  } : value, [onOlderRevision, revisionDocument]), {
    editState: editState_2,
    connectionState,
    focusPath,
    onChange,
    validation,
    ready: formReady,
    value: value_0,
    formState,
    permissions,
    onPathOpen,
    isPermissionsLoading,
    formStateRef,
    onProgrammaticFocus,
    collapsedFieldSets,
    collapsedPaths,
    onBlur,
    onFocus,
    onSetActiveFieldGroup,
    onSetCollapsedPath,
    onSetCollapsedFieldSet,
    openPath
  } = useDocumentForm({
    documentType,
    documentId,
    initialValue,
    comparisonValue: getComparisonValue,
    releaseId: selectedReleaseId,
    selectedPerspectiveName,
    initialFocusPath: params.path ? fromString(params.path) : EMPTY_ARRAY$2,
    readOnly: getIsReadOnly,
    onFocusPath,
    getFormDocumentValue: getDisplayed
  }), getDocumentVersionType = useCallback(() => {
    let version;
    switch (!0) {
      case !!params.rev:
        version = "revision";
        break;
      case (selectedReleaseId && isVersionId(value_0._id)):
        version = "version";
        break;
      case selectedPerspectiveName === "published":
        version = "published";
        break;
      case draftsEnabled:
        version = "draft";
        break;
      default:
        version = "published";
    }
    return version;
  }, [params.rev, selectedReleaseId, value_0._id, selectedPerspectiveName, draftsEnabled]), actionsPerspective = useMemo(() => getDocumentVersionType(), [getDocumentVersionType]), documentActionsProps = useMemo(() => ({
    schemaType: documentType,
    documentId,
    versionType: actionsPerspective,
    releaseId: selectedReleaseId
  }), [documentType, documentId, actionsPerspective, selectedReleaseId]), actions = useMemo(() => documentActions2(documentActionsProps), [documentActions2, documentActionsProps]), badges = useMemo(() => documentBadges2({
    schemaType: documentType,
    documentId
  }), [documentBadges2, documentId, documentType]), languageFilter = useMemo(() => languageFilterResolver({
    schemaType: documentType,
    documentId
  }), [documentId, documentType, languageFilterResolver]), views = useUnique(viewsProp), activeViewId = params.view || views[0] && views[0].id || null, previewUrl = usePreviewUrl(value_0), {
    t
  } = useTranslation(structureLocaleNamespace), fieldActions = useMemo(() => schemaType ? fieldActionsResolver({
    documentId,
    documentType,
    schemaType
  }) : [], [documentId, documentType, fieldActionsResolver, schemaType]), ready = formReady && (!params.rev || timelineReady || !!timelineError), displayed = useMemo(() => getDisplayed(value_0), [getDisplayed, value_0]), {
    previousId
  } = useDocumentIdStack({
    displayed,
    documentId,
    editState: editState_2
  }), setTimelineRange = useCallback((newSince, newRev) => {
    setPaneParams({
      ...params,
      since: newSince,
      rev: newRev || void 0
    });
  }, [params, setPaneParams]), handlePaneClose = useCallback(() => paneRouter.closeCurrent(), [paneRouter]), handlePaneSplit = useCallback(() => paneRouter.duplicateCurrent(), [paneRouter]), handleMenuAction = useCallback(async (item) => {
    if (item.action === "production-preview" && previewUrl)
      return window.open(previewUrl), !0;
    if (item.action === "copy-document-url" && navigator) {
      telemetry.log(DocumentURLCopied);
      const copyUrl = buildStudioUrl({
        coreUi: (url) => `${url}/intent/edit/id=${documentId};type=${documentType}`
      });
      return await navigator.clipboard.writeText(copyUrl), pushToast({
        id: "copy-document-url",
        status: "info",
        title: t("panes.document-operation-results.operation-success_copy-url")
      }), !0;
    }
    return item.action === "reviewChanges" ? (handleHistoryOpen(), !0) : ((item.action === "inspect" || typeof item.action == "string" && item.action.startsWith(INSPECT_ACTION_PREFIX)) && handleInspectorAction(item), item.action === "compareVersions" && typeof previousId < "u" ? (diffViewRouter.navigateDiffView({
      mode: "version",
      previousDocument: {
        type: documentType,
        id: previousId
      },
      nextDocument: {
        type: documentType,
        id: value_0._id
      }
    }), !0) : !1);
  }, [previewUrl, previousId, telemetry, buildStudioUrl, pushToast, t, documentId, documentType, handleHistoryOpen, handleInspectorAction, diffViewRouter, value_0._id]);
  useEffect(() => {
    setDocumentMeta({
      documentId,
      documentType,
      schemaType,
      onChange
    });
  }, [documentId, documentType, schemaType, onChange, setDocumentMeta]);
  const compareValue = useMemo(() => getComparisonValue(editState_2), [editState_2, getComparisonValue]), isDeleted_0 = useMemo(() => getIsDeleted(editState_2), [editState_2, getIsDeleted]), revisionNotFound = onOlderRevision && !revisionDocument, documentPane = useMemo(() => ({
    actions,
    activeViewId,
    badges,
    changesOpen,
    closeInspector,
    collapsedFieldSets,
    collapsedPaths,
    compareValue,
    connectionState,
    displayed,
    documentId,
    documentIdRaw,
    documentType,
    editState: editState_2,
    fieldActions,
    focusPath,
    inspector: currentInspector || null,
    inspectors: inspectors2,
    onBlur,
    onChange,
    onFocus,
    onPathOpen,
    onHistoryClose: handleHistoryClose,
    onHistoryOpen: handleHistoryOpen,
    onInspectClose: handleLegacyInspectClose,
    onMenuAction: handleMenuAction,
    onPaneClose: handlePaneClose,
    onPaneSplit: handlePaneSplit,
    onSetActiveFieldGroup,
    onSetCollapsedPath,
    onSetCollapsedFieldSet,
    openInspector,
    openPath,
    index,
    inspectOpen,
    validation,
    menuItemGroups: menuItemGroups || [],
    paneKey,
    previewUrl,
    ready,
    schemaType,
    isPermissionsLoading,
    isInitialValueLoading,
    permissions,
    setTimelineRange,
    setIsDeleting,
    isDeleting,
    isDeleted: isDeleted_0,
    timelineError,
    timelineStore,
    title,
    value: value_0,
    selectedReleaseId,
    views,
    formState,
    unstable_languageFilter: languageFilter,
    revisionId,
    revisionNotFound,
    lastNonDeletedRevId
  }), [actions, activeViewId, badges, changesOpen, closeInspector, collapsedFieldSets, collapsedPaths, compareValue, connectionState, displayed, documentId, documentIdRaw, documentType, editState_2, fieldActions, focusPath, currentInspector, inspectors2, onBlur, onChange, onFocus, onPathOpen, handleHistoryClose, handleHistoryOpen, handleLegacyInspectClose, handleMenuAction, handlePaneClose, handlePaneSplit, onSetActiveFieldGroup, onSetCollapsedPath, onSetCollapsedFieldSet, openInspector, openPath, index, inspectOpen, validation, menuItemGroups, paneKey, previewUrl, ready, schemaType, isPermissionsLoading, isInitialValueLoading, permissions, setTimelineRange, isDeleting, isDeleted_0, timelineError, timelineStore, title, value_0, selectedReleaseId, views, formState, languageFilter, revisionId, revisionNotFound, lastNonDeletedRevId]);
  return useEffect(() => {
    if (ready && params.path) {
      const {
        path,
        ...restParams
      } = params, pathFromUrl = resolveKeyedPath(formStateRef.current?.value, fromString(path));
      onProgrammaticFocus(pathFromUrl), paneRouter.setParams(restParams);
    }
  }, [formStateRef, onProgrammaticFocus, paneRouter, params, ready]), /* @__PURE__ */ jsx(DocumentPaneContext.Provider, { value: documentPane, children });
});
DocumentPaneProvider.displayName = "Memo(DocumentPaneProvider)";
const DocumentEventsPane = (props) => {
  const $ = c(37), {
    params: t0
  } = usePaneRouter(), params = t0 === void 0 ? EMPTY_PARAMS$2 : t0, options = usePaneOptions(props.pane.options, params), schema = useSchema(), documentType = options.type, liveEdit = !!schema.get(options.type)?.liveEdit, {
    selectedPerspectiveName,
    selectedReleaseId,
    selectedPerspective
  } = usePerspective(), {
    data: archivedReleases
  } = useArchivedReleases();
  let t1;
  $[0] !== options.id ? (t1 = getPublishedId(options.id), $[0] = options.id, $[1] = t1) : t1 = $[1];
  const editState = useEditState(t1, documentType, "default", selectedReleaseId), showingPublishedOnDraft = liveEdit && selectedPerspective === "drafts" && !editState?.draft, {
    rev,
    since
  } = params, historyVersion = params.historyVersion;
  let t2;
  bb0: {
    if (showingPublishedOnDraft) {
      let t32;
      $[2] !== options.id ? (t32 = getPublishedId(options.id), $[2] = options.id, $[3] = t32) : t32 = $[3], t2 = t32;
      break bb0;
    }
    if (historyVersion && archivedReleases.some((release) => getReleaseIdFromReleaseDocumentId(release._id) === historyVersion)) {
      let t32;
      $[4] !== historyVersion || $[5] !== options.id ? (t32 = getVersionId(options.id, historyVersion), $[4] = historyVersion, $[5] = options.id, $[6] = t32) : t32 = $[6], t2 = t32;
      break bb0;
    }
    if (typeof selectedPerspectiveName > "u") {
      let t32;
      $[7] !== options.id ? (t32 = getDraftId(options.id), $[7] = options.id, $[8] = t32) : t32 = $[8], t2 = t32;
      break bb0;
    }
    if (selectedPerspectiveName === "published") {
      let t32;
      $[9] !== options.id ? (t32 = getPublishedId(options.id), $[9] = options.id, $[10] = t32) : t32 = $[10], t2 = t32;
      break bb0;
    }
    if (selectedReleaseId) {
      let t32;
      $[11] !== options.id || $[12] !== selectedPerspectiveName ? (t32 = getVersionId(options.id, selectedPerspectiveName), $[11] = options.id, $[12] = selectedPerspectiveName, $[13] = t32) : t32 = $[13], t2 = t32;
      break bb0;
    }
    t2 = options.id;
  }
  const documentId = t2;
  let t3;
  $[14] !== documentId || $[15] !== options.type || $[16] !== rev || $[17] !== since ? (t3 = {
    documentId,
    documentType: options.type,
    rev,
    since
  }, $[14] = documentId, $[15] = options.type, $[16] = rev, $[17] = since, $[18] = t3) : t3 = $[18];
  const eventsStore = useEventsStore(t3);
  let t4;
  const t5 = eventsStore.error, t6 = eventsStore.revision?.revisionId || null, t7 = !!(rev && !eventsStore.revision?.loading), t8 = eventsStore.revision?.document || null, t9 = eventsStore.sinceRevision?.document || null, t10 = !eventsStore.loading, t11 = eventsStore.events.length === 0;
  let t12;
  $[19] !== eventsStore.events ? (t12 = eventsStore.events.find(_temp$6)?.id || null, $[19] = eventsStore.events, $[20] = t12) : t12 = $[20];
  let t13;
  $[21] !== eventsStore.error || $[22] !== t10 || $[23] !== t11 || $[24] !== t12 || $[25] !== t6 || $[26] !== t7 || $[27] !== t8 || $[28] !== t9 ? (t13 = {
    error: t5,
    revisionId: t6,
    onOlderRevision: t7,
    revisionDocument: t8,
    sinceDocument: t9,
    ready: t10,
    isPristine: t11,
    lastNonDeletedRevId: t12
  }, $[21] = eventsStore.error, $[22] = t10, $[23] = t11, $[24] = t12, $[25] = t6, $[26] = t7, $[27] = t8, $[28] = t9, $[29] = t13) : t13 = $[29], t4 = t13;
  const historyStoreProps = t4;
  let t14;
  t14 = eventsStore;
  const value = t14;
  let t15;
  $[30] !== historyStoreProps || $[31] !== historyVersion || $[32] !== props ? (t15 = historyVersion ? /* @__PURE__ */ jsx(PerspectiveProvider, { selectedPerspectiveName: historyVersion, excludedPerspectives: EMPTY_ARRAY$2, children: /* @__PURE__ */ jsx(DocumentPaneProvider, { ...props, historyStore: historyStoreProps }) }) : /* @__PURE__ */ jsx(DocumentPaneProvider, { ...props, historyStore: historyStoreProps }), $[30] = historyStoreProps, $[31] = historyVersion, $[32] = props, $[33] = t15) : t15 = $[33];
  let t16;
  return $[34] !== t15 || $[35] !== value ? (t16 = /* @__PURE__ */ jsx(EventsProvider, { value, children: t15 }), $[34] = t15, $[35] = value, $[36] = t16) : t16 = $[36], t16;
};
function _temp$6(e) {
  return !isDeleteDocumentGroupEvent(e) && !isDeleteDocumentVersionEvent(e);
}
const DocumentPaneWithLegacyTimelineStore = (props) => {
  const $ = c(20), {
    pane: pane2
  } = props, paneRouter = usePaneRouter(), options = usePaneOptions(pane2.options, paneRouter.params), params = paneRouter.params || EMPTY_PARAMS$2, [timelineError, setTimelineError] = useState(null);
  let t0;
  $[0] !== options.id ? (t0 = getPublishedId(options.id), $[0] = options.id, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== options.type || $[3] !== params.rev || $[4] !== params.since || $[5] !== t0 ? (t1 = {
    documentId: t0,
    documentType: options.type,
    onError: setTimelineError,
    rev: params.rev,
    since: params.since
  }, $[2] = options.type, $[3] = params.rev, $[4] = params.since, $[5] = t0, $[6] = t1) : t1 = $[6];
  const store = useTimelineStore(t1), onOlderRevision = useTimelineSelector(store, _temp$5), revTime = useTimelineSelector(store, _temp2$1), sinceAttributes = useTimelineSelector(store, _temp3$1), timelineDisplayed = useTimelineSelector(store, _temp4$1), timelineReady = useTimelineSelector(store, _temp5$1), isPristine = useTimelineSelector(store, _temp6$1), lastNonDeletedRevId = useTimelineSelector(store, _temp7);
  let t2;
  const t3 = revTime?.id || null, t4 = timelineDisplayed, t5 = sinceAttributes, t6 = !!isPristine;
  let t7;
  $[7] !== lastNonDeletedRevId || $[8] !== onOlderRevision || $[9] !== store || $[10] !== t3 || $[11] !== t4 || $[12] !== t5 || $[13] !== t6 || $[14] !== timelineError || $[15] !== timelineReady ? (t7 = {
    store,
    error: timelineError,
    revisionId: t3,
    onOlderRevision,
    revisionDocument: t4,
    sinceDocument: t5,
    ready: timelineReady,
    isPristine: t6,
    lastNonDeletedRevId
  }, $[7] = lastNonDeletedRevId, $[8] = onOlderRevision, $[9] = store, $[10] = t3, $[11] = t4, $[12] = t5, $[13] = t6, $[14] = timelineError, $[15] = timelineReady, $[16] = t7) : t7 = $[16], t2 = t7;
  const historyStoreProps = t2;
  let t8;
  return $[17] !== historyStoreProps || $[18] !== props ? (t8 = /* @__PURE__ */ jsx(DocumentPaneProvider, { ...props, historyStore: historyStoreProps }), $[17] = historyStoreProps, $[18] = props, $[19] = t8) : t8 = $[19], t8;
};
function _temp$5(state2) {
  return state2.onOlderRevision;
}
function _temp2$1(state_0) {
  return state_0.revTime;
}
function _temp3$1(state_1) {
  return state_1.sinceAttributes;
}
function _temp4$1(state_2) {
  return state_2.timelineDisplayed;
}
function _temp5$1(state_3) {
  return state_3.timelineReady;
}
function _temp6$1(state_4) {
  return state_4.isPristine;
}
function _temp7(state_5) {
  return state_5.lastNonDeletedRevId;
}
const DocumentPaneProviderWrapper = memo((props) => {
  const $ = c(4);
  if (useSource().beta?.eventsAPI?.documents) {
    let t02;
    return $[0] !== props ? (t02 = /* @__PURE__ */ jsx(DocumentEventsPane, { ...props }), $[0] = props, $[1] = t02) : t02 = $[1], t02;
  }
  let t0;
  return $[2] !== props ? (t0 = /* @__PURE__ */ jsx(DocumentPaneWithLegacyTimelineStore, { ...props }), $[2] = props, $[3] = t0) : t0 = $[3], t0;
});
DocumentPaneProviderWrapper.displayName = "Memo(DocumentPaneProviderWrapper)";
function useResetHistoryParams() {
  const $ = c(10), {
    params: t0,
    setParams
  } = usePaneRouter(), params = t0 === void 0 ? EMPTY_PARAMS$2 : t0, {
    selectedPerspectiveName
  } = usePerspective(), isMounted = useRef(!1);
  let t1;
  $[0] !== params || $[1] !== setParams ? (t1 = (_perspective) => {
    ["since", "historyVersion", "rev", "preserveRev"].some((param) => params[param]) && setParams({
      ...params,
      rev: params.preserveRev === "true" ? params.rev : void 0,
      preserveRev: void 0,
      since: void 0,
      historyVersion: void 0
    });
  }, $[0] = params, $[1] = setParams, $[2] = t1) : t1 = $[2];
  const updateHistoryParams = useEffectEvent(t1);
  let t2;
  $[3] !== selectedPerspectiveName || $[4] !== updateHistoryParams ? (t2 = () => {
    isMounted.current && updateHistoryParams(selectedPerspectiveName);
  }, $[3] = selectedPerspectiveName, $[4] = updateHistoryParams, $[5] = t2) : t2 = $[5];
  let t3;
  $[6] !== selectedPerspectiveName ? (t3 = [selectedPerspectiveName], $[6] = selectedPerspectiveName, $[7] = t3) : t3 = $[7], useEffect(t2, t3);
  let t4, t5;
  $[8] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => (isMounted.current = !0, () => {
    isMounted.current = !1;
  }), t5 = [], $[8] = t4, $[9] = t5) : (t4 = $[8], t5 = $[9]), useEffect(t4, t5);
}
const DocumentPane = memo(function(props) {
  const $ = c(5), {
    name: parentSourceName
  } = useSource(), t0 = props.pane.source || parentSourceName;
  let t1;
  $[0] !== props ? (t1 = /* @__PURE__ */ jsx(CopyPasteProvider, { children: /* @__PURE__ */ jsx(DocumentPaneInner, { ...props }) }), $[0] = props, $[1] = t1) : t1 = $[1];
  let t2;
  return $[2] !== t0 || $[3] !== t1 ? (t2 = /* @__PURE__ */ jsx(SourceProvider, { name: t0, children: t1 }), $[2] = t0, $[3] = t1, $[4] = t2) : t2 = $[4], t2;
});
function DocumentPaneInner(props) {
  const $ = c(57), {
    pane: pane2,
    paneKey
  } = props, {
    resolveNewDocumentOptions
  } = useSource().document, {
    selectedPerspectiveName
  } = usePerspective(), paneRouter = usePaneRouter(), options = usePaneOptions(pane2.options, paneRouter.params), {
    documentType,
    isLoaded: isDocumentLoaded
  } = useDocumentType(options.id, options.type);
  useResetHistoryParams();
  const DocumentLayout2 = useDocumentLayoutComponent();
  let t0, t1;
  $[0] !== options.id || $[1] !== options.type || $[2] !== resolveNewDocumentOptions ? (t1 = resolveNewDocumentOptions({
    type: "document",
    documentId: options.id,
    schemaType: options.type
  }), $[0] = options.id, $[1] = options.type, $[2] = resolveNewDocumentOptions, $[3] = t1) : t1 = $[3], t0 = t1;
  const templateItems = t0;
  let t2;
  $[4] !== templateItems ? (t2 = {
    templateItems
  }, $[4] = templateItems, $[5] = t2) : t2 = $[5];
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions(t2), isLoaded = isDocumentLoaded && !isTemplatePermissionsLoading;
  let t3, t4;
  $[6] !== documentType || $[7] !== isLoaded || $[8] !== options || $[9] !== props ? (t4 = isLoaded && documentType && options.type !== documentType ? mergeDocumentType(props, options, documentType) : props, $[6] = documentType, $[7] = isLoaded, $[8] = options, $[9] = props, $[10] = t4) : t4 = $[10], t3 = t4;
  const providerProps = t3, {
    ReferenceChildLink: ReferenceChildLink2,
    handleEditReference,
    groupIndex,
    routerPanesState
  } = paneRouter;
  let t5;
  $[11] !== groupIndex || $[12] !== routerPanesState ? (t5 = routerPanesState[groupIndex + 1]?.[0].params || {}, $[11] = groupIndex, $[12] = routerPanesState, $[13] = t5) : t5 = $[13];
  const childParams = t5, routerPanesStateLength = routerPanesState.length, {
    parentRefPath
  } = childParams;
  let t6, t7;
  $[14] !== groupIndex || $[15] !== parentRefPath || $[16] !== routerPanesStateLength ? (t7 = parentRefPath ? {
    path: fromString(parentRefPath),
    state: groupIndex >= routerPanesStateLength - 1 ? "none" : groupIndex >= routerPanesStateLength - 2 ? "selected" : "pressed"
  } : {
    path: [],
    state: "none"
  }, $[14] = groupIndex, $[15] = parentRefPath, $[16] = routerPanesStateLength, $[17] = t7) : t7 = $[17], t6 = t7;
  const activePath = t6, {
    t
  } = useTranslation(structureLocaleNamespace);
  if (options.type === "*" && !isLoaded) {
    let t82;
    $[18] !== t ? (t82 = t("panes.document-pane.document-not-found.loading"), $[18] = t, $[19] = t82) : t82 = $[19];
    let t92;
    return $[20] !== paneKey || $[21] !== t82 ? (t92 = /* @__PURE__ */ jsx(LoadingPane, { flex: 2.5, minWidth: 320, paneKey, title: t82 }), $[20] = paneKey, $[21] = t82, $[22] = t92) : t92 = $[22], t92;
  }
  if (!documentType) {
    let t82;
    $[23] !== t ? (t82 = t("panes.document-pane.document-not-found.title"), $[23] = t, $[24] = t82) : t82 = $[24];
    let t92;
    $[25] !== options.id ? (t92 = {
      id: options.id
    }, $[25] = options.id, $[26] = t92) : t92 = $[26];
    let t102;
    $[27] === Symbol.for("react.memo_cache_sentinel") ? (t102 = {
      Code: _temp$4
    }, $[27] = t102) : t102 = $[27];
    let t112;
    $[28] !== t || $[29] !== t92 ? (t112 = /* @__PURE__ */ jsx(Stack, { space: 4, children: /* @__PURE__ */ jsx(Text, { as: "p", children: /* @__PURE__ */ jsx(Translate, { t, i18nKey: "panes.document-pane.document-not-found.text", values: t92, components: t102 }) }) }), $[28] = t, $[29] = t92, $[30] = t112) : t112 = $[30];
    let t122;
    return $[31] !== paneKey || $[32] !== t112 || $[33] !== t82 ? (t122 = /* @__PURE__ */ jsx(ErrorPane, { flex: 2.5, minWidth: 320, paneKey, title: t82, children: t112 }), $[31] = paneKey, $[32] = t112, $[33] = t82, $[34] = t122) : t122 = $[34], t122;
  }
  const t8 = `${documentType}-${options.id}-${selectedPerspectiveName || ""}`;
  let t9;
  $[35] !== DocumentLayout2 || $[36] !== options.id || $[37] !== options.type ? (t9 = /* @__PURE__ */ jsx(DocumentLayout2, { documentId: options.id, documentType: options.type }), $[35] = DocumentLayout2, $[36] = options.id, $[37] = options.type, $[38] = t9) : t9 = $[38];
  let t10;
  $[39] !== options.id || $[40] !== options.type || $[41] !== t9 ? (t10 = /* @__PURE__ */ jsx(CommentsWrapper, { documentId: options.id, documentType: options.type, children: t9 }), $[39] = options.id, $[40] = options.type, $[41] = t9, $[42] = t10) : t10 = $[42];
  let t11;
  $[43] !== options.id || $[44] !== options.type || $[45] !== t10 ? (t11 = /* @__PURE__ */ jsx(DiffViewDocumentLayout, { documentId: options.id, documentType: options.type, children: t10 }), $[43] = options.id, $[44] = options.type, $[45] = t10, $[46] = t11) : t11 = $[46];
  let t12;
  $[47] !== ReferenceChildLink2 || $[48] !== activePath || $[49] !== handleEditReference || $[50] !== t11 || $[51] !== templatePermissions ? (t12 = /* @__PURE__ */ jsx(ReferenceInputOptionsProvider, { EditReferenceLinkComponent: ReferenceChildLink2, onEditReference: handleEditReference, initialValueTemplateItems: templatePermissions, activePath, children: t11 }), $[47] = ReferenceChildLink2, $[48] = activePath, $[49] = handleEditReference, $[50] = t11, $[51] = templatePermissions, $[52] = t12) : t12 = $[52];
  let t13;
  return $[53] !== providerProps || $[54] !== t12 || $[55] !== t8 ? (t13 = /* @__PURE__ */ jsx(DocumentPaneProviderWrapper, { ...providerProps, children: t12 }, t8), $[53] = providerProps, $[54] = t12, $[55] = t8, $[56] = t13) : t13 = $[56], t13;
}
function _temp$4(t0) {
  const {
    children
  } = t0;
  return /* @__PURE__ */ jsx("code", { children });
}
function usePaneOptions(options, t0) {
  const $ = c(8);
  let t1;
  $[0] !== t0 ? (t1 = t0 === void 0 ? {} : t0, $[0] = t0, $[1] = t1) : t1 = $[1];
  const params = t1, templates = useTemplates();
  let t2;
  bb0: {
    if (options.type && options.type !== "*") {
      t2 = options;
      break bb0;
    }
    const templateName = options.template || params.template;
    let t3;
    $[2] !== templateName || $[3] !== templates ? (t3 = templateName ? templates.find((t) => t.id === templateName) : void 0, $[2] = templateName, $[3] = templates, $[4] = t3) : t3 = $[4];
    const documentType = t3?.schemaType;
    if (!documentType) {
      t2 = options;
      break bb0;
    }
    let t4;
    $[5] !== documentType || $[6] !== options ? (t4 = {
      ...options,
      type: documentType
    }, $[5] = documentType, $[6] = options, $[7] = t4) : t4 = $[7], t2 = t4;
  }
  return t2;
}
function mergeDocumentType(props, options, documentType) {
  return {
    ...props,
    pane: {
      ...props.pane,
      options: {
        ...options,
        type: documentType
      }
    }
  };
}
const PARTIAL_PAGE_LIMIT = 100, FULL_LIST_LIMIT = 2e3, DEFAULT_ORDERING = {
  by: [{
    field: "_updatedAt",
    direction: "desc"
  }]
}, EMPTY_RECORD = {}, RootBox = styled(Box)`
  position: relative;
  opacity: ${(props) => props.$opacity || 1};
  transition: opacity 0.4s;
`, CommandListBox = styled(Box)`
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
`, SKELETON_ITEMS = [...Array(30).keys()];
function LoadingView(props) {
  const $ = c(4), {
    layout
  } = props;
  let t0;
  $[0] !== layout ? (t0 = SKELETON_ITEMS.map((num) => /* @__PURE__ */ jsx(SanityDefaultPreview, { isPlaceholder: !0, layout }, num)), $[0] = layout, $[1] = t0) : t0 = $[1];
  let t1;
  return $[2] !== t0 ? (t1 = /* @__PURE__ */ jsx(Stack, { paddingX: 3, paddingY: 2, paddingTop: 0, space: 1, children: t0 }), $[2] = t0, $[3] = t1) : t1 = $[3], t1;
}
function DocumentListPaneContent(props) {
  const $ = c(66), {
    childItemId,
    error,
    isRetrying,
    autoRetry,
    filterIsSimpleTypeConstraint,
    hasMaxItems,
    hasSearchQuery,
    isActive,
    isLazyLoading,
    muted,
    isLoading,
    isConnected,
    retryCount,
    canRetry,
    items,
    layout,
    loadingVariant,
    onEndReached,
    onRetry,
    paneTitle,
    searchInputElement,
    showIcons
  } = props, schema = useSchema(), {
    collapsed: layoutCollapsed
  } = usePaneLayout(), {
    collapsed,
    index
  } = usePane(), [shouldRender, setShouldRender] = useState(!collapsed), {
    t
  } = useTranslation(structureLocaleNamespace);
  let t0;
  $[0] !== onEndReached || $[1] !== shouldRender ? (t0 = () => {
    shouldRender && onEndReached();
  }, $[0] = onEndReached, $[1] = shouldRender, $[2] = t0) : t0 = $[2];
  const handleEndReached = t0;
  let t1;
  $[3] !== collapsed ? (t1 = () => {
    if (collapsed)
      return;
    const timer2 = setTimeout(() => {
      setShouldRender(!0);
    }, 0);
    return () => {
      clearTimeout(timer2);
    };
  }, $[3] = collapsed, $[4] = t1) : t1 = $[4];
  let t2;
  $[5] !== collapsed || $[6] !== items ? (t2 = [collapsed, items], $[5] = collapsed, $[6] = items, $[7] = t2) : t2 = $[7], useEffect(t1, t2);
  let t3;
  $[8] !== childItemId || $[9] !== hasMaxItems || $[10] !== isActive || $[11] !== isLazyLoading || $[12] !== items.length || $[13] !== layout || $[14] !== schema || $[15] !== showIcons || $[16] !== t ? (t3 = (item, t42) => {
    const {
      activeIndex
    } = t42, publishedId = getPublishedId(item._id), isSelected = childItemId === publishedId, pressed = !isActive && isSelected, selected = isActive && isSelected, isLastItem = activeIndex === items.length - 1, showSpinner = isLastItem && isLazyLoading, showMaxItemsMessage = isLastItem && hasMaxItems;
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(PaneItem, { icon: showIcons === !1 ? !1 : void 0, id: publishedId, layout, marginBottom: 1, pressed, schemaType: schema.get(item._type), selected, value: item }),
      showSpinner && /* @__PURE__ */ jsx(LoadingBlock, {}),
      showMaxItemsMessage && /* @__PURE__ */ jsx(Box, { marginY: 1, paddingX: 3, paddingY: 4, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, size: 1, children: t("panes.document-list-pane.max-items.text", {
        limit: FULL_LIST_LIMIT
      }) }) })
    ] });
  }, $[8] = childItemId, $[9] = hasMaxItems, $[10] = isActive, $[11] = isLazyLoading, $[12] = items.length, $[13] = layout, $[14] = schema, $[15] = showIcons, $[16] = t, $[17] = t3) : t3 = $[17];
  const renderItem = t3;
  let t4;
  bb0: {
    if (hasSearchQuery) {
      let t53;
      $[18] !== t ? (t53 = t("panes.document-list-pane.no-documents.text"), $[18] = t, $[19] = t53) : t53 = $[19];
      let t63;
      $[20] !== t53 ? (t63 = /* @__PURE__ */ jsx(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsx(Container$1, { width: 1, children: /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 5, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, children: t53 }) }) }) }), $[20] = t53, $[21] = t63) : t63 = $[21], t4 = t63;
      break bb0;
    }
    let t52;
    $[22] !== filterIsSimpleTypeConstraint || $[23] !== t ? (t52 = t(filterIsSimpleTypeConstraint ? "panes.document-list-pane.no-documents-of-type.text" : "panes.document-list-pane.no-matching-documents.text"), $[22] = filterIsSimpleTypeConstraint, $[23] = t, $[24] = t52) : t52 = $[24];
    let t62;
    $[25] !== t52 ? (t62 = /* @__PURE__ */ jsx(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsx(Container$1, { width: 1, children: /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 5, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, children: t52 }) }) }) }), $[25] = t52, $[26] = t62) : t62 = $[26], t4 = t62;
  }
  const noDocumentsContent = t4;
  let t5;
  bb1: {
    if (!shouldRender) {
      t5 = null;
      break bb1;
    }
    const isOnline = window.navigator.onLine;
    if (error) {
      let t63;
      $[27] !== t ? (t63 = t("panes.document-list-pane.error.title"), $[27] = t, $[28] = t63) : t63 = $[28];
      let t73;
      $[29] !== t63 ? (t73 = /* @__PURE__ */ jsx(Heading, { as: "h3", children: t63 }), $[29] = t63, $[30] = t73) : t73 = $[30];
      let t82;
      $[31] !== error || $[32] !== t ? (t82 = isDev ? /* @__PURE__ */ jsx(Translate, { t, i18nKey: "panes.document-list-pane.error.text.dev", values: {
        error: error.message
      }, components: {
        Code: _temp$3
      } }) : t(isOnline ? "panes.document-list-pane.error.text" : "panes.document-list-pane.error.text.offline"), $[31] = error, $[32] = t, $[33] = t82) : t82 = $[33];
      let t9;
      $[34] !== t82 ? (t9 = /* @__PURE__ */ jsx(Text, { as: "p", children: t82 }), $[34] = t82, $[35] = t9) : t9 = $[35];
      const t10 = isOnline && canRetry ? onRetry : void 0;
      let t11;
      $[36] !== error || $[37] !== isRetrying || $[38] !== t10 ? (t11 = /* @__PURE__ */ jsx(ErrorActions, { error, eventId: null, onRetry: t10, isRetrying }), $[36] = error, $[37] = isRetrying, $[38] = t10, $[39] = t11) : t11 = $[39];
      let t12;
      $[40] !== autoRetry || $[41] !== canRetry || $[42] !== isRetrying || $[43] !== retryCount || $[44] !== t ? (t12 = canRetry ? /* @__PURE__ */ jsx(Text, { as: "p", muted: !0, size: 1, children: isRetrying ? t("panes.document-list-pane.error.retrying", {
        count: retryCount
      }) : autoRetry ? t("panes.document-list-pane.error.will-retry-automatically", {
        count: retryCount
      }) : t("panes.document-list-pane.error.max-retries-attempted", {
        count: retryCount
      }) }) : null, $[40] = autoRetry, $[41] = canRetry, $[42] = isRetrying, $[43] = retryCount, $[44] = t, $[45] = t12) : t12 = $[45];
      let t13;
      $[46] !== t11 || $[47] !== t12 || $[48] !== t73 || $[49] !== t9 ? (t13 = /* @__PURE__ */ jsx(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsx(Container$1, { width: 1, children: /* @__PURE__ */ jsxs(Stack, { paddingX: 4, paddingY: 5, space: 4, children: [
        t73,
        t9,
        t11,
        t12
      ] }) }) }), $[46] = t11, $[47] = t12, $[48] = t73, $[49] = t9, $[50] = t13) : t13 = $[50], t5 = t13;
      break bb1;
    }
    if (isConnected && !isLoading && items.length === 0) {
      t5 = noDocumentsContent;
      break bb1;
    }
    if (loadingVariant === "initial" && isLoading) {
      let t63;
      $[51] !== layout ? (t63 = /* @__PURE__ */ jsx(Delay, { ms: 300, children: /* @__PURE__ */ jsx(LoadingView, { layout }) }), $[51] = layout, $[52] = t63) : t63 = $[52], t5 = t63;
      break bb1;
    }
    if (loadingVariant === "spinner" && isLoading) {
      t5 = null;
      break bb1;
    }
    const key = `${index}-${collapsed}`, t62 = muted ? 0.8 : 1;
    let t72;
    $[53] !== handleEndReached || $[54] !== items || $[55] !== key || $[56] !== paneTitle || $[57] !== renderItem || $[58] !== searchInputElement ? (t72 = /* @__PURE__ */ jsx(CommandListBox, { children: /* @__PURE__ */ jsx(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: paneTitle, canReceiveFocus: !0, inputElement: searchInputElement, itemHeight: 51, items, onEndReached: handleEndReached, onlyShowSelectionWhenActive: !0, overscan: 10, paddingBottom: 1, paddingX: 3, renderItem, wrapAround: !1 }, key) }), $[53] = handleEndReached, $[54] = items, $[55] = key, $[56] = paneTitle, $[57] = renderItem, $[58] = searchInputElement, $[59] = t72) : t72 = $[59];
    let t8;
    $[60] !== t62 || $[61] !== t72 ? (t8 = /* @__PURE__ */ jsx(RootBox, { overflow: "hidden", height: "fill", $opacity: t62, children: t72 }), $[60] = t62, $[61] = t72, $[62] = t8) : t8 = $[62], t5 = t8;
  }
  const mainContent = t5, t6 = layoutCollapsed || loadingVariant === "initial" ? "hidden" : "auto";
  let t7;
  return $[63] !== mainContent || $[64] !== t6 ? (t7 = /* @__PURE__ */ jsx(PaneContent, { "data-testid": "document-list-pane", overflow: t6, children: mainContent }), $[63] = mainContent, $[64] = t6, $[65] = t7) : t7 = $[65], t7;
}
function _temp$3(t0) {
  const {
    children
  } = t0;
  return /* @__PURE__ */ jsx("code", { children });
}
function removePublishedWithDrafts(documents) {
  return collate(documents).map((entry) => {
    const doc = entry.draft || entry.published || entry.versions[0], hasDraft = !!entry.draft;
    return {
      ...doc,
      hasPublished: !!entry.published,
      hasDraft
    };
  });
}
function applyOrderingFunctions(order, schemaType) {
  const orderBy = order.by.map((by) => {
    if (by.mapWith)
      return by;
    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);
    return fieldType ? fieldExtendsType(fieldType, "datetime") ? {
      ...by,
      mapWith: "dateTime"
    } : fieldType.jsonType === "string" ? {
      ...by,
      mapWith: "lower"
    } : by : by;
  });
  return orderBy.every((item, index) => item === order.by[index]) ? order : {
    ...order,
    by: orderBy
  };
}
function tryResolveSchemaTypeForPath(baseType, path) {
  const pathSegments = PathUtils.fromString(path);
  let current = baseType;
  for (const segment of pathSegments) {
    if (!current)
      return;
    if (typeof segment == "string") {
      current = getFieldTypeByName(current, segment);
      continue;
    }
    if (!(isKeySegment(segment) || isIndexSegment(segment)) || current.jsonType !== "array")
      return;
    const [memberType, otherType] = current.of || [];
    if (otherType || !memberType)
      return;
    if (!isReferenceSchemaType(memberType)) {
      current = memberType;
      continue;
    }
    const [refType, otherRefType] = memberType.to || [];
    if (otherRefType || !refType)
      return;
    current = refType;
  }
  return current;
}
function getFieldTypeByName(type, fieldName) {
  if (!("fields" in type))
    return;
  const fieldType = type.fields.find((field) => field.name === fieldName);
  return fieldType ? fieldType.type : void 0;
}
function fieldExtendsType(field, ofType) {
  let current = field.type;
  for (; current; ) {
    if (current.name === ofType || !current.type && current.jsonType === ofType)
      return !0;
    current = current.type;
  }
  return !1;
}
function findTypes(node) {
  switch (node.type) {
    case "OpCall": {
      const {
        left,
        right
      } = node;
      switch (node.op) {
        // e.g. `a == b`
        case "==":
          return left.type === "AccessAttribute" && left.name === "_type" && !left.base ? right.type !== "Value" || typeof right.value != "string" ? null : /* @__PURE__ */ new Set([right.value]) : right.type === "AccessAttribute" && right.name === "_type" && !right.base ? left.type !== "Value" || typeof left.value != "string" ? null : /* @__PURE__ */ new Set([left.value]) : null;
        // e.g. `a in b`
        case "in": {
          if (left.type !== "AccessAttribute" || left.name !== "_type" || left.base || right.type !== "Array") return null;
          const types = /* @__PURE__ */ new Set();
          for (const element of right.elements) {
            if (element.isSplat || element.value.type !== "Value" || typeof element.value.value != "string") return null;
            types.add(element.value.value);
          }
          return types.size ? types : null;
        }
        default:
          return null;
      }
    }
    // groups can just be unwrapped, the AST preserves the order
    case "Group":
      return findTypes(node.base);
    // e.g. `_type == 'a' || _type == 'b'`
    // with Or nodes, if we can't determine the types for either the left or
    // right hand side then we can't determine the types for any
    // e.g. `_type == 'a' || isActive`
    // — can't determine types because `isActive` could be true on another types
    case "Or": {
      const left = findTypes(node.left);
      if (!left) return null;
      const right = findTypes(node.right);
      return right ? /* @__PURE__ */ new Set([...left, ...right]) : null;
    }
    // e.g. `_type == 'a' && isActive`
    // with And nodes, we can determine the types as long as we can determine
    // the types for one side. We can't determine the types if both are `null`.
    case "And": {
      const left = findTypes(node.left), right = findTypes(node.right);
      return !left && !right ? null : /* @__PURE__ */ new Set([...left || [], ...right || []]);
    }
    default:
      return null;
  }
}
function findStaticTypesInFilter(filter2, params = {}) {
  try {
    const types = findTypes(parse(filter2, {
      params
    }));
    return types ? Array.from(types).sort() : null;
  } catch {
    return null;
  }
}
const swr = createSWR({
  maxSize: 100
});
function listenSearchQuery(options) {
  const {
    client,
    schema,
    sort,
    perspective,
    limit,
    params,
    filter: groqFilter,
    searchQuery,
    staticTypeNames,
    maxFieldDepth,
    searchStrategy
  } = options, sortBy = sort.by, extendedProjection = sort?.extendedProjection, events$ = defer(() => client.listen(`*[${groqFilter}]`, params, {
    events: ["welcome", "mutation", "reconnect"],
    includeAllVersions: !0,
    includeResult: !1,
    visibility: "query",
    tag: "listen-search-query"
  })).pipe(mergeMap((ev, i) => {
    const isFirst = i === 0;
    return isFirst && ev.type === "reconnect" ? throwError(() => new Error("Failed to establish EventSource connection")) : isFirst && ev.type !== "welcome" ? throwError(() => new Error(`Received unexpected type of first event "${ev.type}"`)) : of(ev);
  }), share()), [welcome$, mutationAndReconnect$] = partition(events$, (ev) => ev.type === "welcome"), swrKey = JSON.stringify({
    fiilter: groqFilter,
    limit,
    params,
    searchQuery,
    perspective,
    sort,
    staticTypeNames
  });
  return merge(welcome$, mutationAndReconnect$.pipe(throttleTime(1e3, asyncScheduler, {
    leading: !0,
    trailing: !0
  }))).pipe(exhaustMapWithTrailing((event) => (staticTypeNames ? of(staticTypeNames) : client.observable.fetch(`array::unique(*[${groqFilter}][]._type)`, params)).pipe(mergeMap((typeNames) => {
    const types = getSearchableTypes(schema, staticTypeNames || []).filter((type) => typeNames.includes(type.name) ? (getExtendedProjection(type, sort.by, !0), !0) : !1), search = createSearch(types, client, {
      filter: groqFilter,
      params,
      strategy: searchStrategy,
      maxDepth: maxFieldDepth
    }), doFetch = () => search({
      query: searchQuery || "",
      types
    }, {
      __unstable_extendedProjection: extendedProjection,
      comments: [`findability-source: ${searchQuery ? "list-query" : "list"}`],
      limit,
      skipSortByScore: !0,
      sort: sortBy,
      perspective
    }).pipe(map$1((result) => (
      // eslint-disable-next-line max-nested-callbacks
      result.hits.map(({
        hit
      }) => hit)
    )), map$1((hits) => ({
      type: "result",
      documents: hits
    })));
    return event.type === "mutation" && event.visibility !== "query" ? timer(1200).pipe(mergeMap(doFetch)) : event.type === "reconnect" ? of(event) : doFetch();
  }))), scan((acc, event) => ({
    connected: event.type !== "reconnect",
    documents: event.type === "result" ? event.documents : acc?.documents || []
  }), null), filter((v) => v !== null), swr(swrKey), map$1(({
    fromCache,
    value
  }) => ({
    fromCache,
    ...value
  })));
}
const INITIAL_QUERY_STATE = {
  error: null,
  isRetrying: !1,
  retryCount: 0,
  autoRetry: !1,
  canRetry: !1,
  isLoading: !0,
  isLoadingFullList: !1,
  fromCache: !1,
  items: []
};
function isRetriableError(error) {
  return error instanceof ChannelError ? !1 : error instanceof ServerError ? !0 : error instanceof ClientError ? error.statusCode === 403 : !0;
}
function useDocumentList(opts) {
  const {
    filter: searchFilter,
    params: paramsProp,
    sortOrder,
    searchQuery,
    perspective,
    apiVersion
  } = opts, client = useClient({
    ...DEFAULT_STUDIO_CLIENT_OPTIONS,
    apiVersion: apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion
  }), {
    strategy: searchStrategy
  } = useWorkspace().search, schema = useSchema(), maxFieldDepth = useSearchMaxFieldDepth(), typeNameFromFilter = useMemo(() => findStaticTypesInFilter(searchFilter, paramsProp), [searchFilter, paramsProp]), [[onRetry$, onRetry]] = useState(() => observableCallback()), [[onFetchFullList$, onLoadFullList]] = useState(() => observableCallback()), queryResults$ = useMemo(() => {
    const listenSearchQueryArgs = {
      client,
      filter: searchFilter,
      limit: PARTIAL_PAGE_LIMIT,
      params: paramsProp,
      schema,
      perspective,
      searchQuery: searchQuery || "",
      sort: sortOrder || DEFAULT_ORDERING,
      staticTypeNames: typeNameFromFilter,
      maxFieldDepth,
      searchStrategy
    }, partialList$ = listenSearchQuery(listenSearchQueryArgs).pipe(shareReplay({
      refCount: !0,
      bufferSize: 1
    })), fullList$ = onFetchFullList$.pipe(
      withLatestFrom(partialList$),
      filter$1(([, result]) => result?.documents.length === PARTIAL_PAGE_LIMIT),
      // we want to set up the full list listener only once
      take(1),
      mergeMap$1(() => concat(of({
        type: "loadFullList"
      }), listenSearchQuery({
        ...listenSearchQueryArgs,
        limit: FULL_LIST_LIMIT
      }).pipe(map((result_0) => ({
        type: "result",
        result: result_0
      }))))),
      share$1()
    );
    return merge(partialList$.pipe(
      map((result_1) => ({
        type: "result",
        result: result_1
      })),
      // when the full list listener kicks off, we want to stop the partial list listener
      takeUntil(fullList$)
    ), fullList$).pipe(catchWithCount((lastError, retryCount, caught$) => {
      const error = safeError(lastError), isOnline = window.navigator.onLine, canRetry = isOnline && isRetriableError(lastError), autoRetry = retryCount < 10, retries = merge(isOnline ? onRetry$ : fromEvent(window, "online"), isOnline && autoRetry ? timer(retryCount * 1e3) : NEVER).pipe(take(1), switchMap(() => merge(of({
        type: "error",
        error,
        retrying: !0,
        autoRetry,
        canRetry,
        retryCount
      }), caught$)));
      return concat(of({
        type: "error",
        error,
        retrying: !1,
        autoRetry,
        canRetry,
        retryCount
      }), retries);
    }), scan((prev, event) => {
      if (event.type === "error")
        return {
          ...prev,
          error: event.error,
          retryCount: event.retryCount,
          isRetrying: event.retrying,
          autoRetry: event.autoRetry,
          canRetry: event.canRetry
        };
      if (event.type === "result")
        return {
          ...prev,
          error: null,
          isRetrying: !1,
          fromCache: event.result.fromCache,
          connected: event.result.connected,
          isLoading: !1,
          items: removePublishedWithDrafts(event.result.documents),
          isLoadingFullList: !1
        };
      if (event.type === "loadFullList")
        return {
          ...prev,
          error: null,
          isLoadingFullList: !0
        };
      throw new Error(`Unexpected event type: ${event.type}`);
    }, INITIAL_QUERY_STATE));
  }, [client, searchFilter, paramsProp, schema, perspective, searchQuery, sortOrder, typeNameFromFilter, maxFieldDepth, searchStrategy, onFetchFullList$, onRetry$]), {
    error: error_0,
    items,
    isLoading,
    fromCache,
    connected,
    canRetry: canRetry_0,
    isLoadingFullList,
    isRetrying,
    autoRetry: autoRetry_0,
    retryCount: retryCount_0
  } = useObservable(queryResults$, INITIAL_QUERY_STATE);
  return {
    error: error_0,
    onRetry,
    isLoading,
    items,
    isRetrying,
    canRetry: canRetry_0,
    retryCount: retryCount_0,
    autoRetry: autoRetry_0,
    connected,
    fromCache,
    onLoadFullList,
    isLoadingFullList
  };
}
const nonErrorThrownWarning = "[WARNING: This was thrown as a non-error. Only Error instances should be thrown]";
function safeError(thrown) {
  return thrown instanceof Error ? thrown : typeof thrown == "object" && thrown !== null ? "message" in thrown && typeof thrown.message == "string" ? new Error(`${thrown.message} ${nonErrorThrownWarning}`) : new Error(`${String(thrown)} ${nonErrorThrownWarning}`) : new Error(`${String(thrown)} ${nonErrorThrownWarning}`);
}
const rotate = keyframes`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, fadeIn = keyframes`
  0% {
    opacity: 0;
  }
  50% {
    opacity: 0.1;
  }
  100% {
    opacity: 0.4;
  }
`, AnimatedSpinnerIcon = styled(SpinnerIcon)`
  animation: ${rotate} 500ms linear infinite;
`, SubtleSpinnerIcon = styled(SpinnerIcon)`
  animation: ${rotate} 1500ms linear infinite;
  opacity: 0.4;
`, DelayedSubtleSpinnerIcon = styled(SpinnerIcon)`
  animation:
    ${rotate} 1500ms linear infinite,
    ${fadeIn} 1000ms linear;
  opacity: 0.4;
`, DocumentListPane = memo(function(props) {
  const {
    childItemId,
    isActive,
    pane: pane2,
    paneKey,
    sortOrder: sortOrderRaw,
    layout
  } = props, schema = useSchema(), releases = useActiveReleases(), {
    perspectiveStack
  } = usePerspective(), {
    displayOptions,
    options
  } = pane2, {
    apiVersion,
    filter: filter2
  } = options, params = useShallowUnique(options.params || EMPTY_RECORD), typeName = useMemo(() => {
    const staticTypes = findStaticTypesInFilter(filter2, params);
    return staticTypes?.length === 1 ? staticTypes[0] : null;
  }, [filter2, params]), showIcons = displayOptions?.showIcons !== !1, {
    t
  } = useTranslation(structureLocaleNamespace), {
    title
  } = useI18nText(pane2), [searchQuery, setSearchQuery] = useState(""), [searchInputValue, setSearchInputValue] = useState(""), [searchInputElement, setSearchInputElement] = useState(null), sortWithOrderingFn = typeName && sortOrderRaw ? applyOrderingFunctions(sortOrderRaw, schema.get(typeName)) : sortOrderRaw, sortOrder = useUnique(sortWithOrderingFn), {
    error,
    isLoadingFullList,
    isLoading: documentListIsLoading,
    items,
    fromCache,
    isRetrying,
    autoRetry,
    canRetry,
    retryCount,
    connected,
    onLoadFullList,
    onRetry
  } = useDocumentList({
    apiVersion,
    filter: filter2,
    perspective: perspectiveStack,
    params,
    searchQuery: searchQuery?.trim(),
    sortOrder
  }), isLoading = documentListIsLoading || releases.loading, handleQueryChange = useObservableEvent((event$) => event$.pipe(map$1((event) => event.target.value), tap$1(setSearchInputValue), debounce((value) => value === "" ? of("") : timer(300)), tap$1(setSearchQuery))), handleClearSearch = useCallback(() => {
    setSearchQuery(""), setSearchInputValue("");
  }, []), handleSearchKeyDown = useCallback((event_0) => {
    event_0.key === "Escape" && handleClearSearch();
  }, [handleClearSearch]), [enableSearchSpinner, setEnableSearchSpinner] = useState();
  useEffect(() => {
    !enableSearchSpinner && !isLoading && setEnableSearchSpinner(paneKey);
  }, [enableSearchSpinner, isLoading, paneKey]), useEffect(() => {
    handleClearSearch(), setEnableSearchSpinner();
  }, [paneKey, handleClearSearch]);
  const loadingVariant = useMemo(() => connected && isLoading && enableSearchSpinner === paneKey ? "spinner" : connected && fromCache ? "subtle" : "initial", [connected, enableSearchSpinner, fromCache, isLoading, paneKey]), textInputIcon = useMemo(() => loadingVariant === "spinner" ? AnimatedSpinnerIcon : searchInputValue && loadingVariant === "subtle" ? SubtleSpinnerIcon : SearchIcon, [loadingVariant, searchInputValue]);
  return useReconnectingToast(!connected), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Box, { paddingX: 3, paddingBottom: 3, children: /* @__PURE__ */ jsx(TextInput, { "aria-label": t("panes.document-list-pane.search-input.aria-label"), autoComplete: "off", border: !1, clearButton: !!searchQuery, fontSize: [2, 2, 1], icon: textInputIcon, iconRight: !connected || loadingVariant === "subtle" && !searchInputValue ? DelayedSubtleSpinnerIcon : null, onChange: handleQueryChange, onClear: handleClearSearch, onKeyDown: handleSearchKeyDown, padding: 2, placeholder: t("panes.document-list-pane.search-input.placeholder"), radius: 2, ref: setSearchInputElement, spellCheck: !1, value: searchInputValue }) }),
    /* @__PURE__ */ jsx(DocumentListPaneContent, { childItemId, error, filterIsSimpleTypeConstraint: !!typeName, hasMaxItems: items.length === FULL_LIST_LIMIT, hasSearchQuery: !!searchQuery, isActive, isLazyLoading: isLoadingFullList, isLoading, autoRetry, canRetry, retryCount, isRetrying, isConnected: connected, items, layout, muted: loadingVariant === "subtle", loadingVariant, onEndReached: onLoadFullList, onRetry, paneTitle: title, searchInputElement, showIcons }, paneKey)
  ] });
}), PaneHeader = memo((t0) => {
  const $ = c(27), {
    contentAfter,
    index,
    initialValueTemplates: t1,
    menuItemGroups: t2,
    menuItems: t3,
    setLayout,
    setSortOrder,
    title
  } = t0;
  let t4;
  $[0] !== t1 ? (t4 = t1 === void 0 ? [] : t1, $[0] = t1, $[1] = t4) : t4 = $[1];
  const initialValueTemplates = t4;
  let t5;
  $[2] !== t2 ? (t5 = t2 === void 0 ? [] : t2, $[2] = t2, $[3] = t5) : t5 = $[3];
  const menuItemGroups = t5;
  let t6;
  $[4] !== t3 ? (t6 = t3 === void 0 ? [] : t3, $[4] = t3, $[5] = t6) : t6 = $[5];
  const menuItems = t6, {
    features
  } = useStructureTool(), {
    collapsed,
    isLast
  } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0;
  let t7, t8;
  $[6] !== setLayout ? (t8 = (t92) => {
    const {
      layout: value
    } = t92;
    setLayout(value);
  }, $[6] = setLayout, $[7] = t8) : t8 = $[7];
  let t9;
  $[8] !== setSortOrder ? (t9 = (sort) => {
    setSortOrder(sort);
  }, $[8] = setSortOrder, $[9] = t9) : t9 = $[9];
  let t10;
  $[10] !== t8 || $[11] !== t9 ? (t10 = {
    setLayout: t8,
    setSortOrder: t9
  }, $[10] = t8, $[11] = t9, $[12] = t10) : t10 = $[12], t7 = t10;
  const actionHandlers = t7;
  let t11;
  $[13] !== actionHandlers || $[14] !== initialValueTemplates || $[15] !== menuItemGroups || $[16] !== menuItems ? (t11 = /* @__PURE__ */ jsx(PaneHeaderActions, { initialValueTemplateItems: initialValueTemplates, actionHandlers, menuItemGroups, menuItems }), $[13] = actionHandlers, $[14] = initialValueTemplates, $[15] = menuItemGroups, $[16] = menuItems, $[17] = t11) : t11 = $[17];
  let t12;
  $[18] !== features.backButton || $[19] !== index ? (t12 = features.backButton && index > 0 && /* @__PURE__ */ jsx(Button, { as: BackLink, "data-as": "a", icon: ArrowLeftIcon, mode: "bleed", tooltipProps: {
    content: "Back"
  } }), $[18] = features.backButton, $[19] = index, $[20] = t12) : t12 = $[20];
  let t13;
  return $[21] !== contentAfter || $[22] !== t11 || $[23] !== t12 || $[24] !== tabIndex || $[25] !== title ? (t13 = /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsx(PaneHeader$1, { actions: t11, backButton: t12, contentAfter, tabIndex, title }) }), $[21] = contentAfter, $[22] = t11, $[23] = t12, $[24] = tabIndex, $[25] = title, $[26] = t13) : t13 = $[26], t13;
});
PaneHeader.displayName = "Memo(PaneHeader)";
function DocumentSheetListSelect(props) {
  const {
    row,
    table
  } = props, {
    selectedAnchor,
    setSelectedAnchor
  } = table.options.meta || {}, handleOnClick = useCallback((e) => {
    if (e.shiftKey && selectedAnchor !== null && selectedAnchor !== void 0) {
      const shiftClickIndex = row.index, lowerIndex = shiftClickIndex < selectedAnchor ? shiftClickIndex : selectedAnchor, upperIndex = shiftClickIndex < selectedAnchor ? selectedAnchor : shiftClickIndex, additionalSelectedRows = table.getRowModel().flatRows.slice(lowerIndex, upperIndex + 1).map(({
        id
      }) => id), currentSelectedRows = table.getSelectedRowModel().rows.map(({
        id: id_0
      }) => id_0);
      table.setRowSelection(() => [...additionalSelectedRows, ...currentSelectedRows].reduce((nextSelectedRows, rowId) => ({
        ...nextSelectedRows,
        [rowId]: !0
      }), {}));
    } else if (setSelectedAnchor) {
      const isRowCurrentlySelected = row.getIsSelected();
      setSelectedAnchor(isRowCurrentlySelected ? null : row.index), row.toggleSelected();
    }
  }, [selectedAnchor, row, setSelectedAnchor, table]);
  return /* @__PURE__ */ jsx(
    Checkbox,
    {
      style: {
        paddingLeft: 4
      },
      checked: props.row.getIsSelected(),
      disabled: !props.row.getCanSelect(),
      onChange: () => null,
      onClick: handleOnClick
    }
  );
}
const useDocumentSheetListContext = () => {
  const context = useContext(DocumentSheetListContext);
  if (context === void 0)
    throw new Error("useDocumentSheetListContext must be used within an DocumentSheetListProvider");
  return context;
};
function DocumentSheetListProvider({
  children,
  table
}) {
  const [selectedAnchorCellDetails, setSelectedAnchorCellDetails] = useState(null), [selectedRangeCellIndexes, setSelectedRangeCellIndexes] = useState([]), clearAndSetFocusSelection = useCallback((nextAnchorDetails = null) => {
    selectedAnchorCellDetails?.state === "focused" && document.activeElement instanceof HTMLElement && document.activeElement.blur(), setSelectedAnchorCellDetails(nextAnchorDetails), setSelectedRangeCellIndexes([]);
  }, [selectedAnchorCellDetails]), resetFocusSelection = useCallback(() => clearAndSetFocusSelection(), [clearAndSetFocusSelection]), changeSelectionColumn = useCallback((direction) => {
    if (!selectedAnchorCellDetails) return;
    const visibleColumns = table.getVisibleLeafColumns(), columnIndexAfterMove = visibleColumns.findIndex((col) => col.id === selectedAnchorCellDetails.colId) + (direction === "left" ? -1 : 1);
    columnIndexAfterMove < 0 || columnIndexAfterMove >= visibleColumns.length || clearAndSetFocusSelection({
      colId: visibleColumns[columnIndexAfterMove].id,
      rowIndex: selectedAnchorCellDetails.rowIndex,
      state: "selected"
    });
  }, [clearAndSetFocusSelection, selectedAnchorCellDetails, table]), changeSelectionRange = useCallback((direction_0) => {
    selectedAnchorCellDetails && setSelectedRangeCellIndexes((previousSelection) => {
      const {
        rowIndex: anchorIndex
      } = selectedAnchorCellDetails, getNextIndex = (startingIndex) => startingIndex + (direction_0 === "down" ? 1 : -1);
      if (!previousSelection.length) {
        const firstSelectedIndex = getNextIndex(anchorIndex);
        return firstSelectedIndex < 0 ? [] : [firstSelectedIndex];
      }
      const lastIndexSelected = previousSelection[previousSelection.length - 1], nextIndex = getNextIndex(lastIndexSelected);
      return nextIndex < 0 ? previousSelection : nextIndex === anchorIndex ? [] : previousSelection.includes(nextIndex) ? previousSelection.slice(0, -1) : [...previousSelection, nextIndex];
    });
  }, [selectedAnchorCellDetails]), setSelectedAnchorCell = useCallback((colId, rowIndex) => {
    clearAndSetFocusSelection({
      colId,
      rowIndex,
      state: "selected"
    });
  }, [clearAndSetFocusSelection]), handleEscapePress = useCallback(() => {
    if (selectedAnchorCellDetails)
      if (selectedRangeCellIndexes.length)
        setSelectedRangeCellIndexes([]);
      else {
        const nextAnchorCellDetails = selectedAnchorCellDetails.state === "selected" ? null : {
          ...selectedAnchorCellDetails,
          state: "selected"
        };
        clearAndSetFocusSelection(nextAnchorCellDetails);
      }
  }, [clearAndSetFocusSelection, selectedAnchorCellDetails, selectedRangeCellIndexes.length]), handleUpDownKey = useCallback((isShiftKey, key) => {
    if (!selectedAnchorCellDetails) return;
    const direction_1 = key === "ArrowDown" ? "down" : "up", offset = direction_1 === "down" ? 1 : -1;
    if (isShiftKey)
      changeSelectionRange(direction_1);
    else {
      const newSelectedCellRowIndex = selectedAnchorCellDetails.rowIndex + offset;
      if (newSelectedCellRowIndex < 0) return;
      setSelectedAnchorCell(selectedAnchorCellDetails.colId, newSelectedCellRowIndex);
    }
  }, [changeSelectionRange, selectedAnchorCellDetails, setSelectedAnchorCell]), handleAnchorKeydown = useCallback((event) => {
    if (!selectedAnchorCellDetails) return;
    const {
      key: key_0,
      shiftKey
    } = event;
    switch (key_0) {
      case "Shift":
        break;
      // shift allow should do nothing
      case "Escape":
        handleEscapePress();
        break;
      case "ArrowDown":
      case "ArrowUp":
        event.preventDefault(), handleUpDownKey(shiftKey, key_0);
        break;
      case "ArrowLeft":
      case "ArrowRight":
        selectedAnchorCellDetails.state === "selected" && (event.preventDefault(), changeSelectionColumn(key_0 === "ArrowLeft" ? "left" : "right"));
        break;
    }
  }, [selectedAnchorCellDetails, handleEscapePress, handleUpDownKey, changeSelectionColumn]), handleAnchorClick = useCallback((event_0) => {
    selectedAnchorCellDetails && (document.getElementById(`cell-${selectedAnchorCellDetails.colId}-${selectedAnchorCellDetails.rowIndex}`)?.contains(event_0.target) || resetFocusSelection());
  }, [resetFocusSelection, selectedAnchorCellDetails]);
  useEffect(() => (selectedAnchorCellDetails && (document.addEventListener("keydown", handleAnchorKeydown), document.addEventListener("click", handleAnchorClick)), () => {
    selectedAnchorCellDetails && (document.removeEventListener("keydown", handleAnchorKeydown), document.removeEventListener("click", handleAnchorClick));
  }), [handleAnchorClick, handleAnchorKeydown, selectedAnchorCellDetails]);
  const focusAnchorCell = useCallback(() => setSelectedAnchorCellDetails((anchorCellDetails) => anchorCellDetails ? {
    ...anchorCellDetails,
    state: "focused"
  } : null), []), getStateByCellId = useCallback((colId_0, rowIndex_0) => selectedAnchorCellDetails?.colId !== colId_0 ? null : selectedAnchorCellDetails.rowIndex === rowIndex_0 ? selectedAnchorCellDetails.state === "focused" ? "focused" : "selectedAnchor" : selectedRangeCellIndexes.includes(rowIndex_0) ? "selectedRange" : null, [selectedAnchorCellDetails, selectedRangeCellIndexes]), submitFocusedCell = useCallback(() => {
    selectedAnchorCellDetails && clearAndSetFocusSelection({
      colId: selectedAnchorCellDetails.colId,
      rowIndex: selectedAnchorCellDetails.rowIndex + 1,
      state: "selected"
    });
  }, [clearAndSetFocusSelection, selectedAnchorCellDetails]), value = useMemo(() => ({
    focusAnchorCell,
    resetFocusSelection,
    setSelectedAnchorCell,
    getStateByCellId,
    submitFocusedCell
  }), [focusAnchorCell, resetFocusSelection, setSelectedAnchorCell, getStateByCellId, submitFocusedCell]);
  return /* @__PURE__ */ jsx(DocumentSheetListContext.Provider, { value, children });
}
const DataCell = styled.td`
  display: flex;
  overflow: hidden;
  box-sizing: border-box;
  width: ${({
  width
}) => width}px;
  border-top: 1px solid var(--card-border-color);
  background-color: var(--card-bg-color);
`, PinnedDataCell = styled(DataCell)`
  position: sticky;
  z-index: 2;
`;
function SheetListCellInner(props) {
  const {
    getValue,
    column,
    row,
    fieldType
  } = props, cellId = `cell-${column.id}-${row.index}`, [renderValue, setRenderValue] = useState(getValue()), [isDirty, setIsDirty] = useState(!1), inputRef = useRef(null), {
    focusAnchorCell,
    resetFocusSelection,
    setSelectedAnchorCell,
    getStateByCellId,
    submitFocusedCell
  } = useDocumentSheetListContext(), cellState = getStateByCellId(column.id, row.index), handleOnFocus = useCallback(() => {
    setSelectedAnchorCell(column.id, row.index), focusAnchorCell();
  }, [column.id, focusAnchorCell, row.index, setSelectedAnchorCell]), {
    patchDocument
  } = props.table.options.meta || {}, handleProgrammaticFocus = () => {
    inputRef.current?.focus(), inputRef.current instanceof HTMLInputElement && inputRef.current.select();
  }, handleOnMouseDown = (event) => {
    event.detail === 2 ? handleProgrammaticFocus() : (event.preventDefault(), setSelectedAnchorCell(column.id, row.index));
  }, handleOnEnterDown = useCallback((event_0) => {
    const {
      key
    } = event_0;
    key === "Enter" && (cellState === "selectedAnchor" && handleProgrammaticFocus(), cellState === "focused" && submitFocusedCell());
  }, [cellState, submitFocusedCell]), handleOnChange = (event_1) => {
    setIsDirty(!0), setRenderValue(event_1.target.value);
  }, handleOnBlur = () => {
    isDirty && (patchDocument?.(row.id, column.id, renderValue), setIsDirty(!1)), resetFocusSelection();
  }, handlePaste = useCallback((event_2) => {
    const clipboardData = event_2.clipboardData?.getData("Text");
    (typeof clipboardData == "string" || typeof clipboardData == "number") && (setRenderValue(clipboardData), patchDocument?.(row.id, column.id, clipboardData));
  }, [column.id, patchDocument, row.id]), handleCopy = useCallback(() => {
    navigator.clipboard.writeText(renderValue.toString());
  }, [renderValue]);
  useEffect(() => ((cellState === "selectedAnchor" || cellState === "focused") && document.addEventListener("keydown", handleOnEnterDown), (cellState === "selectedAnchor" || cellState === "selectedRange") && document.addEventListener("paste", handlePaste), cellState === "selectedAnchor" && document.addEventListener("copy", handleCopy), () => {
    (cellState === "selectedAnchor" || cellState === "focused") && document.removeEventListener("keydown", handleOnEnterDown), (cellState === "selectedAnchor" || cellState === "selectedRange") && document.removeEventListener("paste", handlePaste), cellState === "selectedAnchor" && document.removeEventListener("copy", handleCopy);
  }), [cellId, cellState, column.id, getStateByCellId, handleCopy, handleOnEnterDown, handlePaste, row.index]);
  const getBorderStyle = () => cellState === "focused" ? "2px solid blue" : cellState === "selectedRange" ? "1px solid green" : cellState === "selectedAnchor" ? "1px solid blue" : "1px solid transparent", inputProps = {
    onFocus: handleOnFocus,
    onBlur: handleOnBlur,
    onMouseDown: handleOnMouseDown,
    "aria-selected": !!cellState,
    "data-testid": cellId,
    id: cellId,
    ref: (ref) => {
      inputRef.current = ref;
    }
  };
  return fieldType.name === "boolean" ? /* @__PURE__ */ jsxs(Select, { ...inputProps, onChange: () => null, radius: 0, style: {
    boxShadow: "none",
    border: getBorderStyle(),
    padding: 0
  }, value: JSON.stringify(renderValue), children: [
    /* @__PURE__ */ jsx("option", { value: "True", children: "True" }),
    /* @__PURE__ */ jsx("option", { value: "False", children: "False" })
  ] }) : /* @__PURE__ */ jsx(TextInput, { ...inputProps, size: 0, radius: 0, border: !1, style: {
    border: getBorderStyle(),
    padding: "22px 16px"
  }, value: typeof renderValue == "string" || typeof renderValue == "number" ? renderValue : JSON.stringify(renderValue), onChange: handleOnChange });
}
function SheetListCell(cell) {
  const isPinned = cell.column.getIsPinned(), Cell = isPinned ? PinnedDataCell : DataCell, borderWidth = isPinned && cell.column.getIsLastColumn("left") ? 2 : 1;
  return /* @__PURE__ */ jsx(Cell, { style: {
    left: cell.column.getStart("left") ?? void 0,
    borderRight: `${borderWidth}px solid var(--card-border-color)`
  }, width: cell.column.getSize(), children: flexRender(cell.column.columnDef.cell, cell.getContext?.()) }, cell.row.original._id + cell.id);
}
const VISIBLE_COLUMN_LIMIT = 5, PreviewCell = (props) => {
  const {
    documentPreviewStore,
    row,
    schemaType
  } = props, previewStateObservable = useMemo(() => getPreviewStateObservable(documentPreviewStore, schemaType, row.original._id), [documentPreviewStore, row.original._id, schemaType]), versionsInfo = useDocumentVersionInfo(row.original._id), {
    snapshot,
    isLoading
  } = useObservable(previewStateObservable, {
    snapshot: null,
    isLoading: !0
  });
  if (isLoading)
    return /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: "Loading..." });
  const displayValue = snapshot?.title ?? "Untitled";
  return /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
    /* @__PURE__ */ jsx(DocumentStatusIndicator, { draft: versionsInfo.draft, published: versionsInfo.published, versions: void 0 }),
    /* @__PURE__ */ jsx(Text, { size: 1, children: displayValue })
  ] });
}, columnHelper = createColumnHelper(), SUPPORTED_FIELDS = ["string", "number", "boolean"], getColsFromSchemaType = (schemaType, parentalField) => schemaType.fields.reduce((tableColumns, field) => {
  const {
    type,
    name
  } = field;
  if (SUPPORTED_FIELDS.includes(type.name)) {
    const nextCol = columnHelper.accessor(
      // accessor must use dot notation for internal tanstack method of reading cell data
      parentalField ? `${parentalField}.${field.name}` : field.name,
      {
        id: parentalField ? `${parentalField}_${field.name}` : field.name,
        header: field.type.title,
        enableHiding: !0,
        cell: (info) => /* @__PURE__ */ jsx(SheetListCellInner, { ...info, fieldType: type })
      }
    );
    return [...tableColumns, nextCol];
  }
  return type.name === "object" && isObjectSchemaType(type) && !parentalField ? [...tableColumns, columnHelper.group({
    header: name,
    columns: getColsFromSchemaType(type, field.name)
  })] : tableColumns;
}, []);
function isAccessorKeyColumnDef(column) {
  return "accessorKey" in column;
}
function isGroupColumnDef(column) {
  return "columns" in column;
}
const flatColumns = (cols) => cols.flatMap((col) => isAccessorKeyColumnDef(col) ? col : isGroupColumnDef(col) ? col.columns ? flatColumns(col.columns) : [] : []);
function useDocumentSheetColumns(documentSchemaType) {
  const documentPreviewStore = useDocumentPreviewStore(), columns = useMemo(() => documentSchemaType ? [columnHelper.display({
    id: "selected",
    enableHiding: !1,
    header: (info) => /* @__PURE__ */ jsxs(Box, { children: [
      /* @__PURE__ */ jsx(Checkbox, { style: {
        paddingLeft: 4
      }, indeterminate: info.table.getIsSomeRowsSelected(), onChange: info.table.getToggleAllPageRowsSelectedHandler() }),
      info.table.getSelectedRowModel().rows.length,
      " selected"
    ] }),
    cell: DocumentSheetListSelect
  }), columnHelper.accessor("Preview", {
    enableHiding: !1,
    id: "Preview",
    cell: (info_0) => /* @__PURE__ */ jsx(PreviewCell, { ...info_0, documentPreviewStore, schemaType: documentSchemaType })
  }), ...getColsFromSchemaType(documentSchemaType)] : [], [documentPreviewStore, documentSchemaType]), [initialColumnsVisibility] = useMemo(() => flatColumns(columns).reduce(([accCols, countAllowedVisible], column) => {
    if (!column.id) throw new Error("Column must have an id");
    const visibilityKey = column.id;
    return column.enableHiding ? countAllowedVisible === VISIBLE_COLUMN_LIMIT ? [{
      ...accCols,
      [visibilityKey]: !1
    }, countAllowedVisible] : [{
      ...accCols,
      [visibilityKey]: !0
    }, countAllowedVisible + 1] : [{
      ...accCols,
      [visibilityKey]: !0
    }, countAllowedVisible];
  }, [{}, 0]), [columns]);
  return {
    columns,
    initialColumnsVisibility
  };
}
function ColumnsControl({
  table
}) {
  const {
    t
  } = useTranslation(), isVisibleLimitReached = table.getVisibleLeafColumns().filter((col) => col.getCanHide()).length >= VISIBLE_COLUMN_LIMIT, setInitialColumns = useCallback(() => {
    table.resetColumnVisibility();
  }, [table]), handleColumnOnChange = (column) => () => {
    column.toggleVisibility();
  }, getColumnVisibilityDisabled = (column_0) => {
    const isColumnVisible = column_0.getIsVisible(), isSingleColumnVisible = table.getVisibleLeafColumns().filter((col_0) => col_0.getCanHide()).length === 1;
    return isVisibleLimitReached && !isColumnVisible || isSingleColumnVisible && isColumnVisible;
  };
  return /* @__PURE__ */ jsx(MenuButton, { button: /* @__PURE__ */ jsx(Button, { mode: "bleed", text: t("sheet-list.edit-columns") }), id: "columns-control", menu: /* @__PURE__ */ jsx(Menu, { padding: 3, paddingTop: 4, style: {
    width: 240
  }, children: /* @__PURE__ */ jsxs(Flex, { direction: "column", height: "fill", gap: 3, children: [
    /* @__PURE__ */ jsx(Text, { weight: "semibold", size: 1, children: t("sheet-list.select-fields") }),
    /* @__PURE__ */ jsx(Flex, { style: {
      flex: "1 1 auto",
      maxHeight: 320,
      overflowY: "scroll"
    }, children: /* @__PURE__ */ jsx(Stack, { children: table.getAllLeafColumns().filter((column_1) => column_1.getCanHide()).map((column_2) => /* @__PURE__ */ jsxs(Flex, { marginY: 2, align: "center", children: [
      /* @__PURE__ */ jsx(Checkbox, { readOnly: getColumnVisibilityDisabled(column_2), checked: column_2.getIsVisible(), onChange: handleColumnOnChange(column_2), id: `col-visibility-${column_2.id}`, style: {
        display: "block"
      } }),
      /* @__PURE__ */ jsx(Box, { flex: 1, paddingLeft: 3, children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx("label", { htmlFor: `col-visibility-${column_2.id}`, children: column_2.columnDef.header?.toString() }) }) })
    ] }, column_2.id)) }) }),
    /* @__PURE__ */ jsx(Button, { width: "fill", mode: "ghost", text: t("sheet-list.reset-columns"), onClick: setInitialColumns })
  ] }) }), placement: "bottom", popover: {
    portal: !0
  } });
}
const SearchContainer = styled(Flex)`
  flex-shrink: 0;
`;
function DocumentSheetListFilter() {
  const $ = c(5), {
    state: t0
  } = useSearchState(), {
    filtersVisible
  } = t0;
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = /* @__PURE__ */ jsx(SearchHeader, {}), $[0] = t1) : t1 = $[0];
  let t2;
  $[1] !== filtersVisible ? (t2 = filtersVisible && /* @__PURE__ */ jsx(Filters, { showTypeFilter: !1 }), $[1] = filtersVisible, $[2] = t2) : t2 = $[2];
  let t3;
  return $[3] !== t2 ? (t3 = /* @__PURE__ */ jsxs(SearchContainer, { children: [
    t1,
    t2
  ] }), $[3] = t2, $[4] = t3) : t3 = $[4], t3;
}
const Header = styled.th`
  margin: 16px;
  z-index: 1;
  padding: 22px 0px;
  border-top: 1px solid var(--card-border-color);
  background-color: var(--card-badge-default-bg-color);
  box-sizing: border-box;
  text-align: left;
  width: ${({
  width
}) => width}px;
  max-width: ${({
  width
}) => width}px;
`, PinnedHeader = styled(Header)`
  position: sticky;
  z-index: 2;
`, HoverMenu = styled.div`
  visibility: hidden;

  ${Header}:hover & {
    visibility: visible;
  }
`;
function DocumentSheetListHeader(props) {
  const {
    header,
    headerGroup
  } = props, {
    t
  } = useTranslation(), isPinned = header.column.getIsPinned(), headerTitle = headerGroup.depth > 0 && !header.column.parent ? null : /* @__PURE__ */ jsx(Text, { size: 1, weight: "semibold", textOverflow: "ellipsis", children: flexRender(header.column.columnDef.header, header.getContext()) }), HeaderTag = isPinned ? PinnedHeader : Header, canShowHeaderMenu = header.column.getCanHide() && (headerGroup.depth === 0 ? !header.column.columns.length : header.column.parent), borderWidth = isPinned && header.column.getIsLastColumn("left") ? 2 : 1;
  return /* @__PURE__ */ jsx(HeaderTag, { style: {
    left: header.column.getStart("left") ?? void 0,
    borderRight: `${borderWidth}px solid var(--card-border-color)`
  }, "data-testid": `header-${header.id}`, width: header.getSize(), children: /* @__PURE__ */ jsxs(Flex, { justify: "space-between", marginX: 2, align: "baseline", children: [
    /* @__PURE__ */ jsx(Tooltip, { delay: 500, content: headerTitle, children: /* @__PURE__ */ jsx(Box, { style: {
      boxSizing: "border-box"
    }, marginLeft: 3, marginRight: 3, children: headerTitle }) }),
    canShowHeaderMenu && /* @__PURE__ */ jsx(HoverMenu, { children: /* @__PURE__ */ jsx(MenuButton, { button: /* @__PURE__ */ jsx(Button, { tooltipProps: {
      content: "Open field menu"
    }, mode: "bleed", icon: EllipsisHorizontalIcon, "data-testid": "field-menu-button" }), id: "field menu", popover: {
      placement: "bottom-end"
    }, menu: /* @__PURE__ */ jsx(Menu, { children: /* @__PURE__ */ jsx(MenuItem, { text: t("sheet-list.hide-field"), icon: CloseIcon, onClick: () => header.column.toggleVisibility() }) }) }) })
  ] }) }, header.id);
}
function DocumentSheetListPaginator({
  table
}) {
  return /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxs(Flex, { gap: 3, align: "center", children: [
    /* @__PURE__ */ jsx(Button, { onClick: () => table.setPageIndex(0), disabled: !table.getCanPreviousPage(), icon: DoubleChevronLeftIcon, tooltipProps: {
      content: "Go to first page"
    } }),
    /* @__PURE__ */ jsx(Button, { onClick: () => table.previousPage(), disabled: !table.getCanPreviousPage(), icon: ChevronLeftIcon, tooltipProps: {
      content: "Go to previous page"
    } }),
    /* @__PURE__ */ jsxs(Text, { style: {
      whiteSpace: "nowrap"
    }, children: [
      table.getState().pagination.pageIndex + 1,
      " of ",
      table.getPageCount()
    ] }),
    /* @__PURE__ */ jsx(Button, { onClick: () => table.nextPage(), disabled: !table.getCanNextPage(), icon: ChevronRightIcon, tooltipProps: {
      content: "Go to next page"
    } }),
    /* @__PURE__ */ jsx(Button, { onClick: () => table.setPageIndex(table.getPageCount() - 1), disabled: !table.getCanNextPage(), icon: DoubleChevronRightIcon, tooltipProps: {
      content: "Go to last page"
    } }),
    /* @__PURE__ */ jsx("select", { value: table.getState().pagination.pageSize, onChange: (e) => {
      table.setPageSize(Number(e.target.value));
    }, children: [25, 50, 100].map((pageSize) => /* @__PURE__ */ jsx("option", { value: pageSize, children: pageSize }, pageSize)) })
  ] }) });
}
function createDocumentsSet(documents) {
  return documents.reduce((acc, doc) => ({
    ...acc,
    [doc._id]: doc
  }), {});
}
function documentsReducer(state2, action) {
  switch (action.type) {
    case "DOCUMENTS_SET": {
      const documents = createDocumentsSet(action.documents);
      return {
        ...state2,
        documents
      };
    }
    case "DOCUMENT_RECEIVED": {
      const nextDocumentResult = action.payload;
      return {
        ...state2,
        documents: {
          ...state2.documents,
          [nextDocumentResult._id]: nextDocumentResult
        }
      };
    }
    case "DOCUMENT_DELETED": {
      const {
        [action.id]: _,
        ...restDocuments
      } = state2.documents;
      return {
        ...state2,
        documents: restDocuments
      };
    }
    case "DOCUMENT_UPDATED": {
      const updatedDocument = action.payload, id = updatedDocument._id, nextDocument = {
        // Add existing document data
        ...state2.documents[id],
        // Add incoming document data
        ...updatedDocument
      };
      return {
        ...state2,
        documents: {
          ...state2.documents,
          [id]: nextDocument
        }
      };
    }
    default:
      return state2;
  }
}
const LISTEN_OPTIONS = {
  events: ["welcome", "mutation", "reconnect"],
  includeResult: !0,
  visibility: "query",
  includeAllVersions: !0,
  tag: "document-sheet-list-store"
};
function useDocumentSheetListStore(t0) {
  const $ = c(25), {
    filter: filter2,
    params,
    apiVersion
  } = t0, QUERY = `*[${filter2}][0...2000]`, t1 = apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion;
  let t2;
  $[0] !== t1 ? (t2 = {
    ...DEFAULT_STUDIO_CLIENT_OPTIONS,
    apiVersion: t1
  }, $[0] = t1, $[1] = t2) : t2 = $[1];
  const client = useClient(t2);
  let t3;
  $[2] === Symbol.for("react.memo_cache_sentinel") ? (t3 = {
    documents: {}
  }, $[2] = t3) : t3 = $[2];
  const [state2, dispatch] = useReducer(documentsReducer, t3), [isLoading, setIsLoading] = useState(client !== null), [error, setError] = useState(null);
  let t4;
  $[3] !== QUERY || $[4] !== client || $[5] !== params ? (t4 = async () => {
    if (!client) {
      setIsLoading(!1);
      return;
    }
    try {
      const res = await client.fetch(QUERY, params);
      dispatch({
        type: "DOCUMENTS_SET",
        documents: res
      }), setIsLoading(!1);
    } catch (t52) {
      setError(t52);
    }
  }, $[3] = QUERY, $[4] = client, $[5] = params, $[6] = t4) : t4 = $[6];
  const initialFetch = t4;
  let t5;
  $[7] !== initialFetch ? (t5 = async (event) => {
    if (event.type === "welcome" && (setIsLoading(!0), await initialFetch(), setIsLoading(!1)), event.type === "reconnect" && setIsLoading(!0), event.type === "mutation") {
      if (event.transition === "appear") {
        const nextDocument = event.result;
        nextDocument && dispatch({
          type: "DOCUMENT_RECEIVED",
          payload: nextDocument
        });
      }
      if (event.transition === "disappear" && dispatch({
        type: "DOCUMENT_DELETED",
        id: event.documentId
      }), event.transition === "update") {
        const updatedDocument = event.result;
        updatedDocument && dispatch({
          type: "DOCUMENT_UPDATED",
          payload: updatedDocument
        });
      }
    }
  }, $[7] = initialFetch, $[8] = t5) : t5 = $[8];
  const handleListenerEvent = t5;
  let t6;
  bb0: {
    if (!client) {
      let t73;
      $[9] === Symbol.for("react.memo_cache_sentinel") ? (t73 = of(), $[9] = t73) : t73 = $[9], t6 = t73;
      break bb0;
    }
    let t72;
    if ($[10] !== QUERY || $[11] !== client.observable || $[12] !== params) {
      let t82;
      $[14] === Symbol.for("react.memo_cache_sentinel") ? (t82 = (err_0) => (setError(err_0), of(err_0)), $[14] = t82) : t82 = $[14], t72 = client.observable.listen(QUERY, params, LISTEN_OPTIONS).pipe(catchError$1(t82)), $[10] = QUERY, $[11] = client.observable, $[12] = params, $[13] = t72;
    } else
      t72 = $[13];
    t6 = t72;
  }
  const listener$ = t6;
  let t7, t8;
  $[15] !== handleListenerEvent || $[16] !== listener$ ? (t7 = () => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub?.unsubscribe();
    };
  }, t8 = [handleListenerEvent, listener$], $[15] = handleListenerEvent, $[16] = listener$, $[17] = t7, $[18] = t8) : (t7 = $[17], t8 = $[18]), useEffect(t7, t8);
  let t9, t10;
  if ($[19] !== state2.documents) {
    const uniques = Object.keys(state2.documents).reduce((acc, key) => {
      const document2 = state2.documents[key], isDraft = document2._id === getDraftId(document2._id), id = isDraft ? document2._id : getDraftId(document2._id);
      return acc[id] && !isDraft || (acc[id] = document2), acc;
    }, {});
    t10 = Object.values(uniques), $[19] = state2.documents, $[20] = t10;
  } else
    t10 = $[20];
  t9 = t10;
  const dataAsArray = t9;
  let t11;
  return $[21] !== dataAsArray || $[22] !== error || $[23] !== isLoading ? (t11 = {
    data: dataAsArray,
    isLoading,
    error
  }, $[21] = dataAsArray, $[22] = error, $[23] = isLoading, $[24] = t11) : t11 = $[24], t11;
}
function useDocumentSheetList(t0) {
  const $ = c(12), {
    typeName
  } = t0, {
    state: state2
  } = useSearchState();
  let t1, map2;
  $[0] !== state2.result.hits ? (map2 = /* @__PURE__ */ new Map(), state2.result.hits.forEach((h) => map2.set(getPublishedId(h.hit._id), h.hit)), $[0] = state2.result.hits, $[1] = map2) : map2 = $[1], t1 = map2;
  const items = t1, t2 = `_type == "${typeName}"`;
  let t3;
  $[2] !== t2 ? (t3 = {
    filter: t2
  }, $[2] = t2, $[3] = t3) : t3 = $[3];
  const {
    data,
    isLoading
  } = useDocumentSheetListStore(t3);
  let t4, t5;
  if ($[4] !== data || $[5] !== items) {
    let t62;
    $[7] !== items ? (t62 = (doc) => items.has(getPublishedId(doc._id)), $[7] = items, $[8] = t62) : t62 = $[8], t5 = data.filter(t62), $[4] = data, $[5] = items, $[6] = t5;
  } else
    t5 = $[6];
  t4 = t5;
  const documents = t4;
  let t6;
  return $[9] !== documents || $[10] !== isLoading ? (t6 = {
    data: documents,
    isLoading
  }, $[9] = documents, $[10] = isLoading, $[11] = t6) : t6 = $[11], t6;
}
const PaneContainer$1 = styled(Flex)`
  height: 100%;
`, TableContainer = styled.div`
  overflow: auto; //our scrollable table container
  position: relative; //needed for sticky header
`, Table = styled.table`
  border-collapse: separate;
  border-spacing: 0;
  font-family: arial, sans-serif;
  white-space: nowrap;
  width: 100%;
  border: 1px solid lightgray;

  thead {
    display: grid;
    position: sticky;
    top: 0;
    z-index: 10;
  }
  tr {
    padding: 0;
  }
  tr:last-child {
    border-bottom: none;
  }
`;
function DocumentSheetListPaneInner({
  documentSchemaType
}) {
  const {
    dispatch,
    state: state2
  } = useSearchState(), {
    columns,
    initialColumnsVisibility
  } = useDocumentSheetColumns(documentSchemaType), {
    data
  } = useDocumentSheetList({
    typeName: documentSchemaType.name
  }), [selectedAnchor, setSelectedAnchor] = useState(null), totalRows = state2.result.hits.length, table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    // Avoids resetting the page index when the data changes, e.g. a mutation is received
    autoResetPageIndex: !1,
    initialState: {
      columnPinning: {
        left: ["selected", "Preview"]
      },
      pagination: {
        pageSize: 25
      },
      columnVisibility: initialColumnsVisibility
    },
    getRowId: (row) => row._id,
    meta: {
      selectedAnchor,
      setSelectedAnchor,
      patchDocument: (documentId, fieldId, value) => null
    }
  }), {
    rows
  } = table.getRowModel();
  useEffect(() => (dispatch({
    type: "TERMS_TYPE_ADD",
    schemaType: documentSchemaType
  }), () => {
    dispatch({
      type: "TERMS_TYPE_REMOVE",
      schemaType: documentSchemaType
    });
  }), [documentSchemaType, dispatch]);
  const renderRow = useCallback((row_0) => /* @__PURE__ */ jsx(Box, { as: "tr", paddingY: 2, style: {
    display: "flex",
    width: "100%"
  }, children: row_0.getVisibleCells().map((cell) => /* @__PURE__ */ createElement(SheetListCell, { ...cell, key: row_0.original._id + cell.id })) }, row_0.original._id + row_0.id), []), rowsCount = `Total: ${totalRows} rows, showing ${rows.length} rows`;
  return /* @__PURE__ */ jsxs(PaneContainer$1, { direction: "column", paddingX: 3, "data-testid": "document-sheet-list-pane", children: [
    /* @__PURE__ */ jsxs(Flex, { direction: "row", align: "center", paddingY: 3, paddingX: 1, justify: "space-between", children: [
      /* @__PURE__ */ jsxs(Flex, { direction: "row", align: "center", children: [
        /* @__PURE__ */ jsx(DocumentSheetListFilter, {}),
        /* @__PURE__ */ jsx(Text, { size: 0, muted: !0, children: rowsCount })
      ] }),
      /* @__PURE__ */ jsx(ColumnsControl, { table })
    ] }),
    /* @__PURE__ */ jsx(TableContainer, { children: /* @__PURE__ */ jsx(DocumentSheetListProvider, { table, children: /* @__PURE__ */ jsxs(Table, { children: [
      /* @__PURE__ */ jsx("thead", { children: table.getHeaderGroups().map((headerGroup) => /* @__PURE__ */ jsx(Box, { as: "tr", children: headerGroup.headers.map((header) => /* @__PURE__ */ jsx(DocumentSheetListHeader, { header, headerGroup }, header.id)) }, headerGroup.id)) }),
      /* @__PURE__ */ jsx("tbody", { children: table.getRowModel().rows.map(renderRow) })
    ] }) }) }),
    /* @__PURE__ */ jsx(Flex, { justify: "flex-end", padding: 3, gap: 4, paddingY: 5, children: /* @__PURE__ */ jsx(DocumentSheetListPaginator, { table }) })
  ] });
}
function DocumentSheetListPane(props) {
  const schema = useSchema(), typeName = props.pane.schemaTypeName, schemaType = schema.get(typeName);
  if (!schemaType || !isDocumentSchemaType(schemaType))
    throw new Error(`Schema type "${typeName}" not found or not a document schema`);
  return /* @__PURE__ */ jsx(SearchProvider, { children: /* @__PURE__ */ jsx(DocumentSheetListPaneInner, { ...props, documentSchemaType: schemaType }) });
}
const addSelectedStateToMenuItems = (options) => {
  const {
    menuItems,
    sortOrderRaw,
    layout
  } = options;
  return menuItems?.map((item) => item.params?.layout ? {
    ...item,
    selected: layout === item.params?.layout
  } : item?.params?.by ? {
    ...item,
    selected: isEqual(sortOrderRaw?.by, item?.params?.by || EMPTY_ARRAY$2)
  } : {
    ...item,
    selected: !1
  });
};
function useShallowUnique(value) {
  const [previous, setPrevious] = useState(value);
  return shallowEquals(previous, value) ? previous : (setPrevious(value), value);
}
const PaneContainer = memo(function(props) {
  const $ = c(36), {
    index,
    isSelected,
    pane: pane2,
    paneKey
  } = props, {
    name: parentSourceName
  } = useSource(), {
    defaultLayout: t0,
    initialValueTemplates: t1,
    menuItemGroups,
    menuItems,
    options
  } = pane2, defaultLayout = t0 === void 0 ? "default" : t0, initialValueTemplates = t1 === void 0 ? EMPTY_ARRAY$2 : t1, {
    defaultOrdering: t2,
    filter: filter2
  } = options, defaultOrdering = t2 === void 0 ? EMPTY_ARRAY$2 : t2, params = useShallowUnique(options.params || EMPTY_RECORD), sourceName = pane2.source;
  let t3;
  bb0: {
    let t42;
    $[0] !== filter2 || $[1] !== params ? (t42 = findStaticTypesInFilter(filter2, params), $[0] = filter2, $[1] = params, $[2] = t42) : t42 = $[2];
    const staticTypes = t42;
    if (staticTypes?.length === 1) {
      t3 = staticTypes[0];
      break bb0;
    }
    t3 = null;
  }
  const typeName = t3, [layout, setLayout] = useStructureToolSetting("layout", typeName ?? pane2.id, defaultLayout), {
    title
  } = useI18nText(pane2);
  let t4, t5;
  $[3] !== defaultOrdering ? (t5 = defaultOrdering?.length > 0 ? {
    by: defaultOrdering
  } : DEFAULT_ORDERING, $[3] = defaultOrdering, $[4] = t5) : t5 = $[4], t4 = t5;
  const defaultSortOrder = t4, [sortOrderRaw, setSortOrder] = useStructureToolSetting("sort-order", typeName ?? pane2.id, defaultSortOrder);
  let t6, t7;
  $[5] !== layout || $[6] !== menuItems || $[7] !== sortOrderRaw ? (t7 = addSelectedStateToMenuItems({
    menuItems,
    sortOrderRaw,
    layout
  }), $[5] = layout, $[6] = menuItems, $[7] = sortOrderRaw, $[8] = t7) : t7 = $[8], t6 = t7;
  const menuItemsWithSelectedState = t6, isSheetListLayout = layout === "sheetList";
  let t8;
  $[9] !== isSheetListLayout || $[10] !== layout || $[11] !== props || $[12] !== sortOrderRaw ? (t8 = isSheetListLayout ? /* @__PURE__ */ createElement(DocumentSheetListPane, { ...props, key: props.pane.id }) : /* @__PURE__ */ jsx(DocumentListPane, { ...props, sortOrder: sortOrderRaw, layout }), $[9] = isSheetListLayout, $[10] = layout, $[11] = props, $[12] = sortOrderRaw, $[13] = t8) : t8 = $[13];
  const paneLayout = t8, t9 = sourceName || parentSourceName;
  let t10;
  $[14] !== isSheetListLayout ? (t10 = isSheetListLayout ? {} : {
    currentMaxWidth: 350,
    maxWidth: 640
  }, $[14] = isSheetListLayout, $[15] = t10) : t10 = $[15];
  let t11;
  $[16] !== pane2.source ? (t11 = _DEBUG, $[16] = pane2.source, $[17] = t11) : t11 = $[17];
  let t12;
  $[18] !== index || $[19] !== initialValueTemplates || $[20] !== menuItemGroups || $[21] !== menuItemsWithSelectedState || $[22] !== setLayout || $[23] !== setSortOrder || $[24] !== title ? (t12 = /* @__PURE__ */ jsx(PaneHeader, { index, initialValueTemplates, menuItemGroups, menuItems: menuItemsWithSelectedState, setLayout, setSortOrder, title }), $[18] = index, $[19] = initialValueTemplates, $[20] = menuItemGroups, $[21] = menuItemsWithSelectedState, $[22] = setLayout, $[23] = setSortOrder, $[24] = title, $[25] = t12) : t12 = $[25];
  let t13;
  $[26] !== isSelected || $[27] !== paneKey || $[28] !== paneLayout || $[29] !== t10 || $[30] !== t11 || $[31] !== t12 ? (t13 = /* @__PURE__ */ jsxs(Pane, { "data-ui": "DocumentListPane", id: paneKey, minWidth: 320, ...t10, selected: isSelected, children: [
    t11,
    t12,
    paneLayout
  ] }), $[26] = isSelected, $[27] = paneKey, $[28] = paneLayout, $[29] = t10, $[30] = t11, $[31] = t12, $[32] = t13) : t13 = $[32];
  let t14;
  return $[33] !== t13 || $[34] !== t9 ? (t14 = /* @__PURE__ */ jsx(SourceProvider, { name: t9, children: t13 }), $[33] = t13, $[34] = t9, $[35] = t14) : t14 = $[35], t14;
});
PaneContainer.displayName = "Memo(PaneContainer)";
const LiveEditBadge = (props) => {
  const {
    liveEditSchemaType,
    version
  } = props;
  return liveEditSchemaType && !version ? {
    label: "Live",
    color: "danger"
  } : null;
};
LiveEditBadge.displayName = "LiveEditBadge";
const state = {
  activePanes: []
};
function setActivePanes(panes) {
  state.activePanes = panes;
}
function getIntentState(intent, params, routerState, payload) {
  const panes = routerState?.panes || [], activePanes = state.activePanes || [], editDocumentId = params.id || uuid();
  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane2 = activePanes[i];
    if (typeof pane2 == "object" && (pane2.canHandleIntent?.(intent, params, {
      pane: pane2,
      index: i
    }) || // see `resolveIntent.ts` for more info
    pane2.type === "documentList" && pane2.schemaTypeName === params.type && pane2.options.filter === "_type == $type")) {
      const paneParams = getPaneParams(intent, params);
      return {
        panes: panes.slice(0, i).concat([[{
          id: editDocumentId,
          params: paneParams,
          payload
        }]])
      };
    }
  }
  return {
    intent,
    params,
    payload
  };
}
function getPaneParams(intent, {
  template,
  version
}) {
  return intent !== "create" ? EMPTY_PARAMS$1 : template && version ? {
    template,
    version
  } : template ? {
    template
  } : version ? {
    version
  } : EMPTY_PARAMS$1;
}
const Scroller$3 = styled(ScrollContainer)`
  height: 100%;
  overflow: auto;
  position: relative;
  scroll-behavior: smooth;
`, Grid$1 = styled(Box)`
  &:not([hidden]) {
    display: grid;
  }
  grid-template-columns: 48px 1fr;
  align-items: center;
  gap: 0.25em;
`;
function ChangesInspector(t0) {
  const $ = c(39), {
    showChanges
  } = t0, {
    documentId,
    schemaType,
    timelineError,
    timelineStore,
    value
  } = useDocumentPane(), {
    selectedReleaseId
  } = usePerspective(), [scrollRef, setScrollRef] = useState(null), rev = useTimelineSelector(timelineStore, _temp$2), diff = useTimelineSelector(timelineStore, _temp2), onOlderRevision = useTimelineSelector(timelineStore, _temp3), selectionState = useTimelineSelector(timelineStore, _temp4), sinceTime = useTimelineSelector(timelineStore, _temp5), loading = selectionState === "loading", isComparingCurrent = !onOlderRevision, {
    t: structureT
  } = useTranslation(structureLocaleNamespace);
  let t1, t2;
  $[0] !== diff || $[1] !== documentId || $[2] !== isComparingCurrent || $[3] !== schemaType || $[4] !== value ? (t2 = {
    documentId,
    schemaType,
    FieldWrapper: _temp6,
    rootDiff: diff,
    isComparingCurrent,
    value,
    showFromValue: !0
  }, $[0] = diff, $[1] = documentId, $[2] = isComparingCurrent, $[3] = schemaType, $[4] = value, $[5] = t2) : t2 = $[5], t1 = t2;
  const documentContext = t1;
  if (selectedReleaseId) {
    let t32;
    return $[6] === Symbol.for("react.memo_cache_sentinel") ? (t32 = /* @__PURE__ */ jsx(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", children: /* @__PURE__ */ jsx(Card, { flex: 1, padding: 2, paddingTop: 0, children: /* @__PURE__ */ jsx(TimelineError, { versionError: !0 }) }) }), $[6] = t32) : t32 = $[6], t32;
  }
  let t3;
  $[7] !== structureT ? (t3 = structureT("changes.from.label"), $[7] = structureT, $[8] = t3) : t3 = $[8];
  let t4;
  $[9] !== t3 ? (t4 = /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: t3 }), $[9] = t3, $[10] = t4) : t4 = $[10];
  let t5;
  $[11] !== sinceTime ? (t5 = /* @__PURE__ */ jsx(TimelineMenu, { mode: "since", chunk: sinceTime, placement: "bottom-start" }), $[11] = sinceTime, $[12] = t5) : t5 = $[12];
  let t6;
  $[13] !== structureT ? (t6 = structureT("changes.to.label"), $[13] = structureT, $[14] = t6) : t6 = $[14];
  let t7;
  $[15] !== t6 ? (t7 = /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: t6 }), $[15] = t6, $[16] = t7) : t7 = $[16];
  let t8;
  $[17] !== rev ? (t8 = /* @__PURE__ */ jsx(TimelineMenu, { chunk: rev, mode: "rev", placement: "bottom-end" }), $[17] = rev, $[18] = t8) : t8 = $[18];
  let t9;
  $[19] !== t4 || $[20] !== t5 || $[21] !== t7 || $[22] !== t8 ? (t9 = /* @__PURE__ */ jsx(Box, { padding: 3, children: /* @__PURE__ */ jsxs(Grid$1, { paddingX: 2, paddingBottom: 2, children: [
    t4,
    t5,
    t7,
    t8
  ] }) }), $[19] = t4, $[20] = t5, $[21] = t7, $[22] = t8, $[23] = t9) : t9 = $[23];
  let t10;
  $[24] !== diff || $[25] !== documentContext || $[26] !== loading || $[27] !== schemaType || $[28] !== showChanges || $[29] !== timelineError ? (t10 = showChanges && /* @__PURE__ */ jsx(Content$1, { diff, documentContext, error: timelineError, loading, schemaType }), $[24] = diff, $[25] = documentContext, $[26] = loading, $[27] = schemaType, $[28] = showChanges, $[29] = timelineError, $[30] = t10) : t10 = $[30];
  let t11;
  $[31] !== t10 ? (t11 = /* @__PURE__ */ jsx(Scroller$3, { "data-ui": "Scroller", ref: setScrollRef, children: /* @__PURE__ */ jsx(Box, { flex: 1, paddingX: 3, height: "fill", children: t10 }) }), $[31] = t10, $[32] = t11) : t11 = $[32];
  let t12;
  $[33] !== scrollRef || $[34] !== t11 ? (t12 = /* @__PURE__ */ jsx(Card, { flex: 1, paddingX: 2, paddingY: 2, children: /* @__PURE__ */ jsx(BoundaryElementProvider, { element: scrollRef, children: t11 }) }), $[33] = scrollRef, $[34] = t11, $[35] = t12) : t12 = $[35];
  let t13;
  return $[36] !== t12 || $[37] !== t9 ? (t13 = /* @__PURE__ */ jsxs(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", overflow: "hidden", children: [
    t9,
    t12
  ] }), $[36] = t12, $[37] = t9, $[38] = t13) : t13 = $[38], t13;
}
function _temp6(props) {
  return /* @__PURE__ */ jsx(ChangeFieldWrapper, { ...props, hasRevertHover: !1 });
}
function _temp5(state_3) {
  return state_3.sinceTime;
}
function _temp4(state_2) {
  return state_2.selectionState;
}
function _temp3(state_1) {
  return state_1.onOlderRevision;
}
function _temp2(state_0) {
  return state_0.diff;
}
function _temp$2(state2) {
  return state2.revTime;
}
function Content$1(t0) {
  const $ = c(9), {
    error,
    diff,
    documentContext,
    loading,
    schemaType
  } = t0;
  if (error) {
    let t12;
    return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t12 = /* @__PURE__ */ jsx(NoChanges, {}), $[0] = t12) : t12 = $[0], t12;
  }
  if (loading) {
    let t12;
    return $[1] === Symbol.for("react.memo_cache_sentinel") ? (t12 = /* @__PURE__ */ jsx(LoadingBlock, { showText: !0 }), $[1] = t12) : t12 = $[1], t12;
  }
  if (!diff) {
    let t12;
    return $[2] === Symbol.for("react.memo_cache_sentinel") ? (t12 = /* @__PURE__ */ jsx(NoChanges, {}), $[2] = t12) : t12 = $[2], t12;
  }
  let t1;
  $[3] !== diff || $[4] !== schemaType ? (t1 = /* @__PURE__ */ jsx(ChangeList, { diff, schemaType }), $[3] = diff, $[4] = schemaType, $[5] = t1) : t1 = $[5];
  let t2;
  return $[6] !== documentContext || $[7] !== t1 ? (t2 = /* @__PURE__ */ jsx(DocumentChangeContext.Provider, { value: documentContext, children: t1 }), $[6] = documentContext, $[7] = t1, $[8] = t2) : t2 = $[8], t2;
}
const getIsSelectable = (event) => !isDeleteDocumentVersionEvent(event) && !isDeleteDocumentGroupEvent(event) && !isUnpublishDocumentEvent(event) && !isScheduleDocumentVersionEvent(event) && !isUnscheduleDocumentVersionEvent(event);
function EventTimelineItem(t0) {
  const $ = c(27), {
    event,
    isSelected,
    onSelect,
    optionsMenu
  } = t0, {
    t
  } = useTranslation("studio");
  let t1;
  $[0] !== event ? (t1 = getIsSelectable(event), $[0] = event, $[1] = t1) : t1 = $[1];
  const isSelectable = t1;
  let t2;
  $[2] !== event || $[3] !== isSelectable || $[4] !== onSelect ? (t2 = (evt) => {
    evt.preventDefault(), evt.stopPropagation(), isSelectable && onSelect(event);
  }, $[2] = event, $[3] = isSelectable, $[4] = onSelect, $[5] = t2) : t2 = $[5];
  const handleClick = t2;
  let t3;
  $[6] !== isSelectable || $[7] !== t ? (t3 = isSelectable ? "" : t("changes.not-selectable"), $[6] = isSelectable, $[7] = t, $[8] = t3) : t3 = $[8];
  const t4 = isSelectable ? "button" : "div", t5 = isSelectable ? "pointer" : "default";
  let t6;
  $[9] !== t5 ? (t6 = {
    cursor: t5,
    width: "100%"
  }, $[9] = t5, $[10] = t6) : t6 = $[10];
  let t7;
  $[11] !== event ? (t7 = /* @__PURE__ */ jsx(Event, { event, showChangesBy: "tooltip" }), $[11] = event, $[12] = t7) : t7 = $[12];
  let t8;
  $[13] !== event.timestamp || $[14] !== handleClick || $[15] !== isSelected || $[16] !== t4 || $[17] !== t6 || $[18] !== t7 ? (t8 = /* @__PURE__ */ jsx(Card, { as: t4, onClick: handleClick, padding: 2, pressed: isSelected, radius: 2, "data-ui": "timelineItem", "data-testid": "timeline-item-button", "data-chunk-timestamp": event.timestamp, style: t6, children: t7 }), $[13] = event.timestamp, $[14] = handleClick, $[15] = isSelected, $[16] = t4, $[17] = t6, $[18] = t7, $[19] = t8) : t8 = $[19];
  let t9;
  $[20] !== isSelectable || $[21] !== t3 || $[22] !== t8 ? (t9 = /* @__PURE__ */ jsx(Tooltip, { content: t3, disabled: isSelectable, children: t8 }), $[20] = isSelectable, $[21] = t3, $[22] = t8, $[23] = t9) : t9 = $[23];
  let t10;
  return $[24] !== optionsMenu || $[25] !== t9 ? (t10 = /* @__PURE__ */ jsxs(Flex, { gap: 1, children: [
    t9,
    optionsMenu
  ] }), $[24] = optionsMenu, $[25] = t9, $[26] = t10) : t10 = $[26], t10;
}
function PublishedEventMenu(t0) {
  const $ = c(41), {
    event
  } = t0, {
    t
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation(), portalContext = usePortal(), {
    params,
    setParams
  } = usePaneRouter(), setPerspective = useSetPerspective();
  let t1;
  $[0] !== event.id || $[1] !== event.versionId || $[2] !== event.versionRevisionId || $[3] !== params || $[4] !== setParams ? (t1 = () => {
    setParams({
      ...params,
      rev: event.versionRevisionId || "@lastPublished",
      since: void 0,
      historyEvent: event.id,
      historyVersion: getVersionFromId(event.versionId)
    });
  }, $[0] = event.id, $[1] = event.versionId, $[2] = event.versionRevisionId, $[3] = params, $[4] = setParams, $[5] = t1) : t1 = $[5];
  const handleOpenReleaseDocument = t1;
  let t2;
  $[6] !== event.versionRevisionId || $[7] !== params || $[8] !== setParams || $[9] !== setPerspective ? (t2 = () => {
    setParams({
      ...params,
      rev: event.versionRevisionId,
      preserveRev: "true",
      since: void 0
    }), setTimeout(() => {
      setPerspective("drafts");
    }, 100);
  }, $[6] = event.versionRevisionId, $[7] = params, $[8] = setParams, $[9] = setPerspective, $[10] = t2) : t2 = $[10];
  const handleOpenDraftDocument = t2;
  let t3;
  $[11] !== event.release ? (t3 = (t42) => {
    const {
      children
    } = t42;
    return /* @__PURE__ */ jsx(VersionInlineBadge, { $tone: event.release ? isReleaseDocument(event.release) ? getReleaseTone(event.release) : "default" : void 0, children });
  }, $[11] = event.release, $[12] = t3) : t3 = $[12];
  const VersionBadge = t3, isMenuDisabled = event.release && !isReleaseDocument(event.release), t4 = `timeline-item-menu-button-${event.versionId}`;
  let t5;
  $[13] !== t ? (t5 = t("timeline-item.menu-button.aria-label"), $[13] = t, $[14] = t5) : t5 = $[14];
  let t6;
  $[15] !== event.release || $[16] !== isMenuDisabled || $[17] !== t ? (t6 = isMenuDisabled ? t("timeline-item.not-found-release.tooltip", {
    releaseId: event.release?._id ? getReleaseIdFromReleaseDocumentId(event.release._id) : void 0
  }) : t("timeline-item.menu-button.tooltip"), $[15] = event.release, $[16] = isMenuDisabled, $[17] = t, $[18] = t6) : t6 = $[18];
  let t7;
  $[19] !== t6 ? (t7 = {
    content: t6
  }, $[19] = t6, $[20] = t7) : t7 = $[20];
  let t8;
  $[21] !== isMenuDisabled || $[22] !== t5 || $[23] !== t7 ? (t8 = /* @__PURE__ */ jsx(ContextMenuButton, { "aria-label": t5, tooltipProps: t7, disabled: isMenuDisabled }), $[21] = isMenuDisabled, $[22] = t5, $[23] = t7, $[24] = t8) : t8 = $[24];
  let t9;
  $[25] !== VersionBadge || $[26] !== event.release || $[27] !== event.versionRevisionId || $[28] !== handleOpenDraftDocument || $[29] !== handleOpenReleaseDocument || $[30] !== t || $[31] !== tCore ? (t9 = /* @__PURE__ */ jsx(Menu, { padding: 1, children: event.release ? /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(IntentLink, { intent: RELEASES_INTENT, params: {
      id: getReleaseIdFromReleaseDocumentId(event.release._id)
    }, style: {
      textDecoration: "none"
    }, children: /* @__PURE__ */ jsx(MenuItem$1, { padding: 3, children: /* @__PURE__ */ jsx(Flex, { align: "center", justify: "flex-start", children: /* @__PURE__ */ jsx(Text, { size: 1, style: {
      textDecoration: "none"
    }, children: /* @__PURE__ */ jsx(Translate, { components: {
      VersionBadge: (t102) => {
        const {
          children: children_0
        } = t102;
        return /* @__PURE__ */ jsx(VersionBadge, { children: children_0 });
      }
    }, i18nKey: "events.open.release", values: {
      releaseTitle: event.release.metadata?.title || tCore("release.placeholder-untitled-release")
    }, t }) }) }) }) }),
    /* @__PURE__ */ jsx(MenuItem$1, { onClick: handleOpenReleaseDocument, children: /* @__PURE__ */ jsx(Flex, { align: "center", justify: "flex-start", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Translate, { components: {
      VersionBadge: (t112) => {
        const {
          children: children_1
        } = t112;
        return /* @__PURE__ */ jsx(VersionBadge, { children: children_1 });
      }
    }, i18nKey: "events.inspect.release", values: {
      releaseTitle: event.release.metadata?.title || tCore("release.placeholder-untitled-release")
    }, t }) }) }) })
  ] }) : /* @__PURE__ */ jsx(MenuItem$1, { onClick: handleOpenDraftDocument, disabled: !event.versionRevisionId, children: /* @__PURE__ */ jsx(Flex, { align: "center", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Translate, { components: {
    VersionBadge: _temp$1
  }, i18nKey: "events.open.draft", t }) }) }) }) }), $[25] = VersionBadge, $[26] = event.release, $[27] = event.versionRevisionId, $[28] = handleOpenDraftDocument, $[29] = handleOpenReleaseDocument, $[30] = t, $[31] = tCore, $[32] = t9) : t9 = $[32];
  const t10 = portalContext.elements?.[TIMELINE_MENU_PORTAL$1] ? TIMELINE_MENU_PORTAL$1 : !0;
  let t11;
  $[33] === Symbol.for("react.memo_cache_sentinel") ? (t11 = ["bottom-end", "bottom-start"], $[33] = t11) : t11 = $[33];
  let t12;
  $[34] !== t10 ? (t12 = {
    portal: t10,
    placement: "bottom",
    fallbackPlacements: t11
  }, $[34] = t10, $[35] = t12) : t12 = $[35];
  let t13;
  return $[36] !== t12 || $[37] !== t4 || $[38] !== t8 || $[39] !== t9 ? (t13 = /* @__PURE__ */ jsx(MenuButton, { id: t4, button: t8, menu: t9, popover: t12 }), $[36] = t12, $[37] = t4, $[38] = t8, $[39] = t9, $[40] = t13) : t13 = $[40], t13;
}
function _temp$1(t0) {
  const {
    children: children_2
  } = t0;
  return /* @__PURE__ */ jsx(VersionInlineBadge, { $tone: "caution", children: children_2 });
}
const TimelineItemWrapper = motion.create(Box), CHILDREN_ITEMS_VARIANTS = {
  initial: {
    opacity: 0
  },
  animate: {
    opacity: 1
  },
  exit: {
    opacity: 0
  }
}, ITEM_HEIGHT = 57, TIMELINE_LIST_WRAPPER_ID = "timeline-list-wrapper", EventsTimeline = ({
  events: allEvents,
  hasMoreEvents,
  selectedEventId,
  onLoadMore,
  onSelect,
  listMaxHeight = "calc(100vh - 280px)",
  fetchEventChildren
}) => {
  const [mounted, setMounted] = useState(!1), {
    t
  } = useTranslation("studio"), [expandedParents, setExpandedParents] = useState(() => {
    if (selectedEventId) {
      const selectedEvent = allEvents.find((event) => event.id === selectedEventId);
      if (selectedEvent && "parentId" in selectedEvent && selectedEvent.parentId)
        return /* @__PURE__ */ new Set([selectedEvent.parentId]);
    }
    return /* @__PURE__ */ new Set();
  }), [expandingParents, setExpandingParents] = useState(/* @__PURE__ */ new Set()), events = useMemo(() => allEvents.filter((event_0) => isCreateDocumentVersionEvent(event_0) && event_0.parentId ? allEvents[allEvents.length - 1].id === event_0.id ? !0 : expandedParents.has(event_0.parentId) : isEditDocumentVersionEvent(event_0) && event_0.parentId ? expandedParents.has(event_0.parentId) : !0), [expandedParents, allEvents]), handleExpandParent = useCallback((event_1) => async () => {
    const parentId = event_1.id;
    let isExpanding = !1;
    setExpandedParents((prev) => {
      const next = new Set(prev);
      return prev.has(parentId) ? next.delete(parentId) : (isExpanding = !0, next.add(parentId)), next;
    }), isExpanding && (setExpandingParents((prev_0) => {
      const next_0 = new Set(prev_0);
      return next_0.add(parentId), next_0;
    }), await fetchEventChildren(event_1), setExpandingParents((prev_1) => {
      const next_1 = new Set(prev_1);
      return next_1.delete(parentId), next_1;
    }));
  }, [fetchEventChildren, setExpandingParents]), handleSelectChunk = useCallback((event_2) => {
    onSelect(event_2);
  }, [onSelect]), renderOptionsMenu = useCallback((event_3) => {
    const documentVariantType = getDocumentVariantType(event_3.documentId);
    return isPublishDocumentVersionEvent(event_3) && documentVariantType === "published" ? /* @__PURE__ */ jsx(PublishedEventMenu, { event: event_3 }) : isPublishDocumentVersionEvent(event_3) && documentVariantType === "draft" && event_3.creationEvent || isDeleteDocumentVersionEvent(event_3) && event_3.creationEvent ? /* @__PURE__ */ jsx(ExpandableTimelineItemButton, { isExpanded: expandedParents.has(event_3.id), onExpand: handleExpandParent(event_3) }) : null;
  }, [expandedParents, handleExpandParent]), renderItem = useCallback((event_4, {
    activeIndex
  }) => {
    const showExpandingLoader = isCreateDocumentVersionEvent(event_4) && event_4.parentId && expandingParents.has(event_4.parentId), isLastEvent_0 = activeIndex === events.length - 1;
    return showExpandingLoader ? /* @__PURE__ */ jsx(TimelineItemWrapper, { animate: {
      opacity: 1
    }, initial: {
      opacity: 0
    }, transition: {
      duration: 0.2,
      delay: 0.2
    }, children: /* @__PURE__ */ jsx(Flex, { align: "center", justify: "center", style: {
      height: ITEM_HEIGHT
    }, children: /* @__PURE__ */ jsx(Spinner, {}) }) }) : /* @__PURE__ */ jsxs(TimelineItemWrapper, { paddingBottom: 1, paddingRight: 1, animate: "animate", exit: "exit", initial: "initial", variants: "parentId" in event_4 ? CHILDREN_ITEMS_VARIANTS : void 0, paddingLeft: (isEditDocumentVersionEvent(event_4) || isCreateDocumentVersionEvent(event_4)) && event_4.parentId && !isLastEvent_0 ? 4 : 1, children: [
      /* @__PURE__ */ jsx(EventTimelineItem, { event: event_4, isSelected: event_4.id === selectedEventId, onSelect: handleSelectChunk, optionsMenu: renderOptionsMenu(event_4) }),
      isLastEvent_0 && hasMoreEvents && /* @__PURE__ */ jsx(LoadingBlock, {})
    ] }, event_4.timestamp);
  }, [expandingParents, selectedEventId, handleSelectChunk, renderOptionsMenu, events.length, hasMoreEvents]);
  useEffect(() => setMounted(!0), []);
  const selectedIndex = events.findIndex((event_5) => event_5.id === selectedEventId);
  return /* @__PURE__ */ jsx(
    Root$2,
    {
      $visible: !selectedIndex || mounted,
      "data-ui": "timeline",
      children: events.length > 0 ? /* @__PURE__ */ jsx(ListWrapper, { direction: "column", $maxHeight: listMaxHeight, id: TIMELINE_LIST_WRAPPER_ID, children: /* @__PURE__ */ jsx(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t("timeline.list.aria-label"), autoFocus: "list", initialIndex: selectedIndex, initialScrollAlign: "center", itemHeight: ITEM_HEIGHT, items: events, onEndReached: onLoadMore, onEndReachedIndexOffset: 20, overscan: 5, renderItem, wrapAround: !1 }) }) : /* @__PURE__ */ jsxs(Stack, { padding: 3, space: 3, children: [
        /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t("timeline.error.no-document-history-title") }),
        /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("timeline.error.no-document-history-description") })
      ] })
    }
  );
};
EventsTimeline.displayName = "EventsTimeline";
const Root = styled(Popover)`
  overflow: hidden;
  overflow: clip;
`, TIMELINE_MENU_PORTAL = "timeline-menu", formatParams = {
  timestamp: {
    dateStyle: "medium",
    timeStyle: "short"
  }
};
function EventsTimelineMenu({
  event,
  events,
  mode,
  placement
}) {
  const {
    setTimelineRange
  } = useDocumentPane(), [open, setOpen] = useState(!1), [button, setButton] = useState(null), [popoverRef, setPopoverRef] = useState(null), toast = useToast(), {
    nextCursor,
    loading,
    error: eventsError,
    findRangeForRevision,
    findRangeForSince,
    loadMoreEvents,
    expandEvent
  } = useEvents(), {
    t
  } = useTranslation("studio"), handleOpen = useCallback(() => {
    setOpen(!0);
  }, []), handleClose = useCallback(() => {
    setOpen(!1);
  }, []), handleGlobalKeyDown = useCallback((e) => {
    open && (e.key === "Escape" || e.key === "Tab") && (handleClose(), button?.focus());
  }, [button, handleClose, open]);
  useGlobalKeyDown(handleGlobalKeyDown), useClickOutsideEvent(open && handleClose, () => [button, popoverRef]);
  const selectRev = useCallback((revEvent) => {
    try {
      if (isDeleteDocumentVersionEvent(revEvent) || isDeleteDocumentGroupEvent(revEvent) || isUnpublishDocumentEvent(revEvent) || isScheduleDocumentVersionEvent(revEvent) || isUnscheduleDocumentVersionEvent(revEvent)) {
        console.error("Event is not selectable");
        return;
      }
      const [since, rev] = findRangeForRevision(revEvent?.id);
      setTimelineRange(since, rev), handleClose();
    } catch (err) {
      toast.push({
        closable: !0,
        description: err.message,
        status: "error",
        title: t("timeline.error.unable-to-load-revision")
      });
    }
  }, [t, toast, setTimelineRange, findRangeForRevision, handleClose]), selectSince = useCallback((sinceEvent) => {
    try {
      const [since_0, rev_0] = findRangeForSince(sinceEvent.id);
      setTimelineRange(since_0, rev_0), handleClose();
    } catch (err_0) {
      toast.push({
        closable: !0,
        description: err_0.message,
        status: "error",
        title: t("timeline.error.unable-to-load-revision")
      });
    }
  }, [findRangeForSince, setTimelineRange, toast, t, handleClose]), handleLoadMore = useCallback(() => {
    !loading && nextCursor && loadMoreEvents();
  }, [loading, loadMoreEvents, nextCursor]), content = useMemo(() => eventsError ? /* @__PURE__ */ jsx(TimelineError, {}) : /* @__PURE__ */ jsx(EventsTimeline, { events, fetchEventChildren: expandEvent, hasMoreEvents: !!nextCursor, selectedEventId: event?.id, onLoadMore: handleLoadMore, onSelect: mode === "rev" ? selectRev : selectSince }), [eventsError, mode, expandEvent, events, nextCursor, event?.id, handleLoadMore, selectSince, selectRev]), revLabel = event ? t(TIMELINE_ITEM_I18N_KEY_MAPPING$1[event.documentVariantType][event.type], {
    context: "timestamp",
    timestamp: new Date(event.timestamp),
    formatParams
  }) : t("timeline.latest-revision"), sinceLabel = event ? t(TIMELINE_ITEM_I18N_KEY_MAPPING$1[event.documentVariantType][event.type], {
    context: "timestamp",
    timestamp: new Date(event.timestamp),
    formatParams
  }) : events.length > 0 ? t("timeline.since-version-missing") : t("timeline.no-previous-events"), buttonLabel = mode === "rev" ? revLabel : sinceLabel;
  return /* @__PURE__ */ jsx(PortalProvider, { __unstable_elements: {
    [TIMELINE_MENU_PORTAL]: popoverRef
  }, children: /* @__PURE__ */ jsx(Root, { "data-testid": "timeline-menu", constrainSize: !0, content: open && content, "data-ui": "versionMenu", open, placement, matchReferenceWidth: !0, portal: !0, ref: setPopoverRef, children: /* @__PURE__ */ jsx(Flex, { width: "fill", children: /* @__PURE__ */ jsx(Button, { "data-testid": open ? "timeline-menu-close-button" : "timeline-menu-open-button", disabled: loading || !events.length, mode: "ghost", onClick: open ? handleClose : handleOpen, ref: setButton, selected: open, width: "fill", tooltipProps: null, justify: "space-between", style: {
    maxWidth: "100%"
  }, iconRight: ChevronDownIcon, text: loading ? t("timeline.loading-history") : buttonLabel }) }) }) });
}
const Scroller$2 = styled(ScrollContainer)`
  height: 100%;
  overflow: auto;
  position: relative;
  scroll-behavior: smooth;
`, Grid = styled(Box)`
  &:not([hidden]) {
    display: grid;
  }
  grid-template-columns: 48px 1fr;
  align-items: center;
  gap: 0.25em;
`, SpinnerContainer = styled(Flex)`
  width: 100%;
  position: absolute;
  bottom: -4px;
`, DIFF_INITIAL_VALUE = {
  diff: null,
  loading: !0,
  error: null
}, CompareWithPublishedView = () => {
  const $ = c(35), {
    documentId,
    schemaType,
    editState,
    displayed
  } = useDocumentPane(), {
    selectedPerspective,
    selectedPerspectiveName,
    selectedReleaseId
  } = usePerspective(), {
    t
  } = useTranslation(structureLocaleNamespace);
  let t0, t1;
  $[0] !== editState?.published ? (t1 = editState?.published ?? {}, $[0] = editState?.published, $[1] = t1) : t1 = $[1];
  let t2;
  if ($[2] !== displayed || $[3] !== t1) {
    let t32;
    $[5] !== displayed ? (t32 = displayed ?? {}, $[5] = displayed, $[6] = t32) : t32 = $[6], t2 = diffInput(wrap(t1, {
      author: ""
    }), wrap(t32, {
      author: ""
    })), $[2] = displayed, $[3] = t1, $[4] = t2;
  } else
    t2 = $[4];
  t0 = t2;
  const rootDiff = t0;
  if (selectedReleaseId && !editState?.version || selectedPerspective === "drafts" && !editState?.draft || selectedPerspectiveName === "published" || !displayed?._rev)
    return null;
  let t3;
  $[7] !== t ? (t3 = t("events.compare-with-published.title"), $[7] = t, $[8] = t3) : t3 = $[8];
  let t4;
  $[9] !== t3 ? (t4 = /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t3 }), $[9] = t3, $[10] = t4) : t4 = $[10];
  let t5;
  $[11] !== selectedPerspective ? (t5 = isReleaseDocument(selectedPerspective) ? selectedPerspective.metadata?.title : "draft", $[11] = selectedPerspective, $[12] = t5) : t5 = $[12];
  let t6;
  $[13] !== t5 ? (t6 = {
    version: t5
  }, $[13] = t5, $[14] = t6) : t6 = $[14];
  let t7;
  $[15] !== t || $[16] !== t6 ? (t7 = /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: /* @__PURE__ */ jsx(Translate, { i18nKey: "events.compare-with-published.description", t, values: t6 }) }), $[15] = t, $[16] = t6, $[17] = t7) : t7 = $[17];
  let t8;
  $[18] !== t4 || $[19] !== t7 ? (t8 = /* @__PURE__ */ jsx(Card, { borderBottom: !0, paddingBottom: 3, children: /* @__PURE__ */ jsxs(Stack, { space: 3, paddingTop: 1, children: [
    t4,
    t7
  ] }) }), $[18] = t4, $[19] = t7, $[20] = t8) : t8 = $[20];
  let t9;
  $[21] !== displayed || $[22] !== documentId || $[23] !== rootDiff || $[24] !== schemaType ? (t9 = {
    documentId,
    schemaType,
    rootDiff,
    isComparingCurrent: !0,
    FieldWrapper: _temp,
    value: displayed,
    showFromValue: !0
  }, $[21] = displayed, $[22] = documentId, $[23] = rootDiff, $[24] = schemaType, $[25] = t9) : t9 = $[25];
  let t10;
  $[26] !== rootDiff || $[27] !== schemaType ? (t10 = /* @__PURE__ */ jsx(Box, { paddingY: 1, children: /* @__PURE__ */ jsx(ChangeList, { diff: rootDiff, schemaType }) }), $[26] = rootDiff, $[27] = schemaType, $[28] = t10) : t10 = $[28];
  let t11;
  $[29] !== t10 || $[30] !== t9 ? (t11 = /* @__PURE__ */ jsx(DocumentChangeContext.Provider, { value: t9, children: t10 }), $[29] = t10, $[30] = t9, $[31] = t11) : t11 = $[31];
  let t12;
  return $[32] !== t11 || $[33] !== t8 ? (t12 = /* @__PURE__ */ jsxs(Stack, { space: 2, marginBottom: 3, children: [
    t8,
    t11
  ] }), $[32] = t11, $[33] = t8, $[34] = t12) : t12 = $[34], t12;
};
function EventsInspector({
  showChanges
}) {
  const {
    documentId,
    schemaType,
    timelineError,
    value,
    formState
  } = useDocumentPane(), [scrollRef, setScrollRef] = useState(null), {
    events,
    revision,
    sinceRevision,
    getChangesList
  } = useEvents(), isComparingCurrent = !revision?.revisionId, changesList$ = useMemo(() => getChangesList(), [getChangesList]), {
    diff,
    loading: diffLoading,
    error: diffError
  } = useObservable(changesList$, DIFF_INITIAL_VALUE), {
    t
  } = useTranslation("studio"), documentContext = useMemo(() => ({
    documentId,
    schemaType,
    FieldWrapper: (props) => props.path.length > 0 ? /* @__PURE__ */ jsx(ChangeFieldWrapper, { ...props }) : props.children,
    rootDiff: diff,
    isComparingCurrent: isComparingCurrent && !formState?.readOnly,
    value,
    showFromValue: !0
  }), [diff, documentId, isComparingCurrent, formState?.readOnly, schemaType, value]), [sinceEvent, toEvent] = useMemo(() => events ? [events.find((e) => e.id === sinceRevision?.revisionId) || null, events.find((e_0) => e_0.id === revision?.revisionId) || events[0]] : [null, null], [events, revision?.revisionId, sinceRevision?.revisionId]), sinceEvents = useMemo(() => toEvent ? events.slice(events.indexOf(toEvent) + 1).map((event) => "parentId" in toEvent && "parentId" in event && event.parentId === toEvent.parentId || "parentId" in event && toEvent.id === event.parentId ? {
    ...event,
    parentId: void 0
  } : event) : events.slice(1), [events, toEvent]);
  return events.length ? /* @__PURE__ */ jsxs(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", overflow: "hidden", children: [
    /* @__PURE__ */ jsxs(Box, { padding: 3, style: {
      position: "relative"
    }, children: [
      /* @__PURE__ */ jsxs(Grid, { paddingX: 2, paddingBottom: 2, children: [
        /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: t("changes.inspector.from-label") }),
        /* @__PURE__ */ jsx(EventsTimelineMenu, { event: sinceEvent || null, events: sinceEvents, mode: "since", placement: "bottom-start" }),
        /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: t("changes.inspector.to-label") }),
        /* @__PURE__ */ jsx(EventsTimelineMenu, { event: toEvent || null, events, mode: "rev", placement: "bottom-end" })
      ] }),
      diffLoading && /* @__PURE__ */ jsx(motion.div, { animate: {
        opacity: 1
      }, initial: {
        opacity: 0
      }, transition: {
        delay: 0.2,
        duration: 0.2
      }, children: /* @__PURE__ */ jsxs(SpinnerContainer, { justify: "center", align: "center", gap: 2, children: [
        /* @__PURE__ */ jsx(Text, { muted: !0, size: 0, children: t("changes.loading-changes") }),
        /* @__PURE__ */ jsx(Spinner, { size: 0 })
      ] }) })
    ] }),
    /* @__PURE__ */ jsx(Card, { flex: 1, paddingX: 2, paddingY: 2, children: /* @__PURE__ */ jsx(BoundaryElementProvider, { element: scrollRef, children: /* @__PURE__ */ jsx(Scroller$2, { "data-ui": "Scroller", ref: setScrollRef, children: /* @__PURE__ */ jsx(Box, { flex: 1, paddingX: 3, height: "fill", children: showChanges && /* @__PURE__ */ jsx(Content, { documentContext, error: timelineError || diffError, loading: revision?.loading || sinceRevision?.loading || !1, schemaType, sameRevisionSelected: sinceEvent?.id === toEvent?.id, sinceEvent }) }) }) }) })
  ] }) : /* @__PURE__ */ jsx(Box, { paddingX: 2, children: /* @__PURE__ */ jsxs(Stack, { padding: 3, space: 3, children: [
    /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t("timeline.error.no-document-history-title") }),
    /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("timeline.error.no-document-history-description") })
  ] }) });
}
function Content(t0) {
  const $ = c(15), {
    error,
    documentContext,
    loading,
    schemaType,
    sameRevisionSelected,
    sinceEvent
  } = t0;
  if (error) {
    let t12;
    $[0] === Symbol.for("react.memo_cache_sentinel") ? (t12 = /* @__PURE__ */ jsx(CompareWithPublishedView, {}), $[0] = t12) : t12 = $[0];
    let t22;
    $[1] !== error || $[2] !== sinceEvent?.type ? (t22 = sinceEvent?.type !== "historyCleared" && /* @__PURE__ */ jsx(ChangesError, { error }), $[1] = error, $[2] = sinceEvent?.type, $[3] = t22) : t22 = $[3];
    let t3;
    return $[4] !== t22 ? (t3 = /* @__PURE__ */ jsxs(Fragment, { children: [
      t12,
      t22
    ] }), $[4] = t22, $[5] = t3) : t3 = $[5], t3;
  }
  if (loading) {
    let t12;
    return $[6] === Symbol.for("react.memo_cache_sentinel") ? (t12 = /* @__PURE__ */ jsx(LoadingBlock, { showText: !0 }), $[6] = t12) : t12 = $[6], t12;
  }
  if (sameRevisionSelected) {
    let t12;
    return $[7] === Symbol.for("react.memo_cache_sentinel") ? (t12 = /* @__PURE__ */ jsx(SameRevisionSelected, {}), $[7] = t12) : t12 = $[7], t12;
  }
  if (!documentContext.rootDiff) {
    let t12;
    return $[8] === Symbol.for("react.memo_cache_sentinel") ? (t12 = /* @__PURE__ */ jsx(motion.div, { animate: {
      opacity: 1
    }, initial: {
      opacity: 0
    }, transition: {
      delay: 0.2,
      duration: 0.2
    }, children: /* @__PURE__ */ jsx(NoChanges, {}) }), $[8] = t12) : t12 = $[8], t12;
  }
  let t1;
  $[9] !== documentContext.rootDiff || $[10] !== schemaType ? (t1 = /* @__PURE__ */ jsx(Box, { paddingY: 1, children: /* @__PURE__ */ jsx(ChangeList, { diff: documentContext.rootDiff, schemaType }) }), $[9] = documentContext.rootDiff, $[10] = schemaType, $[11] = t1) : t1 = $[11];
  let t2;
  return $[12] !== documentContext || $[13] !== t1 ? (t2 = /* @__PURE__ */ jsx(DocumentChangeContext.Provider, { value: documentContext, children: t1 }), $[12] = documentContext, $[13] = t1, $[14] = t2) : t2 = $[14], t2;
}
function SameRevisionSelected() {
  const $ = c(12), {
    t
  } = useTranslation("");
  let t0, t1, t2;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    opacity: 1
  }, t1 = {
    opacity: 0
  }, t2 = {
    delay: 0.2,
    duration: 0.2
  }, $[0] = t0, $[1] = t1, $[2] = t2) : (t0 = $[0], t1 = $[1], t2 = $[2]);
  let t3;
  $[3] !== t ? (t3 = t("changes.same-revision-selected-title"), $[3] = t, $[4] = t3) : t3 = $[4];
  let t4;
  $[5] !== t3 ? (t4 = /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", as: "h3", children: t3 }), $[5] = t3, $[6] = t4) : t4 = $[6];
  let t5;
  $[7] !== t ? (t5 = /* @__PURE__ */ jsx(Text, { as: "p", size: 1, muted: !0, children: /* @__PURE__ */ jsx(Translate, { i18nKey: "changes.same-revision-selected-description", t }) }), $[7] = t, $[8] = t5) : t5 = $[8];
  let t6;
  return $[9] !== t4 || $[10] !== t5 ? (t6 = /* @__PURE__ */ jsx(motion.div, { animate: t0, initial: t1, transition: t2, children: /* @__PURE__ */ jsxs(Stack, { space: 3, paddingTop: 2, children: [
    t4,
    t5
  ] }) }), $[9] = t4, $[10] = t5, $[11] = t6) : t6 = $[11], t6;
}
function _temp(props) {
  return props.children;
}
const Scroller$1 = styled(ScrollContainer)`
  height: 100%;
  overflow: auto;
  position: relative;
  scroll-behavior: smooth;
`;
function EventsSelector({
  showList
}) {
  const [scrollRef, setScrollRef] = useState(null), [listHeight, setListHeight] = useState(0), {
    setTimelineRange
  } = useDocumentPane(), getScrollerRef = useCallback((el) => {
    !listHeight && el && (setListHeight(el.clientHeight ? el.clientHeight - 1 : 0), setScrollRef(el));
  }, [listHeight]), {
    events,
    nextCursor,
    loading,
    error,
    revision,
    loadMoreEvents,
    findRangeForRevision,
    expandEvent
  } = useEvents(), {
    t
  } = useTranslation("studio"), toast = useToast(), selectRev = useCallback((event) => {
    try {
      if (isDeleteDocumentVersionEvent(event) || isDeleteDocumentGroupEvent(event) || isUnpublishDocumentEvent(event) || isScheduleDocumentVersionEvent(event) || isUnscheduleDocumentVersionEvent(event)) {
        console.error("Event is not selectable");
        return;
      }
      const [since, rev] = findRangeForRevision(event.id);
      setTimelineRange(since, rev);
    } catch (err) {
      toast.push({
        closable: !0,
        description: err.message,
        status: "error",
        title: t("timeline.error.unable-to-load-revision")
      });
    }
  }, [t, toast, setTimelineRange, findRangeForRevision]), initialLoad = loading && !events.length;
  return /* @__PURE__ */ jsx(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", children: /* @__PURE__ */ jsx(Card, { flex: 1, padding: 2, paddingTop: 0, children: error ? /* @__PURE__ */ jsx(TimelineError, {}) : /* @__PURE__ */ jsx(BoundaryElementProvider, { element: scrollRef, children: /* @__PURE__ */ jsxs(Scroller$1, { "data-ui": "Scroller", ref: getScrollerRef, children: [
    listHeight && // This forces the list to unmount and remount, which is needed to reset the scroll position
    showList && !initialLoad ? /* @__PURE__ */ jsx(
      EventsTimeline,
      {
        events,
        fetchEventChildren: expandEvent,
        hasMoreEvents: !!nextCursor,
        selectedEventId: revision?.revisionId || events[0]?.id,
        onLoadMore: loadMoreEvents,
        onSelect: selectRev,
        listMaxHeight: `${listHeight}px`
      }
    ) : null,
    loading && /* @__PURE__ */ jsx(LoadingBlock, {})
  ] }) }) }) });
}
const Scroller = styled(ScrollContainer)`
  height: 100%;
  overflow: auto;
  position: relative;
  scroll-behavior: smooth;
`;
function HistorySelector({
  showList
}) {
  const {
    timelineError,
    setTimelineRange,
    timelineStore
  } = useDocumentPane(), {
    selectedReleaseId
  } = usePerspective(), [scrollRef, setScrollRef] = useState(null), [listHeight, setListHeight] = useState(0), getScrollerRef = useCallback((el) => {
    el?.clientHeight && (setListHeight(el.clientHeight - 1), setScrollRef(el));
  }, []), chunks = useTimelineSelector(timelineStore, (state2) => state2.chunks), realRevChunk = useTimelineSelector(timelineStore, (state_0) => state_0.realRevChunk), hasMoreChunks = useTimelineSelector(timelineStore, (state_1) => state_1.hasMoreChunks), loading = useTimelineSelector(timelineStore, (state_2) => state_2.isLoading), {
    t
  } = useTranslation("studio"), toast = useToast(), selectRev = useCallback((revChunk) => {
    try {
      const [sinceId, revId] = timelineStore?.findRangeForRev(revChunk) || [null, null];
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({
        closable: !0,
        description: err.message,
        status: "error",
        title: t("timeline.error.unable-to-load-revision")
      });
    }
  }, [setTimelineRange, t, timelineStore, toast]), handleLoadMore = useCallback(() => {
    loading || timelineStore?.loadMore();
  }, [loading, timelineStore]);
  return /* @__PURE__ */ jsx(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", children: /* @__PURE__ */ jsx(Card, { flex: 1, padding: 2, paddingTop: 0, children: timelineError || selectedReleaseId ? /* @__PURE__ */ jsx(TimelineError, { versionError: !!selectedReleaseId }) : /* @__PURE__ */ jsx(BoundaryElementProvider, { element: scrollRef, children: /* @__PURE__ */ jsx(Scroller, { "data-ui": "Scroller", ref: getScrollerRef, children: listHeight && // This forces the list to unmount and remount, which is needed to reset the scroll position
  showList ? /* @__PURE__ */ jsx(Timeline, { chunks, hasMoreChunks, lastChunk: realRevChunk, onLoadMore: handleLoadMore, onSelect: selectRev, listMaxHeight: `${listHeight}px` }) : null }) }) }) });
}
const FadeInFlex = styled(Flex)`
  opacity: 0;
  transition: opacity 200ms;
  &[data-ready] {
    opacity: 1;
  }
`, TABS = ["history", "review"], isValidTab = (tab) => (
  // @ts-expect-error TS doesn't understand the type guard
  tab && TABS.includes(tab)
);
function ChangesTabs(props) {
  const $ = c(72), {
    params,
    setParams
  } = usePaneRouter(), source = useSource(), [parentRef, setParentRef] = useState(null), {
    t
  } = useTranslation(structureLocaleNamespace), isReady = params?.inspect === HISTORY_INSPECTOR_NAME, {
    selectedPerspective
  } = usePerspective();
  let t0;
  $[0] !== params ? (t0 = isValidTab(params?.changesInspectorTab) ? params.changesInspectorTab : TABS[0], $[0] = params, $[1] = t0) : t0 = $[1];
  const paneRouterTab = t0;
  let t1;
  $[2] !== params || $[3] !== setParams ? (t1 = (tab) => setParams({
    ...params,
    changesInspectorTab: tab,
    since: tab === "history" ? void 0 : params?.since
  }), $[2] = params, $[3] = setParams, $[4] = t1) : t1 = $[4];
  const setPaneRouterTab = t1;
  let t2;
  $[5] !== selectedPerspective || $[6] !== t ? (t2 = isReleaseDocument(selectedPerspective) ? selectedPerspective.metadata.title : t(selectedPerspective === "drafts" ? "compare-versions.status.draft" : "compare-versions.status.published"), $[5] = selectedPerspective, $[6] = t, $[7] = t2) : t2 = $[7];
  const perspectiveName2 = t2, t3 = isReady ? "" : void 0;
  let t4;
  $[8] !== t ? (t4 = t("changes.tab.history"), $[8] = t, $[9] = t4) : t4 = $[9];
  let t5;
  $[10] !== setPaneRouterTab ? (t5 = () => setPaneRouterTab("history"), $[10] = setPaneRouterTab, $[11] = t5) : t5 = $[11];
  const t6 = paneRouterTab === "history";
  let t7;
  $[12] !== t4 || $[13] !== t5 || $[14] !== t6 ? (t7 = /* @__PURE__ */ jsx(Tab, { "aria-controls": "history-panel", id: "history-tab", label: t4, onClick: t5, selected: t6 }), $[12] = t4, $[13] = t5, $[14] = t6, $[15] = t7) : t7 = $[15];
  let t8;
  $[16] !== t ? (t8 = t("changes.tab.review-changes"), $[16] = t, $[17] = t8) : t8 = $[17];
  let t9;
  $[18] !== setPaneRouterTab ? (t9 = () => setPaneRouterTab("review"), $[18] = setPaneRouterTab, $[19] = t9) : t9 = $[19];
  const t10 = paneRouterTab === "review";
  let t11;
  $[20] !== t10 || $[21] !== t8 || $[22] !== t9 ? (t11 = /* @__PURE__ */ jsx(Tab, { "aria-controls": "review-changes-panel", id: "changes-tab", label: t8, onClick: t9, selected: t10 }), $[20] = t10, $[21] = t8, $[22] = t9, $[23] = t11) : t11 = $[23];
  let t12;
  $[24] !== t11 || $[25] !== t7 ? (t12 = /* @__PURE__ */ jsxs(TabList, { space: 1, flex: 1, children: [
    t7,
    t11
  ] }), $[24] = t11, $[25] = t7, $[26] = t12) : t12 = $[26];
  let t13;
  $[27] !== t ? (t13 = t("changes.action.close-label"), $[27] = t, $[28] = t13) : t13 = $[28];
  const t14 = props.onClose;
  let t15;
  $[29] !== t ? (t15 = t("document-inspector.close-button.tooltip"), $[29] = t, $[30] = t15) : t15 = $[30];
  let t16;
  $[31] !== t15 ? (t16 = {
    content: t15
  }, $[31] = t15, $[32] = t16) : t16 = $[32];
  let t17;
  $[33] !== props.onClose || $[34] !== t13 || $[35] !== t16 ? (t17 = /* @__PURE__ */ jsx(Button, { "aria-label": t13, icon: CloseIcon, mode: "bleed", onClick: t14, tooltipProps: t16 }), $[33] = props.onClose, $[34] = t13, $[35] = t16, $[36] = t17) : t17 = $[36];
  let t18;
  $[37] !== t12 || $[38] !== t17 ? (t18 = /* @__PURE__ */ jsx(Card, { paddingBottom: 1, children: /* @__PURE__ */ jsxs(Flex, { align: "center", padding: 3, gap: 2, children: [
    t12,
    t17
  ] }) }), $[37] = t12, $[38] = t17, $[39] = t18) : t18 = $[39];
  let t19;
  $[40] !== t ? (t19 = /* @__PURE__ */ jsx(Box, { flex: 1, padding: 1, children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Translate, { t, i18nKey: "changes.banner.tooltip" }) }) }), $[40] = t, $[41] = t19) : t19 = $[41];
  let t20;
  $[42] === Symbol.for("react.memo_cache_sentinel") ? (t20 = /* @__PURE__ */ jsx(Text, { size: 0, muted: !0, children: /* @__PURE__ */ jsx(InfoOutlineIcon, { fontSize: 1 }) }), $[42] = t20) : t20 = $[42];
  let t21;
  $[43] !== parentRef || $[44] !== t19 ? (t21 = /* @__PURE__ */ jsx(Tooltip, { portal: !0, placement: "bottom-end", boundaryElement: parentRef, content: t19, children: t20 }), $[43] = parentRef, $[44] = t19, $[45] = t21) : t21 = $[45];
  let t22;
  $[46] !== perspectiveName2 ? (t22 = {
    perspective: perspectiveName2
  }, $[46] = perspectiveName2, $[47] = t22) : t22 = $[47];
  let t23;
  $[48] !== t || $[49] !== t22 ? (t23 = /* @__PURE__ */ jsx(Text, { size: 0, muted: !0, children: /* @__PURE__ */ jsx(Translate, { t, values: t22, i18nKey: "changes.banner.description" }) }), $[48] = t, $[49] = t22, $[50] = t23) : t23 = $[50];
  let t24;
  $[51] !== t21 || $[52] !== t23 ? (t24 = /* @__PURE__ */ jsx(Card, { padding: 2, marginBottom: 3, marginX: 3, tone: "neutral", border: !0, radius: 3, children: /* @__PURE__ */ jsxs(Flex, { gap: 2, align: "flex-start", children: [
    t21,
    t23
  ] }) }), $[51] = t21, $[52] = t23, $[53] = t24) : t24 = $[53];
  const t25 = paneRouterTab !== "history";
  let t26;
  $[54] !== paneRouterTab || $[55] !== source.beta?.eventsAPI?.documents ? (t26 = source.beta?.eventsAPI?.documents ? /* @__PURE__ */ jsx(EventsSelector, { showList: paneRouterTab === "history" }) : /* @__PURE__ */ jsx(HistorySelector, { showList: paneRouterTab === "history" }), $[54] = paneRouterTab, $[55] = source.beta?.eventsAPI?.documents, $[56] = t26) : t26 = $[56];
  let t27;
  $[57] !== t25 || $[58] !== t26 ? (t27 = /* @__PURE__ */ jsx(TabPanel, { "aria-labelledby": "history-tab", height: "fill", hidden: t25, id: "history-panel", children: t26 }), $[57] = t25, $[58] = t26, $[59] = t27) : t27 = $[59];
  const t28 = paneRouterTab !== "review";
  let t29;
  $[60] !== paneRouterTab || $[61] !== source.beta?.eventsAPI?.documents ? (t29 = source.beta?.eventsAPI?.documents ? /* @__PURE__ */ jsx(Fragment, { children: paneRouterTab === "review" ? /* @__PURE__ */ jsx(EventsInspector, { showChanges: paneRouterTab === "review" }) : null }) : /* @__PURE__ */ jsx(ChangesInspector, { showChanges: paneRouterTab === "review" }), $[60] = paneRouterTab, $[61] = source.beta?.eventsAPI?.documents, $[62] = t29) : t29 = $[62];
  let t30;
  $[63] !== t28 || $[64] !== t29 ? (t30 = /* @__PURE__ */ jsx(TabPanel, { "aria-labelledby": "review-tab", hidden: t28, id: "review-panel", height: "fill", children: t29 }), $[63] = t28, $[64] = t29, $[65] = t30) : t30 = $[65];
  let t31;
  return $[66] !== t18 || $[67] !== t24 || $[68] !== t27 || $[69] !== t3 || $[70] !== t30 ? (t31 = /* @__PURE__ */ jsxs(FadeInFlex, { direction: "column", padding: 0, height: "fill", "data-ready": t3, ref: setParentRef, children: [
    t18,
    t24,
    t27,
    t30
  ] }), $[66] = t18, $[67] = t24, $[68] = t27, $[69] = t3, $[70] = t30, $[71] = t31) : t31 = $[71], t31;
}
const changesInspector = {
  name: HISTORY_INSPECTOR_NAME,
  useMenuItem: () => {
    const {
      features
    } = useStructureTool(), {
      t
    } = useTranslation();
    return {
      hidden: !features.reviewChanges,
      icon: RestoreIcon,
      title: t("changes.title")
    };
  },
  component: ChangesTabs,
  onClose: ({
    params
  }) => ({
    params: {
      ...params,
      since: void 0,
      rev: void 0,
      changesInspectorTab: void 0,
      historyVersion: void 0
    }
  }),
  onOpen: ({
    params
  }) => ({
    params: {
      ...params,
      since: "@lastPublished"
    }
  })
};
function getPathTitles(options) {
  const {
    path,
    schemaType,
    value
  } = options, result = [];
  let s = schemaType, v = value;
  for (const segment of path) {
    if (typeof segment == "string") {
      if (!isRecord(v) && v !== void 0)
        throw new Error(`Parent value is not an object, cannot get path segment: .${segment}`);
      if (s.jsonType !== "object")
        throw new Error(`Parent type is not an object schema type, cannot get path segment: .${segment}`);
      v = v?.[segment];
      const field = s.fields.find((f) => f.name === segment);
      if (!field)
        return result.push({
          name: segment
        }), result;
      s = field.type, result.push(s);
      continue;
    }
    if (typeof segment == "number") {
      if (!isArray(v) && v !== void 0)
        throw new Error(`Parent value is not an array, cannot get path segment: [${segment}]`);
      if (s.jsonType !== "array")
        throw new Error(`Parent type is not an array schema type, cannot get path segment: [${segment}]`);
      v = v?.[segment];
      const itemType = s.of.find((ofType) => typeof v == "string" ? ofType.jsonType === "string" : typeof v == "number" ? ofType.jsonType === "number" : typeof v == "boolean" ? ofType.jsonType === "boolean" : isRecord(v) ? ofType.name === v?._type : !1);
      if (!itemType)
        throw new Error(`Item type not found: [${segment}]`);
      s = itemType, result.push(s);
      continue;
    }
    if (isRecord(segment) && segment._key) {
      if (!isArray(v))
        throw new Error(`Parent value is not an array, cannot get path segment: [_key == ${segment}]`);
      if (s.jsonType !== "array")
        throw new Error(`Parent type is not an array schema type, cannot get path segment: .${segment}`);
      if (v = (v ?? []).find((i) => isRecord(i) && i._key === segment._key), !isRecord(v))
        throw new Error(`Array item not found: [_key == ${segment._key}]`);
      const ofType = s.of.find((i) => isRecord(v) && i.name === v?._type);
      if (!ofType)
        throw new Error(`Array item type not found: .${v?._type}`);
      s = ofType, result.push(s);
      continue;
    }
    throw new Error(`Invalid path segment: ${JSON.stringify(segment)}`);
  }
  return result;
}
const MARKER_ICON = {
  error: ErrorOutlineIcon,
  warning: WarningOutlineIcon,
  info: InfoOutlineIcon
}, MARKER_TONE = {
  error: "critical",
  warning: "caution",
  info: "primary"
};
function ValidationInspector(props) {
  const $ = c(23), {
    onClose
  } = props, {
    onFocus,
    onPathOpen,
    schemaType,
    validation,
    value,
    editState
  } = useDocumentPane(), {
    t
  } = useTranslation("validation");
  let t0;
  $[0] !== onFocus || $[1] !== onPathOpen ? (t0 = (path) => {
    onPathOpen(path), onFocus(path);
  }, $[0] = onFocus, $[1] = onPathOpen, $[2] = t0) : t0 = $[2];
  const handleOpen = t0;
  let t1;
  $[3] !== editState ? (t1 = editState && editState.version && isGoingToUnpublish(editState.version), $[3] = editState, $[4] = t1) : t1 = $[4];
  const isVersionGoingToUnpublish = t1;
  let t2;
  $[5] !== t ? (t2 = t("panel.close-button-aria-label"), $[5] = t, $[6] = t2) : t2 = $[6];
  let t3;
  $[7] !== t ? (t3 = t("panel.title"), $[7] = t, $[8] = t3) : t3 = $[8];
  let t4;
  $[9] !== onClose || $[10] !== t2 || $[11] !== t3 ? (t4 = /* @__PURE__ */ jsx(DocumentInspectorHeader, { as: "header", closeButtonLabel: t2, flex: "none", onClose, title: t3 }), $[9] = onClose, $[10] = t2, $[11] = t3, $[12] = t4) : t4 = $[12];
  let t5;
  $[13] !== handleOpen || $[14] !== isVersionGoingToUnpublish || $[15] !== schemaType || $[16] !== t || $[17] !== validation || $[18] !== value ? (t5 = /* @__PURE__ */ jsx(Card, { flex: 1, overflow: "auto", padding: 3, children: isVersionGoingToUnpublish ? /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("panel.unpublish-message") }) }) : /* @__PURE__ */ jsxs(Fragment, { children: [
    validation.length === 0 && /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("panel.no-errors-message") }) }),
    validation.length > 0 && /* @__PURE__ */ jsx(Stack, { space: 2, children: validation.map((marker, i) => /* @__PURE__ */ jsx(ValidationCard, { marker, onOpen: handleOpen, schemaType, value }, i)) })
  ] }) }), $[13] = handleOpen, $[14] = isVersionGoingToUnpublish, $[15] = schemaType, $[16] = t, $[17] = validation, $[18] = value, $[19] = t5) : t5 = $[19];
  let t6;
  return $[20] !== t4 || $[21] !== t5 ? (t6 = /* @__PURE__ */ jsxs(Flex, { direction: "column", height: "fill", overflow: "hidden", children: [
    t4,
    t5
  ] }), $[20] = t4, $[21] = t5, $[22] = t6) : t6 = $[22], t6;
}
function ValidationCard(props) {
  const $ = c(17), {
    marker,
    onOpen,
    schemaType,
    value
  } = props;
  let t0;
  $[0] !== marker.path || $[1] !== onOpen ? (t0 = () => onOpen(marker.path), $[0] = marker.path, $[1] = onOpen, $[2] = t0) : t0 = $[2];
  const handleOpen = t0, [errorInfo, setErrorInfo] = useState(null), Icon = MARKER_ICON[marker.level];
  let t1;
  $[3] !== errorInfo ? (t1 = errorInfo && /* @__PURE__ */ jsx(Card, { padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsx(Text, { size: 1, children: errorInfo.error.message }) }), $[3] = errorInfo, $[4] = t1) : t1 = $[4];
  let t2;
  $[5] !== Icon || $[6] !== errorInfo || $[7] !== handleOpen || $[8] !== marker.level || $[9] !== marker.message || $[10] !== marker.path || $[11] !== schemaType || $[12] !== value ? (t2 = !errorInfo && /* @__PURE__ */ jsx(Card, { __unstable_focusRing: !0, as: "button", onClick: handleOpen, padding: 3, radius: 2, tone: MARKER_TONE[marker.level], children: /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 3, children: [
    /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(Icon, {}) }) }),
    /* @__PURE__ */ jsxs(Stack, { flex: 1, space: 2, children: [
      /* @__PURE__ */ jsx(DocumentNodePathBreadcrumbs, { path: marker.path, schemaType, value }),
      /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: marker.message })
    ] })
  ] }) }), $[5] = Icon, $[6] = errorInfo, $[7] = handleOpen, $[8] = marker.level, $[9] = marker.message, $[10] = marker.path, $[11] = schemaType, $[12] = value, $[13] = t2) : t2 = $[13];
  let t3;
  return $[14] !== t1 || $[15] !== t2 ? (t3 = /* @__PURE__ */ jsxs(ErrorBoundary, { onCatch: setErrorInfo, children: [
    t1,
    t2
  ] }), $[14] = t1, $[15] = t2, $[16] = t3) : t3 = $[16], t3;
}
function DocumentNodePathBreadcrumbs(props) {
  const {
    path,
    schemaType,
    value
  } = props, pathTitles = useMemo(() => {
    try {
      return getPathTitles({
        path,
        schemaType,
        value
      });
    } catch (e) {
      console.error(e);
    }
    return null;
  }, [path, schemaType, value]);
  return pathTitles?.length ? /* @__PURE__ */ jsx(Text, { size: 1, children: pathTitles.map((t, i) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
    i > 0 && /* @__PURE__ */ jsx("span", { style: {
      color: "var(--card-muted-fg-color)",
      opacity: 0.5
    }, children: " / " }),
    /* @__PURE__ */ jsx("span", { style: {
      fontWeight: 500
    }, children: t.title || t.name })
  ] }, i)) }) : null;
}
function useMenuItem(props) {
  const {
    documentId,
    documentType
  } = props, {
    t
  } = useTranslation("validation"), {
    selectedReleaseId
  } = usePerspective(), {
    validation: validationMarkers
  } = useValidationStatus(documentId, documentType, selectedReleaseId), {
    value
  } = useDocumentPane(), validation = useMemo(() => validationMarkers.map((item) => ({
    level: item.level,
    message: item.message,
    path: item.path
  })), [validationMarkers]), hasErrors = validation.some(isValidationError), hasWarnings = validation.some(isValidationWarning), isDocumentGoingToUnpublish = isGoingToUnpublish(value), icon = useMemo(() => hasErrors ? ErrorOutlineIcon : hasWarnings ? WarningOutlineIcon : CheckmarkCircleIcon, [hasErrors, hasWarnings]), tone = useMemo(() => hasErrors ? "critical" : hasWarnings ? "caution" : "positive", [hasErrors, hasWarnings]);
  return {
    hidden: validation.length === 0 || isDocumentGoingToUnpublish,
    icon,
    title: t("panel.title"),
    tone,
    showAsAction: !0
  };
}
const validationInspector = {
  name: VALIDATION_INSPECTOR_NAME,
  component: ValidationInspector,
  useMenuItem
}, EMPTY_PARAMS = {};
function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch {
    return console.warn("Failed to parse JSON parameters"), {};
  }
}
function encodePanesSegment(panes) {
  return (panes || []).map((group) => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}
function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}
function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
function toPath(panes) {
  return encodePanesSegment(panes);
}
const router = route.create("/", [
  // "Asynchronous intent resolving" route
  route.intents("/intent"),
  // Legacy fallback route, will be redirected to new format
  route.create("/edit/:type/:editDocumentId", [route.create({
    path: "/:params",
    transform: {
      params: {
        toState: legacyEditParamsToState,
        toPath: legacyEditParamsToPath
      }
    }
  })]),
  // The regular path - when the intent can be resolved to a specific pane
  route.create({
    path: "/:panes",
    // Legacy URLs, used to handle redirects
    children: [route.create("/:action", route.create("/:legacyEditDocumentId"))],
    transform: {
      panes: {
        toState,
        toPath
      }
    }
  })
]), panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i, isParam = (str) => /^[a-z0-9]+=[^=]+/i.test(str), isPayloadLike = (str) => /^[A-Za-z0-9\-_]+(?:={0,2})$/.test(str), exclusiveParams = ["view", "since", "rev", "inspect", "comment"], isTruthy = Boolean;
function parseChunks(chunks, initial) {
  const sibling = {
    ...initial,
    params: EMPTY_PARAMS,
    payload: void 0
  };
  return chunks.reduce((pane2, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("=")), value = chunk.slice(key.length + 1);
      pane2.params = {
        ...pane2.params,
        [decodeURIComponent(key)]: decodeURIComponent(value)
      };
    } else isPayloadLike(chunk) ? pane2.payload = tryParseBase64Payload(chunk) : console.warn("Unknown pane segment: %s - skipping", chunk);
    return pane2;
  }, sibling);
}
function encodeChunks(pane2, index, group) {
  const {
    payload,
    params = {},
    id
  } = pane2, [firstSibling] = group, paneIsFirstSibling = pane2 === firstSibling, sameAsFirst = index !== 0 && id === firstSibling.id, encodedPayload = typeof payload > "u" ? void 0 : encodeJsonParams(payload), encodedParams = Object.entries(params).filter((entry) => {
    const [key, value] = entry;
    if (!value) return !1;
    if (paneIsFirstSibling) return !0;
    const valueFromFirstSibling = firstSibling.params?.[key];
    return !(value === valueFromFirstSibling && !exclusiveParams.includes(key));
  }).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}
function parsePanesSegment(str) {
  return str.indexOf(",{") !== -1 ? parseOldPanesSegment(str) : str.split(";").map((group) => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map((segment) => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, {
        id
      });
    });
    return [firstSibling, ...restOfSiblings.map((sibling) => ({
      ...firstSibling,
      ...sibling,
      id: sibling.id || firstSibling.id,
      params: {
        ...omit(firstSibling.params, exclusiveParams),
        ...sibling.params
      },
      payload: sibling.payload || firstSibling.payload
    }))];
  }).filter((group) => group.length > 0);
}
function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;
  for (; buffer.length; ) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];
    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }
    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({
      id,
      payload
    }), buffer = buffer.slice(match.length);
  }
  return [chunks];
}
function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
function tryParseBase64Payload(data) {
  try {
    return data ? decodeJsonParams(data) : void 0;
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
const documentActions = [PublishAction, UnpublishAction, DiscardChangesAction, DuplicateAction, DeleteAction, HistoryRestoreAction], documentBadges = [LiveEditBadge], inspectors = [validationInspector, changesInspector], structureTool = definePlugin((options) => {
  const icon = options?.icon || MasterDetailIcon;
  return {
    name: "sanity/structure",
    document: {
      actions: (prevActions) => Array.from(/* @__PURE__ */ new Set([...prevActions, ...documentActions])),
      badges: (prevBadges) => Array.from(/* @__PURE__ */ new Set([...prevBadges, ...documentBadges])),
      inspectors: (prevInspectors) => Array.from(/* @__PURE__ */ new Set([...prevInspectors, ...inspectors]))
    },
    tools: [{
      name: options?.name || "structure",
      title: options?.title || "Structure",
      icon,
      component: lazy(() => import("./index3.mjs")),
      canHandleIntent: (intent, params) => intent === "create" ? canHandleCreateIntent(params) : intent === "edit" ? canHandleEditIntent(params) : !1,
      getIntentState,
      // Controlled by sanity/src/structure/components/structureTool/StructureTitle.tsx
      controlsDocumentTitle: !0,
      options,
      router,
      __internalApplicationType: "sanity/structure"
    }],
    i18n: {
      bundles: [structureUsEnglishLocaleBundle]
    }
  };
});
function canHandleCreateIntent(params) {
  return "type" in params ? "template" in params ? {
    template: !0
  } : !0 : !1;
}
function canHandleEditIntent(params) {
  return "id" in params ? "mode" in params ? {
    mode: params.mode === "structure"
  } : !0 : !1;
}
var pane$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: DocumentPane
}), pane = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: PaneContainer
});
export {
  BackLink,
  ChildLink,
  ConfirmDeleteDialogContainer,
  DocumentInspectorHeader,
  DocumentPane,
  DocumentPaneProviderWrapper,
  LOADING_PANE,
  LoadingPane,
  Pane,
  PaneContainer,
  PaneContent,
  PaneHeader$1 as PaneHeader,
  PaneHeaderActions,
  PaneItem,
  PaneLayout,
  ParameterizedLink,
  ReferenceChildLink,
  _DEBUG,
  pane$1 as pane,
  pane as pane$1,
  setActivePanes,
  structureTool,
  useDocumentPane,
  useDocumentTitle,
  usePane,
  usePaneLayout,
  usePaneOptions,
  usePaneRouter,
  useStructureTool
};
//# sourceMappingURL=pane.mjs.map
