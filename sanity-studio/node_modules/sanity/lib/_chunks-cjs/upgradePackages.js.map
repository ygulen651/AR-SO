{"version":3,"file":"upgradePackages.js","sources":["../../src/_internal/cli/util/checkStudioDependencyVersions.ts","../../src/_internal/cli/util/checkRequiredDependencies.ts","../../src/_internal/cli/util/packageManager/packageManagerChoice.ts","../../src/_internal/cli/util/packageManager/upgradePackages.ts"],"sourcesContent":["import path from 'node:path'\n\nimport {generateHelpUrl} from '@sanity/generate-help-url'\nimport resolveFrom from 'resolve-from'\nimport semver, {type SemVer} from 'semver'\n\nimport {readPackageJson, readPackageManifest} from './readPackageManifest'\n\ninterface PackageInfo {\n  name: string\n  supported: string[]\n  deprecatedBelow: null | string\n  installed: SemVer\n  isUnsupported: boolean\n  isDeprecated: boolean\n  isUntested: boolean\n}\n\n// NOTE: when doing changes here, also remember to update versions in help docs at\n// https://sanity.io/admin/structure/docs;helpArticle;upgrade-packages\nconst PACKAGES = [\n  {name: 'react', supported: ['^18 || ^19'], deprecatedBelow: null},\n  {name: 'react-dom', supported: ['^18 || ^19'], deprecatedBelow: null},\n  {name: 'styled-components', supported: ['^6'], deprecatedBelow: null},\n  {name: '@sanity/ui', supported: ['^2'], deprecatedBelow: null},\n]\n\nexport async function checkStudioDependencyVersions(workDir: string): Promise<void> {\n  const manifest = await readPackageJson(path.join(workDir, 'package.json'))\n  const dependencies = {...manifest.dependencies, ...manifest.devDependencies}\n\n  const packageInfo = PACKAGES.map(async (pkg): Promise<PackageInfo | false> => {\n    const dependency = dependencies[pkg.name]\n    if (!dependency) {\n      return false\n    }\n\n    const manifestPath = resolveFrom.silent(workDir, path.join(pkg.name, 'package.json'))\n    const installed = semver.coerce(\n      manifestPath\n        ? (await readPackageManifest(manifestPath)).version\n        : dependency.replace(/[\\D.]/g, ''),\n    )\n\n    if (!installed) {\n      return false\n    }\n\n    const supported = pkg.supported.join(' || ')\n\n    // \"Untested\" is usually the case where we have not upgraded the React version requirements\n    // before a release, but given that is usually works in a backwards-compatible way, we want\n    // to indicate that it's _untested_, not necessarily _unsupported_\n    // Ex: Installed is react@19.0.0, but we've only _tested_ with react@^18\n    const isUntested = !semver.satisfies(installed, supported) && semver.gtr(installed, supported)\n\n    // \"Unsupported\" in that the installed version is _lower than_ the minimum version\n    // Ex: Installed is react@15.0.0, but we require react@^16\n    const isUnsupported = !semver.satisfies(installed, supported) && !isUntested\n\n    // \"Deprecated\" in that we will stop supporting it at some point in the near future,\n    // so users should be prompted to upgrade\n    const isDeprecated = pkg.deprecatedBelow ? semver.ltr(installed, pkg.deprecatedBelow) : false\n\n    return {\n      ...pkg,\n      installed,\n      isUnsupported,\n      isDeprecated,\n      isUntested,\n    }\n  })\n\n  const installedPackages = (await Promise.all(packageInfo)).filter(\n    (inp): inp is PackageInfo => inp !== false,\n  )\n  const unsupported = installedPackages.filter((pkg) => pkg.isUnsupported)\n  const deprecated = installedPackages.filter((pkg) => !pkg.isUnsupported && pkg.isDeprecated)\n  const untested = installedPackages.filter((pkg) => pkg.isUntested)\n\n  if (deprecated.length > 0) {\n    // eslint-disable-next-line no-console\n    console.warn(`\n[WARN] The following package versions have been deprecated and should be upgraded:\n\n  ${listPackages(deprecated)}\n\nSupport for these will be removed in a future release!\n\n  ${getUpgradeInstructions(deprecated)}\n`)\n  }\n\n  if (untested.length > 0) {\n    // eslint-disable-next-line no-console\n    console.warn(`\n[WARN] The following package versions have not yet been marked as supported:\n\n  ${listPackages(untested)}\n\nYou _may_ encounter bugs while using these versions.\n\n  ${getDowngradeInstructions(untested)}\n`)\n  }\n\n  if (unsupported.length > 0) {\n    // eslint-disable-next-line no-console\n    console.error(`\n[ERROR] The following package versions are no longer supported and needs to be upgraded:\n\n  ${listPackages(unsupported)}\n\n  ${getUpgradeInstructions(unsupported)}\n`)\n    process.exit(1)\n  }\n}\n\nfunction listPackages(pkgs: PackageInfo[]) {\n  return pkgs\n    .map(\n      (pkg) =>\n        `${pkg.name} (installed: ${pkg.installed}, want: ${\n          pkg.deprecatedBelow || pkg.supported.join(' || ')\n        })`,\n    )\n    .join('\\n  ')\n}\n\nfunction getUpgradeInstructions(pkgs: PackageInfo[]) {\n  const inst = pkgs\n    .map((pkg) => {\n      const [highestSupported] = pkg.supported\n        .map((version) => (semver.coerce(version) || {version: ''}).version)\n        .sort(semver.rcompare)\n\n      return `\"${pkg.name}@${highestSupported}\"`\n    })\n    .join(' ')\n\n  return `To upgrade, run either:\n\n  npm install ${inst}\n\n  or\n\n  yarn add ${inst}\n\n  or\n\n  pnpm add ${inst}\n\n\nRead more at ${generateHelpUrl('upgrade-packages')}`\n}\n\nfunction getDowngradeInstructions(pkgs: PackageInfo[]) {\n  const inst = pkgs\n    .map((pkg) => {\n      const [highestSupported] = pkg.supported\n        .map((version) => (semver.coerce(version) || {version: ''}).version)\n        .sort(semver.rcompare)\n\n      return `\"${pkg.name}@${highestSupported}\"`\n    })\n    .join(' ')\n\n  return `To downgrade, run either:\n\n  yarn add ${inst}\n\n  or\n\n  npm install ${inst}\n\n  or\n\n  pnpm install ${inst}`\n}\n","import path from 'node:path'\n\nimport {type CliCommandContext} from '@sanity/cli'\nimport execa from 'execa'\nimport oneline from 'oneline'\nimport semver, {type SemVer} from 'semver'\n\nimport {peerDependencies} from '../../../../package.json'\nimport {determineIsApp} from './determineIsApp'\nimport {readModuleVersion} from './readModuleVersion'\nimport {type PartialPackageManifest, readPackageManifest} from './readPackageManifest'\n\nconst defaultStudioManifestProps: PartialPackageManifest = {\n  name: 'studio',\n  version: '1.0.0',\n}\n\ninterface CheckResult {\n  didInstall: boolean\n  installedSanityVersion: string\n}\n\n/**\n * Checks that the studio has declared and installed the required dependencies\n * needed by the Sanity modules. While we generally use regular, explicit\n * dependencies in modules, there are certain dependencies that are better\n * served being peer dependencies, such as react and styled-components.\n *\n * If these dependencies are not installed/declared, we want to prompt the user\n * whether or not to add them to `package.json` and install them\n *\n * Additionally, returns the version of the 'sanity' dependency from the package.json.\n */\nexport async function checkRequiredDependencies(context: CliCommandContext): Promise<CheckResult> {\n  // currently there's no check needed for custom apps,\n  // but this should be removed once they are more mature\n  const isApp = determineIsApp(context.cliConfig)\n  if (isApp) {\n    return {didInstall: false, installedSanityVersion: ''}\n  }\n\n  const {workDir: studioPath, output} = context\n  const [studioPackageManifest, installedStyledComponentsVersion, installedSanityVersion] =\n    await Promise.all([\n      await readPackageManifest(path.join(studioPath, 'package.json'), defaultStudioManifestProps),\n      await readModuleVersion(studioPath, 'styled-components'),\n      await readModuleVersion(studioPath, 'sanity'),\n    ])\n\n  const wantedStyledComponentsVersionRange = peerDependencies['styled-components']\n\n  // Retrieve the version of the 'sanity' dependency\n  if (!installedSanityVersion) {\n    throw new Error('Failed to read the installed sanity version.')\n  }\n\n  // The studio _must_ now declare `styled-components` as a dependency. If it's not there,\n  // we'll want to automatically _add it_ to the manifest and tell the user to reinstall\n  // dependencies before running whatever command was being run\n  const declaredStyledComponentsVersion =\n    studioPackageManifest.dependencies['styled-components'] ||\n    studioPackageManifest.devDependencies['styled-components']\n\n  if (!declaredStyledComponentsVersion) {\n    const [file, ...args] = process.argv\n    const deps = {'styled-components': wantedStyledComponentsVersionRange}\n    await installDependencies(deps, context)\n\n    // Re-run the same command (sanity dev/sanity build etc) after installation,\n    // as it can have shifted the entire `node_modules` folder around, result in\n    // broken assumptions about installation paths. This is a hack, and should be\n    // solved properly.\n    await execa(file, args, {cwd: studioPath, stdio: 'inherit'})\n    return {didInstall: true, installedSanityVersion}\n  }\n\n  // We ignore catalog identifiers since we check the actual version anyway\n  const isStyledComponentsVersionRangeInCatalog =\n    declaredStyledComponentsVersion.startsWith('catalog:')\n  // Theoretically the version specified in package.json could be incorrect, eg `foo`\n  let minDeclaredStyledComponentsVersion: SemVer | null = null\n  try {\n    minDeclaredStyledComponentsVersion = semver.minVersion(declaredStyledComponentsVersion)\n  } catch (err) {\n    // Intentional fall-through (variable will be left as null, throwing below)\n  }\n\n  if (!minDeclaredStyledComponentsVersion && !isStyledComponentsVersionRangeInCatalog) {\n    throw new Error(oneline`\n      Declared dependency \\`styled-components\\` has an invalid version range:\n      \\`${declaredStyledComponentsVersion}\\`.\n    `)\n  }\n\n  // The declared version should be semver-compatible with the version specified as a\n  // peer dependency in `sanity`. If not, we should tell the user to change it.\n  //\n  // Exception: Ranges are hard to compare. `>=5.0.0 && <=5.3.2 || ^6`... Comparing this\n  // to anything is going to be challenging, so only compare \"simple\" ranges/versions\n  // (^x.x.x / ~x.x.x / x.x.x)\n  if (\n    !isStyledComponentsVersionRangeInCatalog &&\n    isComparableRange(declaredStyledComponentsVersion) &&\n    !semver.satisfies(minDeclaredStyledComponentsVersion!, wantedStyledComponentsVersionRange)\n  ) {\n    output.warn(oneline`\n      Declared version of styled-components (${declaredStyledComponentsVersion})\n      is not compatible with the version required by sanity (${wantedStyledComponentsVersionRange}).\n      This might cause problems!\n    `)\n  }\n\n  // Ensure the studio has _installed_ a version of `styled-components`\n  if (!installedStyledComponentsVersion) {\n    throw new Error(oneline`\n      Declared dependency \\`styled-components\\` is not installed - run\n      \\`npm install\\`, \\`yarn install\\` or \\`pnpm install\\` to install it before re-running this command.\n    `)\n  }\n\n  // The studio should have an _installed_ version of `styled-components`, and it should\n  // be semver compatible with the version specified in `sanity` peer dependencies.\n  if (!semver.satisfies(installedStyledComponentsVersion, wantedStyledComponentsVersionRange)) {\n    output.warn(oneline`\n      Installed version of styled-components (${installedStyledComponentsVersion})\n      is not compatible with the version required by sanity (${wantedStyledComponentsVersionRange}).\n      This might cause problems!\n    `)\n  }\n\n  return {didInstall: false, installedSanityVersion}\n}\n\n/**\n * Install the passed dependencies at the given version/version range,\n * prompting the user which package manager to use. We will try to detect\n * a package manager from files in the directory and show that as the default\n *\n * @param dependencies - Object of dependencies `({[package name]: version})`\n * @param context - CLI context\n */\nasync function installDependencies(\n  dependencies: Record<string, string>,\n  context: CliCommandContext,\n): Promise<void> {\n  const {output, prompt, workDir, cliPackageManager} = context\n  const packages: string[] = []\n\n  output.print('The Sanity studio needs to install missing dependencies:')\n  for (const [pkgName, version] of Object.entries(dependencies)) {\n    const declaration = `${pkgName}@${version}`\n    output.print(`- ${declaration}`)\n    packages.push(declaration)\n  }\n\n  if (!cliPackageManager) {\n    output.error(\n      'ERROR: Could not determine package manager choice - run `npm install` or equivalent',\n    )\n    return\n  }\n\n  const {getPackageManagerChoice, installNewPackages} = cliPackageManager\n  const {mostOptimal, chosen: pkgManager} = await getPackageManagerChoice(workDir, {prompt})\n  if (mostOptimal && pkgManager !== mostOptimal) {\n    output.warn(\n      `WARN: This project appears to be installed with or using ${mostOptimal} - using a different package manager _may_ result in errors.`,\n    )\n  }\n\n  await installNewPackages({packages, packageManager: pkgManager}, context)\n}\n\nfunction isComparableRange(range: string): boolean {\n  return /^[\\^~]?\\d+(\\.\\d+)?(\\.\\d+)?$/.test(range)\n}\n","/* eslint-disable no-process-env */\nimport path from 'node:path'\n\nimport {type CliPrompter} from '@sanity/cli'\nimport preferredPM from 'preferred-pm'\nimport which from 'which'\n\nimport {isInteractive} from '../isInteractive'\n\nexport type PackageManager = 'npm' | 'yarn' | 'pnpm' | 'bun' | 'manual'\n\nexport const ALLOWED_PACKAGE_MANAGERS: PackageManager[] = ['npm', 'yarn', 'pnpm', 'bun', 'manual']\nexport const allowedPackageManagersString = ALLOWED_PACKAGE_MANAGERS.map((pm) => `\"${pm}\"`).join(\n  ' | ',\n)\n\nconst EXPERIMENTAL = ['bun']\n\n/**\n * Attempts to resolve the most optimal package manager to use to install/upgrade\n * packages/dependencies at a given path. It does so by looking for package manager\n * specific lockfiles. If it finds a lockfile belonging to a certain package manager,\n * it prioritizes this one. However, if that package manager is not installed, it will\n * prompt the user for which one they want to use and hint at the most optimal one\n * not being installed.\n *\n * Note that this function also takes local npm binary paths into account - for instance,\n * `yarn` can be installed as a dependency of the project instead of globally, and it\n * will use that is available.\n *\n * The user can also select 'manual' to skip the process and run their preferred package\n * manager manually. Commands using this function must take this `manual` choice into\n * account and act accordingly if chosen.\n *\n * @param workDir - The working directory where a lockfile is most likely to be present\n * @param options - Pass `interactive: false` to fall back to npm if most optimal is\n *                  not available, instead of prompting\n * @returns Object of `chosen` and, if a lockfile is found, the `mostOptimal` choice\n */\nexport async function getPackageManagerChoice(\n  workDir: string,\n  options: {interactive: false} | {interactive?: true; prompt: CliPrompter},\n): Promise<{chosen: PackageManager; mostOptimal?: PackageManager}> {\n  const rootDir = workDir || process.cwd()\n  const preferred = (await preferredPM(rootDir))?.name\n\n  if (preferred && (await hasCommand(preferred, rootDir))) {\n    // There is an optimal/preferred package manager, and the user has it installed!\n    return {chosen: preferred, mostOptimal: preferred}\n  }\n\n  const mostLikelyPM = await getMostLikelyInstalledPackageManager(rootDir)\n  const interactive = typeof options.interactive === 'boolean' ? options.interactive : isInteractive\n  if (!interactive) {\n    // We can't ask the user for their preference, so fall back to either the one that is being run\n    // or whatever is installed on the system (npm being the preferred choice).\n    // Note that the most optimal choice is already picked above if available.\n    return {chosen: mostLikelyPM || (await getFallback(rootDir)), mostOptimal: preferred}\n  }\n\n  if (!('prompt' in options)) {\n    throw new Error('Must pass `prompt` when in interactive mode')\n  }\n\n  // We can ask the user for their preference, hurray!\n  const messageSuffix = preferred ? ` (preferred is ${preferred}, but is not installed)` : ''\n  const installed = await getAvailablePackageManagers(rootDir)\n  const chosen = await options.prompt.single<PackageManager>({\n    type: 'list',\n    choices: installed.map((pm) => ({\n      value: pm,\n      name: EXPERIMENTAL.includes(pm) ? `${pm} (experimental)` : pm,\n    })),\n    default: preferred || mostLikelyPM,\n    message: `Package manager to use for installing dependencies?${messageSuffix}`,\n  })\n\n  return {chosen, mostOptimal: preferred}\n}\n\nasync function getFallback(cwd: string): Promise<PackageManager> {\n  if (await hasNpmInstalled(cwd)) {\n    return 'npm'\n  }\n\n  if (await hasYarnInstalled(cwd)) {\n    return 'yarn'\n  }\n\n  if (await hasPnpmInstalled(cwd)) {\n    return 'pnpm'\n  }\n\n  if (await hasBunInstalled(cwd)) {\n    return 'bun'\n  }\n\n  return 'manual'\n}\n\nasync function getAvailablePackageManagers(cwd: string): Promise<PackageManager[]> {\n  const [npm, yarn, pnpm, bun] = await Promise.all([\n    hasNpmInstalled(cwd),\n    hasYarnInstalled(cwd),\n    hasPnpmInstalled(cwd),\n    hasBunInstalled(cwd),\n  ])\n\n  const choices = [npm && 'npm', yarn && 'yarn', pnpm && 'pnpm', bun && 'bun', 'manual']\n  return choices.filter((pm): pm is PackageManager => pm !== false)\n}\n\nexport function hasNpmInstalled(cwd?: string): Promise<boolean> {\n  return hasCommand('npm', cwd)\n}\n\nexport function hasYarnInstalled(cwd?: string): Promise<boolean> {\n  return hasCommand('yarn', cwd)\n}\n\nexport function hasPnpmInstalled(cwd?: string): Promise<boolean> {\n  return hasCommand('pnpm', cwd)\n}\n\nexport function hasBunInstalled(cwd?: string): Promise<boolean> {\n  return hasCommand('bun', cwd)\n}\n\nexport function getNpmRunPath(cwd: string): string {\n  let previous\n  let cwdPath = path.resolve(cwd)\n  const result: string[] = []\n\n  while (previous !== cwdPath) {\n    result.push(path.join(cwdPath, 'node_modules', '.bin'))\n    previous = cwdPath\n    cwdPath = path.resolve(cwdPath, '..')\n  }\n\n  result.push(path.resolve(cwd, process.execPath, '..'))\n\n  const pathEnv = process.env[getPathEnvVarKey()]\n  return [...result, pathEnv].join(path.delimiter)\n}\n\nexport function getPartialEnvWithNpmPath(cwd: string): NodeJS.ProcessEnv {\n  const key = getPathEnvVarKey()\n  return {[key]: getNpmRunPath(cwd)}\n}\n\nfunction getPathEnvVarKey(): string {\n  if (process.platform !== 'win32') {\n    return 'PATH'\n  }\n\n  return (\n    Object.keys(process.env)\n      .reverse()\n      .find((key) => key.toUpperCase() === 'PATH') || 'Path'\n  )\n}\n\nfunction getCommandPath(cmd: string, cwd?: string): Promise<string | null> {\n  const options = {path: cwd ? getNpmRunPath(cwd) : undefined}\n  return which(cmd, options).catch(() => null)\n}\n\nfunction hasCommand(cmd: string, cwd?: string): Promise<boolean> {\n  return getCommandPath(cmd, cwd).then((cmdPath) => cmdPath !== null)\n}\n\nasync function getMostLikelyInstalledPackageManager(\n  rootDir: string,\n): Promise<PackageManager | undefined> {\n  const installed = await getAvailablePackageManagers(rootDir)\n  const running = getRunningPackageManager()\n  return running && installed.includes(running) ? running : undefined\n}\n\nfunction getRunningPackageManager(): PackageManager | undefined {\n  // Yes, the env var is lowercase - it is set by the package managers themselves\n  const agent = process.env.npm_config_user_agent || ''\n\n  if (agent.includes('yarn')) {\n    return 'yarn'\n  }\n\n  if (agent.includes('pnpm')) {\n    return 'pnpm'\n  }\n\n  if (agent.includes('bun')) {\n    return 'bun'\n  }\n\n  // Both yarn and pnpm does a `npm/?` thing, thus the slightly different match here\n  // Theoretically not needed since we check for yarn/pnpm above, but in case other\n  // package managers do the same thing, we'll (hopefully) catch them here.\n  if (/^npm\\/\\d/.test(agent)) {\n    return 'npm'\n  }\n\n  return undefined\n}\n","import execa, {type CommonOptions, type ExecaReturnValue} from 'execa'\n\nimport {getPartialEnvWithNpmPath, type PackageManager} from './packageManagerChoice'\n\nexport interface InstallOptions {\n  packageManager: PackageManager\n  packages: [name: string, version: string][]\n}\n\nexport async function upgradePackages(\n  options: InstallOptions,\n  context: {output: {print: (output: string) => void}; workDir: string},\n): Promise<void> {\n  const {packageManager, packages} = options\n  const {output, workDir} = context\n  const execOptions: CommonOptions<'utf8'> = {\n    encoding: 'utf8',\n    env: getPartialEnvWithNpmPath(workDir),\n    cwd: workDir,\n    stdio: 'inherit',\n  }\n  const upgradePackageArgs = packages.map((pkg) => pkg.join('@'))\n  let result: ExecaReturnValue<string> | undefined\n  if (packageManager === 'npm') {\n    const npmArgs = ['install', '--legacy-peer-deps', ...upgradePackageArgs]\n    output.print(`Running 'npm ${npmArgs.join(' ')}'`)\n    result = await execa('npm', npmArgs, execOptions)\n  } else if (packageManager === 'yarn') {\n    const yarnArgs = ['upgrade ', ...upgradePackageArgs]\n    output.print(`Running 'yarn ${yarnArgs.join(' ')}'`)\n    result = await execa('yarn', yarnArgs, execOptions)\n  } else if (packageManager === 'pnpm') {\n    const pnpmArgs = ['upgrade', ...upgradePackageArgs]\n    output.print(`Running 'pnpm ${pnpmArgs.join(' ')}'`)\n    result = await execa('pnpm', pnpmArgs, execOptions)\n  } else if (packageManager === 'bun') {\n    const bunArgs = ['update', ...upgradePackageArgs]\n    output.print(`Running 'bun ${bunArgs.join(' ')}'`)\n    result = await execa('bun', bunArgs, execOptions)\n  } else if (packageManager === 'manual') {\n    output.print(\n      `Manual installation selected - run 'npm upgrade ${upgradePackageArgs.join(' ')}' or equivalent`,\n    )\n  }\n\n  if (result?.exitCode || result?.failed) {\n    throw new Error('Package upgrade failed')\n  }\n}\n"],"names":["PACKAGES","name","supported","deprecatedBelow","checkStudioDependencyVersions","workDir","manifest","readPackageJson","path","join","dependencies","devDependencies","packageInfo","map","pkg","dependency","manifestPath","resolveFrom","silent","installed","semver","coerce","readPackageManifest","version","replace","isUntested","satisfies","gtr","isUnsupported","isDeprecated","ltr","installedPackages","Promise","all","filter","inp","unsupported","deprecated","untested","length","console","warn","listPackages","getUpgradeInstructions","getDowngradeInstructions","error","process","exit","pkgs","inst","highestSupported","sort","rcompare","generateHelpUrl","defaultStudioManifestProps","checkRequiredDependencies","context","determineIsApp","cliConfig","didInstall","installedSanityVersion","studioPath","output","studioPackageManifest","installedStyledComponentsVersion","readModuleVersion","wantedStyledComponentsVersionRange","peerDependencies","Error","declaredStyledComponentsVersion","file","args","argv","installDependencies","execa","cwd","stdio","isStyledComponentsVersionRangeInCatalog","startsWith","minDeclaredStyledComponentsVersion","minVersion","oneline","isComparableRange","prompt","cliPackageManager","packages","print","pkgName","Object","entries","declaration","push","getPackageManagerChoice","installNewPackages","mostOptimal","chosen","pkgManager","packageManager","range","test","EXPERIMENTAL","options","rootDir","preferred","preferredPM","hasCommand","mostLikelyPM","getMostLikelyInstalledPackageManager","interactive","isInteractive","getFallback","messageSuffix","getAvailablePackageManagers","single","type","choices","pm","value","includes","default","message","hasNpmInstalled","hasYarnInstalled","hasPnpmInstalled","hasBunInstalled","npm","yarn","pnpm","bun","getNpmRunPath","previous","cwdPath","resolve","result","execPath","pathEnv","env","getPathEnvVarKey","delimiter","getPartialEnvWithNpmPath","platform","keys","reverse","find","key","toUpperCase","getCommandPath","cmd","undefined","which","catch","then","cmdPath","running","getRunningPackageManager","agent","npm_config_user_agent","upgradePackages","execOptions","encoding","upgradePackageArgs","npmArgs","yarnArgs","pnpmArgs","bunArgs","exitCode","failed"],"mappings":"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"}