{"version":3,"file":"schemaStoreOutStrings.js","sources":["../../src/_internal/manifest/manifestTypes.ts","../../src/_internal/cli/actions/schema/__telemetry__/schemaStore.telemetry.ts","../../src/_internal/manifest/manifestTypeHelpers.ts","../../src/_internal/cli/actions/schema/utils/manifestReader.ts","../../src/_internal/cli/actions/schema/utils/schemaStoreValidation.ts","../../src/_internal/cli/actions/schema/utils/mainfestExtractor.ts","../../src/_internal/cli/actions/schema/utils/schemaApiClient.ts","../../src/_internal/cli/actions/schema/utils/schemaStoreOutStrings.ts"],"sourcesContent":["import {type SanityDocumentLike} from '@sanity/types'\nimport {type MediaLibraryConfig} from 'sanity'\n\nexport const SANITY_WORKSPACE_SCHEMA_ID_PREFIX = '_.schemas'\nexport const SANITY_WORKSPACE_SCHEMA_TYPE = 'system.schema'\nexport const CURRENT_WORKSPACE_SCHEMA_VERSION = '2025-05-01'\n\nexport type ManifestSerializable =\n  | string\n  | number\n  | boolean\n  | {[k: string]: ManifestSerializable}\n  | ManifestSerializable[]\n\nexport interface CreateManifest {\n  version: number\n  createdAt: string\n  workspaces: ManifestWorkspaceFile[]\n}\n\nexport interface ManifestWorkspaceFile extends Omit<CreateWorkspaceManifest, 'schema' | 'tools'> {\n  schema: string // filename\n  tools: string // filename\n}\n\nexport interface CreateWorkspaceManifest {\n  name: string\n  title?: string\n  subtitle?: string\n  basePath: string\n  dataset: string\n  projectId: string\n  mediaLibrary?: MediaLibraryConfig\n  schema: ManifestSchemaType[]\n  tools: ManifestTool[]\n  /**\n   * returns null in the case of the icon not being able to be stringified\n   */\n  icon: string | null\n}\n\nexport interface ManifestSchemaType {\n  type: string\n  name: string\n  title?: string\n  deprecated?: {\n    reason: string\n  }\n  readOnly?: boolean | 'conditional'\n  hidden?: boolean | 'conditional'\n  validation?: ManifestValidationGroup[]\n  fields?: ManifestField[]\n  to?: ManifestReferenceMember[]\n  of?: ManifestArrayMember[]\n  preview?: {\n    select: Record<string, string>\n  }\n  fieldsets?: ManifestFieldset[]\n  options?: Record<string, ManifestSerializable>\n  //portable text\n  marks?: {\n    annotations?: ManifestArrayMember[]\n    decorators?: ManifestTitledValue[]\n  }\n  lists?: ManifestTitledValue[]\n  styles?: ManifestTitledValue[]\n\n  // userland (assignable to ManifestSerializable | undefined)\n  // not included to add some typesafty to extractManifest\n  // [index: string]: unknown\n}\n\nexport interface ManifestFieldset {\n  name: string\n  title?: string\n  [index: string]: ManifestSerializable | undefined\n}\n\nexport interface ManifestTitledValue {\n  value: string\n  title?: string\n}\n\nexport type ManifestField = ManifestSchemaType & {fieldset?: string}\nexport type ManifestArrayMember = Omit<ManifestSchemaType, 'name'> & {name?: string}\nexport type ManifestReferenceMember = Omit<ManifestSchemaType, 'name'> & {name?: string}\n\nexport interface ManifestValidationGroup {\n  rules: ManifestValidationRule[]\n  message?: string\n  level?: 'error' | 'warning' | 'info'\n}\n\nexport type ManifestValidationRule = {\n  flag: string\n  constraint?: ManifestSerializable\n  [index: string]: ManifestSerializable | undefined\n}\n\nexport interface ManifestTool {\n  name: string\n  title: string\n  /**\n   * returns null in the case of the icon not being able to be stringified\n   */\n  icon: string | null\n  type: string | null\n}\n\nexport type DefaultWorkspaceSchemaId = `${typeof SANITY_WORKSPACE_SCHEMA_ID_PREFIX}.${string}`\nexport type PrefixedWorkspaceSchemaId = `${DefaultWorkspaceSchemaId}.${string}`\nexport type WorkspaceSchemaId = DefaultWorkspaceSchemaId | PrefixedWorkspaceSchemaId\n\nexport interface StoredWorkspaceSchema extends SanityDocumentLike {\n  _type: typeof SANITY_WORKSPACE_SCHEMA_TYPE\n  _id: WorkspaceSchemaId\n  /* api-like version string: date at which the format had a meaningful change */\n  version: typeof CURRENT_WORKSPACE_SCHEMA_VERSION | undefined\n  tag?: string\n  workspace: {\n    name: string\n    title?: string\n  }\n  /**\n   * The API expects JSON coming in, but will store a string to save on attribute paths.\n   * Consumers must use JSON.parse on the value, put we deploy to the API using ManifestSchemaType[]\n   */\n  schema: string | ManifestSchemaType[]\n}\n","import {defineTrace} from '@sanity/telemetry'\n\ninterface SchemaDeployTraceData {\n  manifestDir: string\n  schemaRequired: boolean\n  workspaceName?: string\n  idPrefix?: string\n  extractManifest?: boolean\n}\n\ninterface GenerateManifestTraceData {\n  manifestDir: string\n  schemaRequired: boolean\n}\n\nexport const GenerateManifest = defineTrace<GenerateManifestTraceData>({\n  name: 'Manifest generation executed',\n  version: 1,\n  description: 'Manifest generation was executed',\n})\n\nexport const SchemaDeploy = defineTrace<SchemaDeployTraceData>({\n  name: 'Schema deploy action executed',\n  version: 1,\n  description:\n    'Schema deploy action was executed, either via sanity schema deploy or as sanity deploy',\n})\n\n//Note – the individual sanity schema store commands are covered by the general cli telemetry\n","import {\n  type CrossDatasetReferenceSchemaType,\n  type GlobalDocumentReferenceSchemaType,\n  type ObjectField,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type SchemaType,\n} from '@sanity/types'\n\nconst DEFAULT_IMAGE_FIELDS = ['asset', 'hotspot', 'crop', 'media']\nconst DEFAULT_FILE_FIELDS = ['asset', 'media']\nconst DEFAULT_GEOPOINT_FIELDS = ['lat', 'lng', 'alt']\nconst DEFAULT_SLUG_FIELDS = ['current', 'source']\n\ntype InternalOwnProps = {fields?: unknown[]; type?: string; name?: string}\n\nexport function getCustomFields(type: ObjectSchemaType): (ObjectField & {fieldset?: string})[] {\n  const fields = type.fieldsets\n    ? type.fieldsets.flatMap((fs) => {\n        if (fs.single) {\n          return fs.field\n        }\n        return fs.fields.map((field) => ({\n          ...field,\n          fieldset: fs.name,\n        }))\n      })\n    : type.fields\n\n  if (isType(type, 'block')) {\n    return []\n  }\n  if (isType(type, 'slug')) {\n    return fields.filter((f) => !DEFAULT_SLUG_FIELDS.includes(f.name))\n  }\n  if (isType(type, 'geopoint')) {\n    return fields.filter((f) => !DEFAULT_GEOPOINT_FIELDS.includes(f.name))\n  }\n  if (isType(type, 'image')) {\n    return fields.filter((f) => !DEFAULT_IMAGE_FIELDS.includes(f.name))\n  }\n  if (isType(type, 'file')) {\n    return fields.filter((f) => !DEFAULT_FILE_FIELDS.includes(f.name))\n  }\n  return fields\n}\n\nexport function isReference(type: SchemaType): type is ReferenceSchemaType {\n  return isType(type, 'reference')\n}\n\nexport function isCrossDatasetReference(type: SchemaType): type is CrossDatasetReferenceSchemaType {\n  return isType(type, 'crossDatasetReference')\n}\n\nexport function isGlobalDocumentReference(\n  type: SchemaType,\n): type is GlobalDocumentReferenceSchemaType {\n  return isType(type, 'globalDocumentReference')\n}\n\nexport function isObjectField(maybeOjectField: unknown): boolean {\n  return (\n    typeof maybeOjectField === 'object' && maybeOjectField !== null && 'name' in maybeOjectField\n  )\n}\n\nexport function isCustomized(maybeCustomized: SchemaType): boolean {\n  const internalOwnProps = getSchemaTypeInternalOwnProps(maybeCustomized)\n\n  const hasFieldsArray =\n    isObjectField(maybeCustomized) &&\n    !isReference(maybeCustomized) &&\n    !isCrossDatasetReference(maybeCustomized) &&\n    !isGlobalDocumentReference(maybeCustomized) &&\n    'fields' in maybeCustomized &&\n    Array.isArray(maybeCustomized.fields) &&\n    // needed to differentiate inline, named array object types from globally defined types\n    // we only consider it customized if the _definition_ has fields declared\n    // this holds for all customizable object-like types: object, document, image and file\n    internalOwnProps?.fields\n\n  if (!hasFieldsArray) {\n    return false\n  }\n\n  const fields = getCustomFields(maybeCustomized)\n  return !!fields.length\n}\n\nexport function isType(schemaType: SchemaType, typeName: string): boolean {\n  if (schemaType.name === typeName) {\n    return true\n  }\n  if (!schemaType.type) {\n    return false\n  }\n  return isType(schemaType.type, typeName)\n}\n\nexport function isDefined<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined\n}\n\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && typeof value === 'object'\n}\n\nexport function isPrimitive(value: unknown): value is string | boolean | number {\n  return isString(value) || isBoolean(value) || isNumber(value)\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value: unknown): value is number {\n  return typeof value === 'boolean'\n}\n\nfunction isBoolean(value: unknown): value is boolean {\n  return typeof value === 'number'\n}\n\n/**\n * _internal_ownProps contains the _definition_ for the type.\n * Without it we cannot differentiate inline array item types from globally defined types in array.of\n */\nexport function getSchemaTypeInternalOwnProps(type: SchemaType): InternalOwnProps | undefined {\n  return (type as {_internal_ownProps?: InternalOwnProps})?._internal_ownProps\n}\n\n/**\n * This allows us to differentiate inline array.of type definitions vs global type names on compiled schema types\n */\nexport function getDefinedTypeName(type: SchemaType): string | undefined {\n  return getSchemaTypeInternalOwnProps(type)?.type\n}\n","import {type Stats} from 'node:fs'\nimport {readFile, stat} from 'node:fs/promises'\nimport path, {join, resolve} from 'node:path'\n\nimport {type CliOutputter} from '@sanity/cli'\nimport chalk from 'chalk'\n\nimport {type CreateManifest, type ManifestSchemaType} from '../../../../manifest/manifestTypes'\nimport {MANIFEST_FILENAME} from '../../manifest/extractManifestAction'\nimport {type DeploySchemasFlags} from '../deploySchemasAction'\n\nexport type ManifestJsonReader = <T>(\n  filePath: string,\n) => Promise<JsonFileParseSuccess<T> | undefined>\n\nexport type CreateManifestReaderFactory = (args: {\n  manifestDir: string\n  output: CliOutputter\n  jsonReader?: <T>(filePath: string) => Promise<JsonFileParseSuccess<T> | undefined>\n}) => CreateManifestReader\n\nexport interface CreateManifestReader {\n  getManifest: () => Promise<CreateManifest>\n  getWorkspaceSchema: (workspaceName: string) => Promise<ManifestSchemaType[]>\n}\n\ninterface JsonFileParseSuccess<T> {\n  parsedJson: T\n  path: string\n  lastModified: string\n}\n\n/**\n * The manifest reader will try to read manifest and workspace schema files _once_ and cache a successful result.\n * If you need to re-read the manifest from disk, create a new instance.\n */\nexport const createManifestReader: CreateManifestReaderFactory = ({\n  manifestDir,\n  output,\n  jsonReader = parseJsonFile,\n}) => {\n  let parsedManifest: JsonFileParseSuccess<CreateManifest>\n  const parsedWorkspaces: Record<string, JsonFileParseSuccess<ManifestSchemaType[]> | undefined> =\n    {}\n\n  const getManifest: CreateManifestReader['getManifest'] = async () => {\n    if (parsedManifest) {\n      return parsedManifest?.parsedJson\n    }\n\n    const manifestFile = path.join(manifestDir, MANIFEST_FILENAME)\n\n    const result = await jsonReader<CreateManifest>(manifestFile)\n    if (!result) {\n      throw new Error(\n        `Manifest does not exist at ${manifestFile}. To create the manifest file, omit --no-${'extract-manifest' satisfies keyof DeploySchemasFlags} or run \"sanity manifest extract\" first.`,\n      )\n    }\n\n    output.print(\n      chalk.gray(`↳ Read manifest from ${manifestFile} (last modified: ${result.lastModified})`),\n    )\n\n    parsedManifest = result\n    return result.parsedJson\n  }\n\n  const getWorkspaceSchema: CreateManifestReader['getWorkspaceSchema'] = async (workspaceName) => {\n    if (parsedWorkspaces[workspaceName]) {\n      return parsedWorkspaces[workspaceName]?.parsedJson\n    }\n    const manifest = await getManifest()\n    if (!manifest) {\n      throw Error('Manifest is required to read workspace schema.')\n    }\n\n    const workspaceManifest = manifest.workspaces.find(\n      (workspace) => workspace.name === workspaceName,\n    )\n\n    if (!workspaceManifest) {\n      throw Error(`No workspace named \"${workspaceName}\" found in manifest.`)\n    }\n\n    const workspaceSchemaFile = path.join(manifestDir, workspaceManifest.schema ?? '')\n    const result = await jsonReader<ManifestSchemaType[]>(workspaceSchemaFile)\n    if (!result) {\n      throw Error(`Workspace schema file at \"${workspaceSchemaFile}\" does not exist.`)\n    }\n    parsedWorkspaces[workspaceName] = result\n    return result.parsedJson\n  }\n  return {\n    getManifest,\n    getWorkspaceSchema,\n  }\n}\n\nexport function resolveManifestDirectory(workDir: string, customPath?: string): string {\n  const defaultOutputDir = resolve(join(workDir, 'dist'))\n\n  const outputDir = resolve(defaultOutputDir)\n  const defaultStaticPath = join(outputDir, 'static')\n\n  const staticPath = customPath ?? defaultStaticPath\n  return path.resolve(process.cwd(), staticPath)\n}\n\nasync function parseJsonFile<T>(filePath: string): Promise<JsonFileParseSuccess<T> | undefined> {\n  let stats: Stats\n  try {\n    stats = await stat(filePath)\n  } catch (err) {\n    // file does not exist\n    return undefined\n  }\n  const content = await readFile(filePath, 'utf-8')\n  const lastModified = stats.mtime.toISOString()\n  const json = JSON.parse(content) as T\n  if (!json) {\n    throw new Error(`JSON file \"${filePath}\" was empty.`)\n  }\n  return {\n    parsedJson: json,\n    path: filePath,\n    lastModified,\n  }\n}\n","import uniqBy from 'lodash/uniqBy'\n\nimport {isDefined} from '../../../../manifest/manifestTypeHelpers'\nimport {SANITY_WORKSPACE_SCHEMA_ID_PREFIX} from '../../../../manifest/manifestTypes'\nimport {type DeleteSchemaFlags} from '../deleteSchemaAction'\nimport {type DeploySchemasFlags} from '../deploySchemasAction'\nimport {type SchemaListFlags} from '../listSchemasAction'\nimport {resolveManifestDirectory} from './manifestReader'\n\nexport const validForIdChars = 'a-zA-Z0-9._-'\nexport const validForIdPattern = new RegExp(`^[${validForIdChars}]+$`, 'g')\n\n//no periods allowed in workspaceName or tag in ids\nexport const validForNamesChars = 'a-zA-Z0-9_-'\nexport const validForNamesPattern = new RegExp(`^[${validForNamesChars}]+$`, 'g')\n\nconst requiredInId = SANITY_WORKSPACE_SCHEMA_ID_PREFIX.replace(/[.]/g, '\\\\.')\n\nconst idIdPatternString = `^${requiredInId}\\\\.([${validForNamesChars}]+)`\nconst baseIdPattern = new RegExp(`${idIdPatternString}$`)\nconst taggedIdIdPattern = new RegExp(`${idIdPatternString}\\\\.tag\\\\.([${validForNamesChars}]+)$`)\n\nexport class FlagValidationError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'FlagValidationError'\n  }\n}\n\ninterface WorkspaceSchemaId {\n  schemaId: string\n  workspace: string\n}\n\nexport interface SchemaStoreCommonFlags {\n  'extract-manifest'?: boolean\n  'manifest-dir'?: string\n  'verbose'?: boolean\n}\n\nfunction parseCommonFlags(\n  flags: SchemaStoreCommonFlags,\n  context: {workDir: string},\n  errors: string[],\n) {\n  const manifestDir = parseManifestDir(flags, errors)\n  const verbose = !!flags.verbose\n  // extract manifest by default: our CLI layer handles both --extract-manifest (true) and --no-extract-manifest (false)\n  const extractManifest = flags['extract-manifest'] ?? true\n\n  const fullManifestDir = resolveManifestDirectory(context.workDir, manifestDir)\n  return {\n    manifestDir: fullManifestDir,\n    verbose,\n    extractManifest,\n  }\n}\n\nexport function parseDeploySchemasConfig(flags: DeploySchemasFlags, context: {workDir: string}) {\n  const errors: string[] = []\n\n  const commonFlags = parseCommonFlags(flags, context, errors)\n  const workspaceName = parseWorkspace(flags, errors)\n  const tag = parseTag(flags, errors)\n  const schemaRequired = !!flags['schema-required']\n\n  assertNoErrors(errors)\n  return {...commonFlags, workspaceName, tag, schemaRequired}\n}\n\nexport function parseListSchemasConfig(flags: SchemaListFlags, context: {workDir: string}) {\n  const errors: string[] = []\n\n  const commonFlags = parseCommonFlags(flags, context, errors)\n  const id = parseId(flags, errors)\n  const json = !!flags.json\n\n  assertNoErrors(errors)\n  return {...commonFlags, json, id}\n}\n\nexport function parseDeleteSchemasConfig(flags: DeleteSchemaFlags, context: {workDir: string}) {\n  const errors: string[] = []\n\n  const commonFlags = parseCommonFlags(flags, context, errors)\n  const ids = parseIds(flags, errors)\n  const dataset = parseDataset(flags, errors)\n\n  assertNoErrors(errors)\n  return {...commonFlags, dataset, ids}\n}\n\nfunction assertNoErrors(errors: string[]) {\n  if (errors.length) {\n    throw new FlagValidationError(\n      `Invalid arguments:\\n${errors.map((error) => `  - ${error}`).join('\\n')}`,\n    )\n  }\n}\n\nexport function parseIds(flags: {ids?: unknown}, errors: string[]): WorkspaceSchemaId[] {\n  const parsedIds = parseNonEmptyString(flags, 'ids', errors)\n  if (errors.length) {\n    return []\n  }\n\n  const ids = parsedIds\n    .split(',')\n    .map((id) => id.trim())\n    .filter((id) => !!id)\n    .map((id) => parseWorkspaceSchemaId(id, errors))\n    .filter(isDefined)\n\n  const uniqueIds = uniqBy(ids, 'schemaId' satisfies keyof (typeof ids)[number])\n  if (uniqueIds.length < ids.length) {\n    errors.push(`ids contains duplicates`)\n  }\n  if (!errors.length && !uniqueIds.length) {\n    errors.push(`ids contains no valid id strings`)\n  }\n  return uniqueIds\n}\n\nexport function parseId(flags: {id?: unknown}, errors: string[]) {\n  const id = flags.id === undefined ? undefined : parseNonEmptyString(flags, 'id', errors)\n  if (id) {\n    return parseWorkspaceSchemaId(id, errors)?.schemaId\n  }\n  return undefined\n}\n\nexport function parseWorkspaceSchemaId(id: string, errors: string[]) {\n  const trimmedId = id.trim()\n\n  if (!trimmedId.match(validForIdPattern)) {\n    errors.push(`id can only contain characters in [${validForIdChars}] but found: \"${trimmedId}\"`)\n    return undefined\n  }\n\n  if (trimmedId.startsWith('-')) {\n    errors.push(`id cannot start with - (dash) but found: \"${trimmedId}\"`)\n    return undefined\n  }\n\n  if (trimmedId.match(/\\.\\./g)) {\n    errors.push(`id cannot have consecutive . (period) characters, but found: \"${trimmedId}\"`)\n    return undefined\n  }\n  const [fullMatch, workspace, tag] =\n    trimmedId.match(taggedIdIdPattern) ?? trimmedId.match(baseIdPattern) ?? []\n  if (!workspace) {\n    errors.push(\n      [\n        `id must either match ${SANITY_WORKSPACE_SCHEMA_ID_PREFIX}.<workspaceName> `,\n        `or ${SANITY_WORKSPACE_SCHEMA_ID_PREFIX}.<workspaceName>.tag.<tag> but found: \"${trimmedId}\". `,\n        `Note that workspace name characters not in [${validForNamesChars}] has to be replaced with _ for schema id.`,\n      ].join(''),\n    )\n    return undefined\n  }\n  return {\n    schemaId: trimmedId,\n    workspace,\n  }\n}\n\nfunction parseDataset(flags: {dataset?: unknown}, errors: string[]) {\n  return flags.dataset === undefined ? undefined : parseNonEmptyString(flags, 'dataset', errors)\n}\n\nfunction parseWorkspace(flags: {workspace?: unknown}, errors: string[]) {\n  return flags.workspace === undefined ? undefined : parseNonEmptyString(flags, 'workspace', errors)\n}\n\nfunction parseManifestDir(flags: {'manifest-dir'?: unknown}, errors: string[]) {\n  return flags['manifest-dir'] === undefined\n    ? undefined\n    : parseNonEmptyString(flags, 'manifest-dir', errors)\n}\n\nexport function parseTag(flags: {tag?: unknown}, errors: string[]) {\n  if (flags.tag === undefined) {\n    return undefined\n  }\n\n  const tag = parseNonEmptyString(flags, 'tag', errors)\n  if (errors.length) {\n    return undefined\n  }\n\n  if (tag.includes('.')) {\n    errors.push(`tag cannot contain . (period), but was: \"${tag}\"`)\n    return undefined\n  }\n\n  if (!tag.match(validForNamesPattern)) {\n    errors.push(`tag can only contain characters in [${validForNamesChars}], but was: \"${tag}\"`)\n    return undefined\n  }\n\n  if (tag.startsWith('-')) {\n    errors.push(`tag cannot start with - (dash) but was: \"${tag}\"`)\n    return undefined\n  }\n\n  return tag\n}\n\nfunction parseNonEmptyString<\n  Flag extends string,\n  Flags extends Partial<Record<Flag, unknown | undefined>>,\n>(flags: Flags, flagName: Flag, errors: string[]): string {\n  const flag = flags[flagName]\n  if (!isString(flag) || !flag) {\n    errors.push(`${flagName} argument is empty`)\n    return ''\n  }\n  return flag\n}\n\nfunction isString(flag: unknown): flag is string {\n  return typeof flag === 'string'\n}\n\nexport const SCHEMA_PERMISSION_HELP_TEXT =\n  'For multi-project workspaces, set SANITY_AUTH_TOKEN environment variable to a token with access to the workspace projects.'\n","import {\n  type CliCommandArguments,\n  type CliCommandContext,\n  type CliOutputter,\n  type TelemetryUserProperties,\n} from '@sanity/cli'\nimport {type TelemetryLogger} from '@sanity/telemetry'\nimport chalk from 'chalk'\n\nimport {type ExtractManifestFlags, extractManifestSafe} from '../../manifest/extractManifestAction'\nimport {GenerateManifest} from '../__telemetry__/schemaStore.telemetry'\nimport {FlagValidationError} from './schemaStoreValidation'\n\nexport type ManifestExtractor = (manifestDir: string) => Promise<void>\n\nexport async function ensureManifestExtractSatisfied(args: {\n  schemaRequired: boolean\n  extractManifest: boolean\n  manifestDir: string\n  manifestExtractor: (manifestDir: string) => Promise<void>\n  output: CliOutputter\n  telemetry: TelemetryLogger<TelemetryUserProperties>\n}) {\n  const {schemaRequired, extractManifest, manifestDir, manifestExtractor, output, telemetry} = args\n  if (!extractManifest) {\n    return true\n  }\n  const trace = telemetry.trace(GenerateManifest, {manifestDir, schemaRequired})\n  try {\n    trace.start()\n    // a successful manifest extract will write a new manifest file, which manifestReader will then read from disk\n    await manifestExtractor(manifestDir)\n    trace.complete()\n    return true\n  } catch (err) {\n    trace.error(err)\n\n    if (schemaRequired || err instanceof FlagValidationError) {\n      throw err\n    } else {\n      output.print(chalk.gray(`↳ Failed to extract manifest:\\n  ${err.message}`))\n      return false\n    }\n  }\n}\n\nexport function createManifestExtractor(context: CliCommandContext & {safe?: boolean}) {\n  return async (manifestDir: string) => {\n    const error = await extractManifestSafe(\n      {\n        extOptions: {path: manifestDir},\n        groupOrCommand: 'extract',\n        argv: [],\n        argsWithoutOptions: [],\n        extraArguments: [],\n      } as CliCommandArguments<ExtractManifestFlags>,\n      context,\n    )\n    if (!context.safe && error) {\n      throw error\n    }\n  }\n}\n","import {type CliApiClient} from '@sanity/cli'\n\nexport function createSchemaApiClient(apiClient: CliApiClient) {\n  const client = apiClient({\n    requireUser: true,\n    requireProject: true,\n  }).withConfig({apiVersion: 'v2025-03-01', useCdn: false})\n\n  const projectId = client.config().projectId\n  const dataset = client.config().dataset\n  if (!projectId) throw new Error('Project ID is not defined')\n  if (!dataset) throw new Error('Dataset is not defined')\n\n  return {\n    client,\n    projectId,\n    dataset,\n  }\n}\n","export function getProjectIdDatasetsOutString(\n  projectIdDatasets: {projectId: string; dataset: string}[],\n) {\n  return projectIdDatasets.length === 1\n    ? `${projectIdDatasetPair(projectIdDatasets[0])}`\n    : `${getStringArrayOutString(projectIdDatasets.map(projectIdDatasetPair))}`\n}\n\nexport function projectIdDatasetPair(pair: {projectId: string; dataset: string}) {\n  return JSON.stringify({projectId: pair.projectId, dataset: pair.dataset})\n}\n\nexport function getStringArrayOutString(array: string[]) {\n  return `[${array.map((d) => `\"${d}\"`).join(',')}]`\n}\n\nexport function getStringList(array: string[]) {\n  return array.map((s) => `- ${s}`).join('\\n')\n}\n"],"names":["SANITY_WORKSPACE_SCHEMA_ID_PREFIX","CURRENT_WORKSPACE_SCHEMA_VERSION","GenerateManifest","defineTrace","name","version","description","SchemaDeploy","isDefined","value","createManifestReader","manifestDir","output","jsonReader","parseJsonFile","parsedManifest","parsedWorkspaces","getManifest","parsedJson","manifestFile","path","join","MANIFEST_FILENAME","result","Error","print","chalk","gray","lastModified","getWorkspaceSchema","workspaceName","manifest","workspaceManifest","workspaces","find","workspace","workspaceSchemaFile","schema","resolveManifestDirectory","workDir","customPath","defaultOutputDir","resolve","outputDir","defaultStaticPath","staticPath","process","cwd","filePath","stats","stat","content","readFile","mtime","toISOString","json","JSON","parse","validForIdChars","validForIdPattern","RegExp","validForNamesChars","validForNamesPattern","requiredInId","replace","idIdPatternString","baseIdPattern","taggedIdIdPattern","FlagValidationError","constructor","message","parseCommonFlags","flags","context","errors","parseManifestDir","verbose","extractManifest","parseDeploySchemasConfig","commonFlags","parseWorkspace","tag","parseTag","schemaRequired","assertNoErrors","parseListSchemasConfig","id","parseId","parseDeleteSchemasConfig","ids","parseIds","dataset","parseDataset","length","map","error","parsedIds","parseNonEmptyString","split","trim","filter","parseWorkspaceSchemaId","uniqueIds","uniqBy","push","undefined","schemaId","trimmedId","match","startsWith","fullMatch","includes","flagName","flag","isString","SCHEMA_PERMISSION_HELP_TEXT","ensureManifestExtractSatisfied","args","manifestExtractor","telemetry","trace","start","complete","err","createManifestExtractor","extractManifestSafe","extOptions","groupOrCommand","argv","argsWithoutOptions","extraArguments","safe","createSchemaApiClient","apiClient","client","requireUser","requireProject","withConfig","apiVersion","useCdn","projectId","config","getProjectIdDatasetsOutString","projectIdDatasets","projectIdDatasetPair","getStringArrayOutString","pair","stringify","array","d","getStringList","s"],"mappings":"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"}