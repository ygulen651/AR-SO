{"version":3,"file":"extractAction.js","sources":["../../src/_internal/cli/actions/schema/extractSchema.telemetry.ts","../../src/_internal/cli/actions/schema/extractAction.ts"],"sourcesContent":["import {defineTrace} from '@sanity/telemetry'\n\ninterface SchemaExtractedTraceAttrubutes {\n  schemaAllTypesCount: number\n  schemaDocumentTypesCount: number\n  schemaTypesCount: number\n\n  enforceRequiredFields: boolean\n  schemaFormat: string\n}\n\nexport const SchemaExtractedTrace = defineTrace<SchemaExtractedTraceAttrubutes>({\n  name: 'Schema Extracted',\n  version: 0,\n  description: 'Trace emitted when extracting schema',\n})\n","import {writeFile} from 'node:fs/promises'\nimport {dirname, join} from 'node:path'\nimport {Worker} from 'node:worker_threads'\n\nimport {type CliCommandArguments, type CliCommandContext} from '@sanity/cli'\nimport readPkgUp from 'read-pkg-up'\n\nimport {\n  type ExtractSchemaWorkerData,\n  type ExtractSchemaWorkerResult,\n} from '../../threads/extractSchema'\nimport {SchemaExtractedTrace} from './extractSchema.telemetry'\n\ninterface ExtractFlags {\n  'workspace'?: string\n  'path'?: string\n  'enforce-required-fields'?: boolean\n  'format'?: 'groq-type-nodes' | string\n}\n\nexport type SchemaValidationFormatter = (result: ExtractSchemaWorkerResult) => string\n\nexport default async function extractAction(\n  args: CliCommandArguments<ExtractFlags>,\n  {workDir, output, telemetry}: CliCommandContext,\n): Promise<void> {\n  const flags = args.extOptions\n  const formatFlag = flags.format || 'groq-type-nodes'\n  const enforceRequiredFields = flags['enforce-required-fields'] || false\n\n  const rootPkgPath = readPkgUp.sync({cwd: __dirname})?.path\n  if (!rootPkgPath) {\n    throw new Error('Could not find root directory for `sanity` package')\n  }\n\n  const workerPath = join(\n    dirname(rootPkgPath),\n    'lib',\n    '_internal',\n    'cli',\n    'threads',\n    'extractSchema.js',\n  )\n\n  const spinner = output\n    .spinner({})\n    .start(\n      enforceRequiredFields\n        ? 'Extracting schema, with enforced required fields'\n        : 'Extracting schema',\n    )\n\n  const trace = telemetry.trace(SchemaExtractedTrace)\n  trace.start()\n\n  const worker = new Worker(workerPath, {\n    workerData: {\n      workDir,\n      workspaceName: flags.workspace,\n      enforceRequiredFields,\n      format: formatFlag,\n    } satisfies ExtractSchemaWorkerData,\n    // eslint-disable-next-line no-process-env\n    env: process.env,\n  })\n\n  try {\n    const {schema} = await new Promise<ExtractSchemaWorkerResult>((resolve, reject) => {\n      worker.addListener('message', resolve)\n      worker.addListener('error', reject)\n    })\n\n    trace.log({\n      schemaAllTypesCount: schema.length,\n      schemaDocumentTypesCount: schema.filter((type) => type.type === 'document').length,\n      schemaTypesCount: schema.filter((type) => type.type === 'type').length,\n      enforceRequiredFields,\n      schemaFormat: formatFlag,\n    })\n\n    const path = flags.path || join(process.cwd(), 'schema.json')\n\n    spinner.text = `Writing schema to ${path}`\n\n    await writeFile(path, `${JSON.stringify(schema, null, 2)}\\n`)\n\n    trace.complete()\n\n    spinner.succeed(\n      enforceRequiredFields\n        ? `Extracted schema to ${path} with enforced required fields`\n        : `Extracted schema to ${path}`,\n    )\n  } catch (err) {\n    trace.error(err)\n    spinner.fail(\n      enforceRequiredFields\n        ? 'Failed to extract schema, with enforced required fields'\n        : 'Failed to extract schema',\n    )\n    throw err\n  }\n}\n"],"names":["SchemaExtractedTrace","defineTrace","name","version","description","extractAction","args","workDir","output","telemetry","flags","extOptions","formatFlag","format","enforceRequiredFields","rootPkgPath","readPkgUp","sync","cwd","__dirname","path","Error","workerPath","join","dirname","spinner","start","trace","worker","Worker","workerData","workspaceName","workspace","env","process","schema","Promise","resolve","reject","addListener","log","schemaAllTypesCount","length","schemaDocumentTypesCount","filter","type","schemaTypesCount","schemaFormat","text","writeFile","JSON","stringify","complete","succeed","err","error","fail"],"mappings":";;;;;;AAWO,MAAMA,uBAAuBC,UAAAA,YAA4C;AAAA,EAC9EC,MAAM;AAAA,EACNC,SAAS;AAAA,EACTC,aAAa;AACf,CAAC;ACOD,eAA8BC,cAC5BC,MACA;AAAA,EAACC;AAAAA,EAASC;AAAAA,EAAQC,WAAAA;AAA4B,GAC/B;AACf,QAAMC,QAAQJ,KAAKK,YACbC,aAAaF,MAAMG,UAAU,mBAC7BC,wBAAwBJ,MAAM,yBAAyB,KAAK,IAE5DK,cAAcC,2BAAUC,KAAK;AAAA,IAACC,KAAKC;AAAAA,EAAU,CAAA,GAAGC;AACtD,MAAI,CAACL;AACG,UAAA,IAAIM,MAAM,oDAAoD;AAGhEC,QAAAA,aAAaC,KAAAA,KACjBC,KAAAA,QAAQT,WAAW,GACnB,OACA,aACA,OACA,WACA,kBACF,GAEMU,UAAUjB,OACbiB,QAAQ,CAAE,CAAA,EACVC,MACCZ,wBACI,qDACA,mBACN,GAEIa,QAAQlB,WAAUkB,MAAM3B,oBAAoB;AAClD2B,QAAMD,MAAM;AAENE,QAAAA,SAAS,IAAIC,oBAAAA,OAAOP,YAAY;AAAA,IACpCQ,YAAY;AAAA,MACVvB;AAAAA,MACAwB,eAAerB,MAAMsB;AAAAA,MACrBlB;AAAAA,MACAD,QAAQD;AAAAA,IACV;AAAA;AAAA,IAEAqB,KAAKC,QAAQD;AAAAA,EAAAA,CACd;AAEG,MAAA;AACI,UAAA;AAAA,MAACE;AAAAA,QAAU,MAAM,IAAIC,QAAmC,CAACC,SAASC,WAAW;AACjFV,aAAOW,YAAY,WAAWF,OAAO,GACrCT,OAAOW,YAAY,SAASD,MAAM;AAAA,IAAA,CACnC;AAEDX,UAAMa,IAAI;AAAA,MACRC,qBAAqBN,OAAOO;AAAAA,MAC5BC,0BAA0BR,OAAOS,OAAQC,UAASA,KAAKA,SAAS,UAAU,EAAEH;AAAAA,MAC5EI,kBAAkBX,OAAOS,OAAQC,UAASA,KAAKA,SAAS,MAAM,EAAEH;AAAAA,MAChE5B;AAAAA,MACAiC,cAAcnC;AAAAA,IAAAA,CACf;AAED,UAAMQ,SAAOV,MAAMU,QAAQG,UAAKW,QAAQhB,OAAO,aAAa;AAE5DO,YAAQuB,OAAO,qBAAqB5B,MAAI,IAExC,MAAM6B,GAAAA,UAAU7B,QAAM,GAAG8B,KAAKC,UAAUhB,QAAQ,MAAM,CAAC,CAAC;AAAA,CAAI,GAE5DR,MAAMyB,SAAS,GAEf3B,QAAQ4B,QACNvC,wBACI,uBAAuBM,MAAI,mCAC3B,uBAAuBA,MAAI,EACjC;AAAA,WACOkC,KAAK;AACNC,UAAAA,MAAAA,MAAMD,GAAG,GACf7B,QAAQ+B,KACN1C,wBACI,4DACA,0BACN,GACMwC;AAAAA,EAAAA;AAEV;;"}